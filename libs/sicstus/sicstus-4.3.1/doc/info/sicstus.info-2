This is info/sicstus.info, produced by makeinfo version 4.13 from
sicstus.texi.

INFO-DIR-SECTION SICStus Prolog
START-INFO-DIR-ENTRY
* SICStus Prolog Manual: (sicstus).			SICStus Prolog User's Manual.
END-INFO-DIR-ENTRY
   Generated 27 November 2014.


File: sicstus.info,  Node: ref-lte-acl,  Next: ref-lte-c2t,  Prev: ref-lte-act,  Up: ref-lte

4.8.3 Analyzing and Constructing Lists
--------------------------------------

To combine two lists to form a third list, use `append(HEAD, TAIL,
LIST)'.

   To analyze a list into its component lists in various ways, use
`append/3' with LIST instantiated to a proper list.  The reference page
for `append/3' includes examples of its usage, including backtracking.

   To check the length of a list call `length(LIST, LENGTH)'.

   To produce a list of a certain length, use `length/2' with LENGTH
instantiated and LIST uninstantiated or instantiated to a list whose
tail is a variable.

   To check if a term is the element of a list, use `memberchk(ELEMENT,
LIST)'.

   To enumerate the elements of a list via backtracking, use
`member(ELEMENT, LIST)'.

   To check that a term is NOT the element of a list, use
`nonmember(ELEMENT, LIST)', which is equivalent to `\+member(ELEMENT,
LIST)'.


File: sicstus.info,  Node: ref-lte-c2t,  Next: ref-lte-atm,  Prev: ref-lte-acl,  Up: ref-lte

4.8.4 Converting between Constants and Text
-------------------------------------------

Three predicates convert between constants and lists of character
codes:  `atom_codes/2', `number_codes/2', and `name/2'.  Two predicates
convert between constants and lists of character atoms:
`atom_chars/2', `number_chars/2'.

   `atom_codes(ATOM, CODES)' is a relation between an atom ATOM and a
list CODES consisting of the character codes comprising the printed
representation of ATOM.  Initially, either ATOM must be instantiated to
an atom, or CODES must be instantiated to a proper code-list.

   `number_codes(NUMBER, CODES)' is a relation between a number NUMBER
and a list CODES consisting of the character codes comprising the
printed representation of NUMBER.  Initially, either NUMBER must be
instantiated to a number, or CODES must be instantiated to a proper
code-list.

   Similarly, `atom_chars(ATOM, CHARS)' and `number_chars(ATOM, CHARS)'
are relations between a constant and a list consisting of the character
atoms comprising the printed representation of the constant.

   `name/2' converts between a constant and a code-list.  Given a
code-list, `name/2' will convert it to a number if it can, otherwise to
an atom.  This means that there are atoms that can be constructed by
`atom_codes/2' but not by `name/2'.  `name/2' is retained for backwards
compatibility with other Prologs.  New programs should use
`atom_codes/2' or `number_codes/2' as appropriate.

   `char_code/2' converts between a character atom and a character code.


File: sicstus.info,  Node: ref-lte-atm,  Next: ref-lte-anv,  Prev: ref-lte-c2t,  Up: ref-lte

4.8.5 Atom Operations
---------------------

To compute LENGTH, the number of characters of the atom ATOM, use:

     ?- atom_length(ATOM,LENGTH).

   To concatenate ATOM1 with ATOM2 giving ATOM12, use the following.
The predicate can also be used to split a given ATOM12 into two unknown
parts:

     ?- atom_concat(ATOM1,ATOM2,ATOM12).

   To extract a sub-atom SUBATOM from ATOM, such that the number of
characters preceding SUBATOM is BEFORE, the number of characters after
SUBATOM is AFTER, and the length of SUBATOM is LENGTH, use the
following. Only ATOM needs to be instantiated:

     ?- sub_atom(ATOM,BEFORE,LENGTH,AFTER,SUBATOM).


File: sicstus.info,  Node: ref-lte-anv,  Next: ref-lte-cpt,  Prev: ref-lte-atm,  Up: ref-lte

4.8.6 Assigning Names to Variables
----------------------------------

Each variable in a term is instantiated to a term of the form
`'$VAR'(N)', where N is an integer, by the predicate `numbervars/3'.
The "write" predicates (`write/[1,2]', `writeq/[1,2]', and
`write_term/[2,3]' with the `numbervars(true)' option) transform these
terms into variable names starting with upper case letters.


File: sicstus.info,  Node: ref-lte-cpt,  Next: ref-lte-cte,  Prev: ref-lte-anv,  Up: ref-lte

4.8.7 Copying Terms
-------------------

The meta-logical predicate `copy_term/2' makes a copy of a term in
which all variables have been replaced by brand new variables, and all
mutables by brand new mutables.  This is precisely the effect that would
have been obtained from the definition:
     copy_term(Term, Copy) :-
        recorda(copy, copy(Term), DBref),
        instance(DBref, copy(Temp)),
        erase(DBref),
        Copy = Temp.

although the built-in predicate `copy_term/2' is more efficient.

   When you call `clause/[2,3]' or `instance/2', you get a new copy of
the term stored in the database, in precisely the same sense that
`copy_term/2' gives you a new copy.  One of the uses of `copy_term/2'
is in writing interpreters for logic-based languages; with
`copy_term/2' available you can keep "clauses" in a Prolog data
structure and pass this structure as an argument without having to
store the "clauses" in the Prolog database.  This is useful if the set
of "clauses" in your interpreted language is changing with time, or if
you want to use clever indexing methods.

   A naive way to attempt to find out whether one term is a copy of
another is shown in this example:
     identical_but_for_variables(X, Y) :-
        \+ \+ (
           numbervars(X, 0, N),
           numbervars(Y, 0, N),
           X = Y
        ).

   This solution is sometimes sufficient, but will not work if the two
terms have any variables in common.  If you want the test to succeed
even when the two terms do have some variables in common, you need to
copy one of them; for example,
     identical_but_for_variables(X, Y) :-
        \+ \+ (
           copy_term(X, Z),
           numbervars(Z, 0, N),
           numbervars(Y, 0, N),
           Z = Y
        ).

   *Please note*: If the term being copied contains attributed variables
(*note lib-atts::) or suspended goals (*note ref-sem-sec::), those
attributes are not retained in the copy.  To retain the attributes, you
can use:

     copy_term(Term, Copy, Body)

which in addition to copying the term unifies BODY with a goal such
that executing BODY will reinstate the attributes in the COPY.  COPY as
well as BODY contain brand new (unattributed) variables only.

   `copy_term/2' is efficient enough to use without hesitation if there
is no solution that does not require the use of meta-logical
predicates.  However, for the sake of both clarity and efficiency, such
a solution should be sought before using `copy_term/2'.  *Note
mpg-ref-copy_term::.


File: sicstus.info,  Node: ref-lte-cte,  Next: ref-lte-mut,  Prev: ref-lte-cpt,  Up: ref-lte

4.8.8 Comparing Terms
---------------------

* Menu:

* ref-lte-cte-bas::                     Introduction
* ref-lte-cte-sot::                     Standard Order of Terms
* ref-lte-cte-sor::                     Sorting Terms


File: sicstus.info,  Node: ref-lte-cte-bas,  Next: ref-lte-cte-sot,  Up: ref-lte-cte

4.8.8.1 Introduction
....................

The predicates described in this section are used to compare and order
terms, rather than to evaluate or process them.  For example, these
predicates can be used to compare variables; however, they never
instantiate those variables.  These predicates should not be confused
with the arithmetic comparison predicates (see *note ref-ari-acm::) or
with unification.


File: sicstus.info,  Node: ref-lte-cte-sot,  Next: ref-lte-cte-sor,  Prev: ref-lte-cte-bas,  Up: ref-lte-cte

4.8.8.2 Standard Order of Terms
...............................

These predicates use a standard total order when comparing terms.  The
standard total order is:

   * Variables, by age (oldest first--the order is _not_ related to the
     names of variables).

   * Floats, in numeric order (e.g. -1.0 is put before 1.0).

   * Integers, in numeric order (e.g. -1 is put before 1).

   * Atoms, in alphabetical (i.e. character code) order.

   * Compound terms, ordered first by arity, then by the name of the
     principal functor, then by age for mutables and by the arguments
     in left-to-right order for other terms.  Recall that lists are
     equivalent to compound terms with principal functor `./2'.

   For example, here is a list of terms in standard order:

     [ X, -1.0, -9, 1, fie, foe, X = Y, foe(0,2), fie(1,1,1) ]

     *Please note*: the standard order is only well-defined for finite
     (acyclic) terms.  There are infinite (cyclic) terms for which no
     order relation holds.  Furthermore, blocking goals (*note
     ref-sem-sec::) on variables or modifying their attributes (*note
     lib-atts::) does not preserve their order.

   The predicates for comparison of terms are described below.

+T1 `==' +T2
     T1 and T2 are literally identical  (in  particular,  variables in
     equivalent positions in the two terms must be identical).

+T1 `\==' +T2
     T1 and T2 are _not_ literally identical.

+T1 `@<' +T2
     T1 is before term T2 in the standard order.

+T1 `@>' +T2
     T1 is after term T2

+T1 `@=<' +T2
     T1 is not after term T2

+T1 `@>=' +T2
     T1 is not before term T2

`compare(-OP, +T1, +T2)'
     the result of comparing terms T1 and T2 is OP, where the possible
     values for OP are:

    `='
          if T1 is identical to T2,

    `<'
          if T1 is before T2 in the standard order,

    `>'
          if T1 is after T2 in the standard order.



File: sicstus.info,  Node: ref-lte-cte-sor,  Prev: ref-lte-cte-sot,  Up: ref-lte-cte

4.8.8.3 Sorting Terms
.....................

Two predicates, `sort/2' and `keysort/2' sort lists into the standard
order.  `keysort/2' takes a list consisting of key-representation pairs and sorts
according to the key.

   Further sorting predicates are available in `library(samsort)'.


File: sicstus.info,  Node: ref-lte-mut,  Next: ref-lte-sum,  Prev: ref-lte-cte,  Up: ref-lte

4.8.9 Mutable Terms
-------------------

One of the tenets of logic programming is that terms are immutable
objects of the Herbrand universe, and the only sense in which they can
be modified is by means of instantiating non-ground parts.  There are,
however, algorithms where destructive assignment is essential for
performance.  Although alien to the ideals of logic programming, this
feature can be defended on practical grounds.

   SICStus Prolog provides an abstract datatype and four operations for
efficient _backtrackable_ destructive assignment.  In other words, any
destructive assignments are transparently undone on backtracking.
Modifications that are intended to survive backtracking must be done by
asserting or retracting dynamic program clauses instead.  Unlike
previous releases of SICStus Prolog, destructive assignment of
arbitrary terms is not allowed.

   A "mutable term" is represented as a compound term with a reserved
functor: `'$mutable'(VALUE,TIMESTAMP)' where VALUE is the current representation
and TIMESTAMP is reserved for bookkeeping purposes [Aggoun & Beldiceanu
90].

   Any copy of a mutable term created by `copy_term/[2,3]', `assert',
`retract', a database predicate, or an all solutions predicate, is an
independent copy of the original mutable term.  Any destructive
assignment done to one of the copies will not affect the other copy.

   The following operations are provided:

`create_mutable(+DATUM,-MUTABLE)'
     DATUM.

`get_mutable(-DATUM,+MUTABLE)'
     The current representation of the mutable term MUTABLE is DATUM.

`update_mutable(+DATUM,+MUTABLE)'
     Updates the current representation of the mutable term MUTABLE to become
     DATUM.

`mutable(+MUTABLE)'
     X is currently instantiated to a mutable term.

     *Please note*: the effect of unifying two mutables is undefined.


File: sicstus.info,  Node: ref-lte-sum,  Prev: ref-lte-mut,  Up: ref-lte

4.8.10 Summary of Predicates
----------------------------

`atom(+T)   "ISO"'
     term T is an atom

`atomic(+T)   "ISO"'
     term T is an atom or a number

`callable(+T)'
     T is an atom or a compound term

`compound(+T)   "ISO"'
     T is a compound term

`db_reference(+X)   *since release 4.1*'
     X is a db_reference

`float(+N)   "ISO"'
     N is a floating-point number

`ground(+T)'
     term T is a nonvar, and all substructures are nonvar

`integer(+T)   "ISO"'
     term T is an integer

`mutable(+X)'
     X is a mutable term

`nonvar(+T)   "ISO"'
     term T is one of atom, number, compound (that is, T is
     instantiated)

`number(+N)   "ISO"'
     N is an integer or a float

`simple(+T)'
     T is not a compound term; it is either atomic or a var

`var(+T)   "ISO"'
     term T is a variable (that is, T is uninstantiated)


`compare(-C,+X,+Y)'
     C is the result of comparing terms X and Y

`+X == +Y   "ISO"'
     terms X and Y are strictly identical

`+X \== +Y   "ISO"'
     terms X and Y are not strictly identical

`+X @< +Y   "ISO"'
     term X precedes term Y in standard order for terms

`+X @>= +Y   "ISO"'
     term X follows or is identical to term Y in standard order for
     terms

`+X @> +Y   "ISO"'
     term X follows term Y in standard order for terms

`+X @=< +Y   "ISO"'
     term X precedes or is identical to term Y in standard order for
     terms


`?T =.. ?L   "ISO"'
     the functor and arguments of term T comprise the list L

`?X = ?Y   "ISO"'
     terms X and Y are unified

`+X \= +Y   "ISO"'
     terms X and Y no not unify

`?=(+X,+Y)'
     X and Y are either strictly identical or don't unify

`acyclic_term(+T)   *since release 4.3, ISO*'
     term T is a finite (acyclic) term

`arg(+N,+T,-A)   "ISO"'
     the Nth argument of term T is A

`atom_chars(?A,?L)   "ISO"'
     A is the atom containing the character atoms in list L

`atom_codes(?A,?L)   "ISO"'
     A is the atom containing the characters in code-list L

`atom_concat(?ATOM1,?ATOM2,?ATOM12)   "ISO"'
     Atom ATOM1 concatenated with ATOM2 gives ATOM12.

`atom_length(+ATOM,-LENGTH)   "ISO"'
     LENGTH is the number of characters of the atom ATOM.

`char_code(?CHAR,?CODE)   "ISO"'
     CODE is the character code of the one-char atom CHAR.

`copy_term(+T,-C)   "ISO"'
     C is a copy of T in which all variables have been replaced by new
     variables

`copy_term(+T,-C,-G)'
     C is a copy of T in which all variables have been replaced by new
     variables, and G is a goal for reinstating any attributes in C

`create_mutable(+DATUM,-MUTABLE)'
     MUTABLE is a new mutable term with current representation DATUM.

`dif(+X,+Y)'
     X and Y are constrained to be different.

`frozen(+VAR,-GOAL)'
     The goal GOAL is blocked on the variable VAR.

`functor(?T,?F,?N)   "ISO"'
     the principal functor of term T has name F and arity N

`get_mutable(-DATUM,+MUTABLE)'
     The current representation of the mutable term MUTABLE is DATUM.

`name(?A,?L)'
     the code-list of atom or number A is L

`number_chars(?N,?L)   "ISO"'
     N is the numeric representation of list of character atoms L

`number_codes(?N,?L)   "ISO"'
     N is the numeric representation of code-list L

`numbervars(+T,+M,-N)'
     number the variables in term T from M to N-1

`sub_atom(+ATOM,?BEFORE,?LENGTH,?AFTER,?SUBATOM)   "ISO"'
     The characters of SUBATOM form a sublist of the characters of
     ATOM, such that the number of characters preceding SUBATOM is
     BEFORE, the number of characters after SUBATOM is AFTER, and the
     length of SUBATOM is LENGTH.

`subsumes_term(General,Specific)   *since release 4.3, ISO*'
     SPECIFIC is an instance of GENERAL

`term_variables(+TERM,-VARIABLES)   *since release 4.3, ISO*'
     VARIABLES is the set of variables that occur in TERM

`unify_with_occurs_check(?X,?Y)   "ISO"'
     True if X and Y unify to a finite (acyclic) term.


`?T =.. ?L   "ISO"'
     the functor and arguments of term T comprise the list L

`append(?A,?B,?C)'
     the list C is the concatenation of lists A and B

`keysort(+L,-S)'
     the list L sorted by key yields S

`length(?L,?N)'
     the length of list L is N

`member(?X,?L)'
     X is a member of L

`memberchk(+X,+L)'
     X is a member of L

`nonmember(+X,+L)'
     X is not a member of L

`sort(+L,-S)'
     sorting the list L into order yields S



File: sicstus.info,  Node: ref-lps,  Next: ref-mgc,  Prev: ref-lte,  Up: Prolog Intro

4.9 Looking at the Program State
================================

* Menu:

* ref-lps-ove::                         Overview
* ref-lps-app::                         Associating Predicates with their Properties
* ref-lps-apf::                         Associating Predicates with Files
* ref-lps-flg::                         Prolog Flags
* ref-lps-lco::                         Load Context
* ref-lps-sum::                         Predicate Summary


File: sicstus.info,  Node: ref-lps-ove,  Next: ref-lps-app,  Up: ref-lps

4.9.1 Overview
--------------

Various aspects of the program state can be inspected: the clauses of
all or selected dynamic procedures, currently available atoms, user
defined predicates, source files of predicates and clauses, predicate
properties and the current load context can all be accessed by calling
the predicates listed in *note ref-lps-ove::.  Furthermore, the values
of Prolog flags can be inspected and, where it makes sense, changed.


File: sicstus.info,  Node: ref-lps-app,  Next: ref-lps-apf,  Prev: ref-lps-ove,  Up: ref-lps

4.9.2 Associating Predicates with their Properties
--------------------------------------------------

The following properties are associated with predicates either
implicitly or by declaration:

`built_in'
     The predicate is built-in.

`compiled'
     The predicate is in virtual code representation.

`interpreted'
     The predicate is in interpreted representation.

`fd_constraint'
     The predicate is a so-called FD predicate; *note Defining
     Primitive Constraints::.

`dynamic'
     The predicate was declared dynamic.

`volatile'
     The predicate was declared volatile.

`multifile'
     The predicate was declared multifile.

`block(SKELETALGOAL)'
     The predicate has block declarations.

`meta_predicate(SKELETALGOAL)'
     The predicate is a meta-predicate.

     As of release 4.2, the SKELETALGOAL will contain the
     specifications used in the original meta-predicate declaration.

`exported'
     The predicate was exported from a module.

`imported_from(MODULE)'
     The predicate was imported from the module MODULE.

   Every predicate has exactly one of the properties `[built_in,
compiled, interpreted, fd_constraint]', at most one of the properties

   `[exported, imported_from(SKELETALGOAL)]', zero or more
`block(SKELETALGOAL)' properties, and at most one of the remaining
properties.

   To query these associations, use `predicate_property/2'.  The
reference page contains several examples.  *Note
mpg-ref-predicate_property::.


File: sicstus.info,  Node: ref-lps-apf,  Next: ref-lps-flg,  Prev: ref-lps-app,  Up: ref-lps

4.9.3 Associating Predicates with Files
---------------------------------------

Information about loaded files and the predicates and clauses in them
is returned by `source_file/[1,2]'.  `source_file/1' can be used to
identify an absolute filename as loaded, or to backtrack through all
loaded files.  To find out the correlation between loaded files and
predicates, call `source_file/2'.  *Note mpg-ref-source_file::.


File: sicstus.info,  Node: ref-lps-flg,  Next: ref-lps-lco,  Prev: ref-lps-apf,  Up: ref-lps

4.9.4 Prolog Flags
------------------

Certain aspects of the state of the program are accessible as values of
the global Prolog flags.  Some of these flags are read-only and
correspond to implementation defined properties and exist to aid
portability.  Others can be set and impact the behavior of certain
built-in predicates.

   The flags are accessed by the built-in predicates
`prolog_flag/[2,3]', `current_prolog_flag/2', and `set_prolog_flag/2'.

   *Please note*: Prolog flags are _global_, as opposed to being local
to the current module, Prolog text, or otherwise.

   The possible Prolog flag names and values are listed below. Flags
annotated "ISO" are prescribed by the ISO standard. Flags annotated
"volatile" are not saved by `save_program/[1,2]'.  Flags annotated
"read-only" are read-only:

`agc_margin'
     An integer MARGIN.  The atoms will be garbage collected when
     MARGIN new atoms have been created since the last atom garbage
     collection.  Initially 10000.

`argv   *volatile*'
     The representation is a list of atoms of the program arguments supplied
     when the current SICStus Prolog process was started.  For example,
     if SICStus Prolog were invoked with:

          % sicstus -- hello world 2001

     the representation will be `[hello,world,'2001']'.

     Setting the representation can be useful when writing test cases for code
     that expects to be run with command line parameters.

`bounded         *ISO,read-only,volatile*'
     One of the flags defining the integer type. For SICStus, its representation
     is `false', indicating that the domain of integers is practically
     unbounded.

`char_conversion         *ISO,volatile*'
     If this flag is `on', unquoted characters in terms and programs
     read in will be converted, as specified by previous invocations of
     `char_conversion/2'. If the flag is `off' no conversion will take
     place. The default representation is `on'.

`compiling'
     Governs the mode in which `compile/1' operate (*note ref-lod::).

    `compactcode'
          Compilation produces byte-coded abstract instructions (the
          default).

    `debugcode'
          Compiling is replaced by consulting.

`debugging   *volatile*'
     Corresponds to the predicates `debug/0', `nodebug/0', `trace/0',
     `notrace/0', `zip/0', `nozip/0'. The flag describes the mode the
     debugger is in, or is required to be switched to:

    `trace'
          Trace mode (the debugger is creeping).

    `debug'
          Debug mode (the debugger is leaping).

    `zip'
          Zip mode (the debugger is zipping).

    `off'
          The debugger is switched off (the default).

`debug         *ISO,volatile*'
     The flag `debug', prescribed by the ISO Prolog standard, is a
     simplified form of the `debugging' flag:

    `off   "ISO"'
          The debugger is switched off (the default).

    `on   "ISO"'
          The debugger is switched on (to trace mode, if previously
          switched off).

`profiling   *since release 4.2*'
     This flag describes the mode the execution profiler (*note
     Execution Profiling::) is in, or is required to be switched to:

    `off'
          The profiler is switched off (the default).

    `on'
          The profiler is switched on.

     (The flags `profiling', `debugging' and `debug' have no effect in
     runtime systems.)

`double_quotes         *ISO,volatile*'
     Governs the interpretation of double quoted strings (*note
     ref-syn-cpt-sli::):

    `codes   "ISO"'
          Code-list comprising the string.  The default.

    `chars   "ISO"'
          Char-list comprising the string.

    `atom   "ISO"'
          The atom composed of the same characters as the string.

`quoted_charset'
     This flag is relevant when `quoted(true)' holds when writing terms.
     Its representation should be one of the atoms:

    `portable'
          Atoms and functors are written using character codes less
          than 128 only, i.e. using the 7-bit subset of the ISO-8859-1
          (Latin 1) character set (*note ref-syn-syn-tok::).

    `prolog'
          Atoms and functors are written using a character set that can
          be read back by `read/[1,2]'. This is a subset of Unicode
          that includes all of ISO-8859-1 (Latin 1) as well as some
          additional characters.

          This character set may grow but not shrink in subsequent
          releases. This ensures that future releases can always read a
          term written by an older release.

          Note that the character set supported by the stream is not
          taken into account. You can use `portable' instead of
          `prolog' if the stream does not support Unicode.


`debugger_print_options'
     The representation is a list of options for `write_term/3' (*note
     ref-iou-tou-wrt::), to be used in the debugger's messages.  The
     initial representation is
     `[quoted(true),numbervars(true),portrayed(true),max_depth(10)]'.

`dialect   *since release 4.1,read-only*'
     The representation of this flag is `sicstus'. It is useful for
     distinguishing between Prolog implementations.

     Also see the Prolog flag `version_data', below.

`discontiguous_warnings   *volatile*'
     `on' or `off'.  Enable or disable warning messages when clauses
     are not together in source files.  Initially `on' in development
     systems, `off' in runtime systems.

`fileerrors'
     `on' or `off'.  Enables or disables raising of file error
     exceptions.  Initially `on' (enabled).

`gc'
     `on' or `off'.  Enables or disables garbage collection of the
     global stack.  Initially `on' (enabled).  

`gc_margin'
     MARGIN: At least MARGIN kilobytes of free global stack space are
     guaranteed to exist after a garbage collection.  Also, no garbage
     collection is attempted unless the global stack is at least MARGIN
     kilobytes.  Initially 1000.

`gc_trace'
     Governs global stack garbage collection trace messages.

    `verbose'
          Turn on verbose tracing of garbage collection.

    `terse'
          Turn on terse tracing of garbage collection.

    `off'
          Turn off tracing of garbage collection (the default).

`host_type   *read-only,volatile*'
     The representation is an atom identifying the platform on which SICStus was
     compiled, such as `'x86-linux-glibc2.1'' or `'sparc-solaris-5.7''.

`informational   *volatile*'
     `on' or `off'.  Enables or disables the printing of informational
     messages.  Initially `on' (printing enabled) in development
     systems, unless the `--noinfo' command line option was used; `off'
     (printing disabled) in runtime systems.

`integer_rounding_function         *ISO,read-only,volatile*'
     One of the flags defining the integer type. In SICStus Prolog its
     representation is `toward_zero', indicating that the integer division
     (`(//)/2') and integer remainder (`rem/2') arithmetic functions
     use rounding toward zero; *note ref-ari::.

`legacy_char_classification   *since release 4.0.3,volatile*'
     `on' or `off'.  When enabled, most legal Unicode codepoints above
     255 are treated as lowercase characters when reading Prolog terms.
     This improves compatibility with earlier versions of SICStus
     Prolog and makes it possible to use full Unicode, e.g. Chinese
     characters, in unquoted atoms as well as variable names, *note
     ref-syn-syn-tok::.  Initially `off' (disabled).

     Setting this flag affects the `read_term/[2,3]' option
     `singletons/1'; see *note mpg-ref-read_term::. It also affects the
     style warning for singleton variables; see the description of the
     `single_var_warnings' in *note The Load Predicates: ref-lod-lod.

`max_arity         *ISO,read-only,volatile*'
     Specifies the maximum arity allowed for a compound term. In
     SICStus Prolog this is 255.

`max_integer         *ISO,read-only,volatile*'
     Specifies the largest possible integer representation. As in SICStus Prolog
     the range of integers in not bounded, `prolog_flag/[2,3]' and
     `current_prolog_flag/2' will fail when accessing this flag.

`max_tagged_integer   *since release 4.1,read-only,volatile*'
     The largest small integer, i.e. integers larger than this are less
     efficient to manipulate and are not available in `library(clpfd)'.

`min_integer         *ISO,read-only,volatile*'
     Specifies the smallest possible integer representation. As in SICStus
     Prolog the range of integers in not bounded, `prolog_flag/[2,3]'
     and `current_prolog_flag/2' will fail, when accessing this flag.

`min_tagged_integer   *since release 4.1,read-only,volatile*'
     The smallest small integer, i.e. integers smaller than this are
     less efficient to manipulate and are not available in
     `library(clpfd)'.

`os_data   *since release 4.1,read-only,volatile*'
     The representation is a term `os(Family,Name,Extra)' describing the
     operating system on which this SICStus process is running, i.e. it
     is the runtime version of the `platform_data' flag, below.

     FAMILY has the same representation and meaning as for the `platform_data'
     flag, below.

     On UNIX-like systems the NAME is the lower case representation `sysname'
     returned from `uname(3)' at runtime, i.e. the same as from the
     comamnd `uname -s'. On all supported versions of Microsoft Windows
     this is `win32nt'.

     `Extra' is a list of extra information. Entries may be added to
     this list without prior notice.

     Currently, at least up to release 4.2.3, the FAMILY and NAME for
     the `platform_data' and `os_data' flags happens to be the same but
     this may change in the unlikely case that the operating system
     starts to return something new. For this reason it is probably
     better to use `platform_data' than `os_data' in most cases.

     The `Extra' representation for `os_data' may differ from its
     `platform_data' counterpart in order to accurately describe the
     running operating system.

`platform_data   *since release 4.1,read-only,volatile*'
     The representation is a term `platform(Family,Name,Extra)' describing the
     operating system platform for which this version of SICStus was
     built.

     FAMILY describes the family or class of operating system.
     Currently documented values are `unix', for UNIX-like systems like
     Linux, OS X, Solaris and Androind; and `windows' for all supported
     versions of Microsoft Windows. You should not assume that these
     are the only two possibilities.

     NAME describes the name of the operating system. On UNIX-like
     systems this correspond to the (lower case) output from `uname
     -s'. Currently documented values are `linux', `darwin', `sunos',
     `android' and `win32nt'.

     Note that this implies that some operating systems may have
     unexpected names. In particular the name for Apple OS X is
     `darwin', for Oracle Solaris it is `sunos' and for 64-bit versions
     of SICStus on Microsoft Windows it is `win32nt'.

     `Extra' is bound to a list of extra information. Entries may be
     added to this list without prior notice.

`redefine_warnings'
     Enable or disable warning messages when:

        * a module or predicate is being redefined from a different
          file than its previous definition.  Such warnings are
          currently not issued when a `.po' file is being loaded.

        * a predicate is being imported while it was locally defined
          already.

        * a predicate is being redefined locally while it was imported
          already.

        * a predicate is being imported while it was imported from
          another module already.

     The possible values are:

    `on'
          The default in development systems.  The user is queried
          about what to do in each case.

    `off'
          The default in runtime systems, but note that this flag is
          not "volatile".  Redefinitions are performed silently, as if
          the user had accepted them.

    `reject   *since release 4.0.3*'
          Redefinitions are refused silently, as if the user had
          rejected them.

    `proceed   *since release 4.0.3*'
          Redefinitions are performed, and warnings are issued.

    `suppress   *since release 4.0.3*'
          Redefinitions are refused, and warnings are issued.

`single_var_warnings   *volatile*'
     `on' or `off'.  Enable or disable warning messages when a SENTENCE
     (*note ref-syn-syn-sen::) containing variables not beginning with
     `_' occurring once only is compiled or consulted.  Initially `on'
     in development systems, `off' in runtime systems.

`source_info   *volatile*'
     `emacs' or `on' or `off'.  If not `off' while source code is being
     loaded, information about line numbers and file names are stored
     with the loaded code.  If the representation is `on' while debugging, this
     information is used to print the source code location while
     prompting for a debugger command.  If the representation is `on' while
     printing an uncaught error exception message, the information is
     used to print the source code location of the culprit goal or one
     of its ancestors, as far as it can be determined.  If the representation is
     `emacs' in any of these cases, the appropriate line of code is
     instead highlighted, and no extra text is printed.  The representation is
     `off' initially, and that is its only available representation in runtime
     systems.

`syntax_errors'
     Controls what action is taken upon syntax errors in `read/[1,2]'.

    `dec10'
          The syntax error is reported and the read is repeated.

    `error'
          An exception is raised.  *Note ref-ere::. (the default).

    `fail'
          The syntax error is reported and the read fails.

    `quiet'
          The read quietly fails.

`system_type   *read-only,volatile*'
     The representation is `development' in development systems and `runtime' in
     runtime systems.

`title'
     The window title. The default representation is the same as the boot message
     `SICStus 4.3.1 ...  Licensed to SICS'. It is currently only used
     as the window title on the Windows platform.

`toplevel_print_options'
     The representation is a list of options for `write_term/3' (*note
     ref-iou-tou-wrt::), to be used when the top-level displays
     variable bindings and answer constraints.  It is also used when
     messages are displayed.  The initial representation is
     `[quoted(true),numbervars(true),portrayed(true),max_depth(10)]'.

`typein_module'
     Permitted values are atoms.  Controls the current type-in module
     (*note ref-mod-tyi::).  Corresponds to the predicate
     `set_module/1'.  

`unknown         "ISO"'
     The system can optionally catch calls to predicates that have no
     definition. First, the user defined predicate
     `user:unknown_predicate_handler/3' (*note ref-ere::) is called.  If
     undefined or if the call fails, the action is governed by the
     state of the this flag, which can be:

    `trace'
          Causes calls to undefined predicates to be reported and the
          debugger to be entered at the earliest opportunity.  Not
          available in runtime systems.

    `error   "ISO"'
          Causes calls to such predicates to raise an exception (the
          default). *Note ref-ere::.

    `warning   "ISO"'
          Causes calls to such predicates to display a warning message
          and then fail.

    `fail   "ISO"'
          Causes calls to such predicates to fail.

`user_input   *volatile*'
     Permitted values are any stream opened for reading.  Controls
     which stream is referenced by `user_input' and `SP_stdin'. It is
     initially set to a stream connected to UNIX `stdin'.

`user_output   *volatile*'
     Permitted values are any stream opened for writing.  Controls
     which stream is referenced by `user_output' and `SP_stdout'. It is
     initially set to a stream connected to UNIX `stdout'.

`user_error   *volatile*'
     Permitted values are any stream opened for writing.  Controls
     which stream is referenced by `user_error' and `SP_stderr'. It is
     initially set to a stream connected to UNIX `stderr'.

`version   *read-only,volatile*'
     The representation is an atom containing the banner text displayed on
     startup, such as `'SICStus 4.1.0 (i386-darwin-9.8.0): Wed Oct 14
     14:43:58 CEST 2009''.

     Also see the Prolog flag `version_data', below.

`version_data   *since release 4.1,read-only,volatile*'
     The representation is a term `sicstus(Major,Minor,Revision,Beta,Extra)' with
     integer major, minor, revision, and beta version.

     `Extra' is bound to a list of extra information. Entries may be
     added to this list without prior notice.

     Also see the Prolog flag `dialect', above.


   You can use `prolog_flag/2' to enumerate all the FLAGNAMEs that the
system currently understands, together with their current values.  Use
`prolog_flag/2' to make queries, `prolog_flag/3' to make changes.


File: sicstus.info,  Node: ref-lps-lco,  Next: ref-lps-sum,  Prev: ref-lps-flg,  Up: ref-lps

4.9.5 Load Context
------------------

When a Prolog source file is being read in, some aspects of the load
context can be accessed by the built-in predicate
`prolog_load_context/2', which accesses the representation of a given key. The
available keys are:

`source'
     The absolute path name of the file being loaded. During loading of
     a PO file, the corresponding source file name is returned.

`file'
     Outside included files (*note Include Declarations::) this is the
     same as the `source' key. In included files this is the absolute
     path name of the file being included.

`directory'
     The absolute path name of the directory of the file being loaded.
     In included files this is the directory of the file being included.

`module'
     The source module (*note ref-mod-mne::).  This is useful for
     example if you are defining clauses for `user:term_expansion/6'
     and need to access the source module at compile time.

`stream'
     The stream being loaded.  This key is not available during loading
     of a PO file.

`term_position'
     A term representing the stream position of the last clause read.
     This key is not available during loading of a PO file.


File: sicstus.info,  Node: ref-lps-sum,  Prev: ref-lps-lco,  Up: ref-lps

4.9.6 Predicate Summary
-----------------------

`current_atom(?A)'
     backtrack through all atoms

`current_module(?M)'
     M is the name of a current module

`current_module(?M,?F)'
     F is the name of the file in which M's module declaration appears

`current_predicate(:A/?N)   "ISO"'
`current_predicate(?A,:P)'
     A is the name of a predicate with most general goal P and arity N

`current_prolog_flag(?F,?V)   "ISO"'
     V is the current representation of Prolog flag F

`listing'
     list all dynamic procedures in the type-in module

`listing(:P)'
     list the dynamic procedure(s) specified by P

`predicate_property(:P,?PROP)'
     PROP is a property of the loaded predicate P

`prolog_flag(?F,?V)'
     V is the current representation of Prolog flag F

`prolog_flag(+F,=O,+N)'
     O is the old representation of Prolog flag F; N is the new representation

`prolog_load_context(?K,?V)'
     find out the context of the current load

`set_module(+M)'
     make M the type-in module

`set_prolog_flag(+F,+N)   "ISO"'
     N is the new representation of Prolog flag F

`source_file(?F)'
     F is a source file that has been loaded into the database

`source_file(:P,?F)'
     P is a predicate defined in the loaded file F

`unknown(-O,+N)   *development*'
     Changes action on undefined predicates from O to N.



File: sicstus.info,  Node: ref-mgc,  Next: ref-mod,  Prev: ref-lps,  Up: Prolog Intro

4.10 Memory Use and Garbage Collection
======================================

* Menu:

* ref-mgc-ove::                         Overview
* ref-mgc-gcp::                         Garbage Collection and Programming Style
* ref-mgc-egc::                         Enabling and Disabling the Garbage Collector
* ref-mgc-mgc::                         Monitoring Garbage Collections
* ref-mgc-gch::                         Interaction of Garbage Collection and Heap Expansion
* ref-mgc-gcd::                         Invoking the Garbage Collector Directly
* ref-mgc-ago::                         Atom Garbage Collection
* ref-mgc-sum::                         Summary of Predicates


File: sicstus.info,  Node: ref-mgc-ove,  Next: ref-mgc-gcp,  Up: ref-mgc

4.10.1 Overview
---------------

* Menu:

* ref-mgc-ove-rsp::                     Reclaiming Space
* ref-mgc-ove-sta::                     Displaying Statistics

   SICStus Prolog uses five data areas: program space, global stack,
local stack, choice stack, and trail stack.  Each of these areas is
automatically expanded if it overflows.

   The local stack contains all the control information and variable
bindings needed in a Prolog execution.  Space on the local stack is
reclaimed on determinate success of predicates and by tail recursion
optimization, as well as on backtracking.

   The choice stack contains data representing outstanding choices for
some goals or disjunctions.  Space on the choice stack is reclaimed on
backtracking.

   The global stack contains all the data structures constructed in an
execution of the program.  This area grows with forward execution and
shrinks on backtracking.

   The trail stack contains references to all the variables that need
to be reset when backtracking occurs.  This area grows with forward
execution and shrinks on backtracking.

   The program space contains compiled and interpreted code, recorded
terms, and atoms.  The space occupied by compiled code, interpreted
code, and recorded terms is recovered when it is no longer needed; the
space occupied by atoms that are no longer in use can be recovered by
atom garbage collection described in *note ref-mgc-ago::.

   These fluctuations in memory usage of the above areas can be
monitored by `statistics/[0,2]'.

   SICStus Prolog uses the global stack to construct compound terms,
including lists.  Global Stack space is used as Prolog execution moves
forward.  When Prolog backtracks, it automatically reclaims space on
the global stack.  However, if a program uses a large amount of space
before failure and backtracking occur, this type of reclamation may be
inadequate.

   Without garbage collection, the Prolog system must attempt to expand
the global stack whenever a global stack overflow occurs.  To do this,
it first requests additional space from the operating system.  If no
more space is available, the Prolog system attempts to allocate unused
space from the other Prolog data areas.  If additional space cannot be
found, a resource error is raised.

   Global stack expansion and abnormal termination of execution due to
lack of stack space can occur even if there are structures on the
global stack that are no longer accessible to the computation (these
structures are what is meant by "garbage").  The proportion of garbage
to non-garbage terms varies during execution and with the Prolog code
being executed.  The global stack may contain no garbage at all, or may
be nearly all garbage.

   The  garbage collector periodically reclaims inaccessible global
stack space, reducing the need for global stack expansion and lessening
the likelihood of running out of global stack.  When the garbage
collector is enabled (as it is by default), the system makes fewer
requests to the operating system for additional space.  The fact that
less space is required from the operating system can produce a
substantial savings in the time taken to run a program, because paging
overhead can be much less.

   For example, without garbage collection, compiling a file containing
the sequence
     p(_) :- p([a]).
     :- p(_).

causes the global stack to expand until the Prolog process eventually
runs out of space.  With garbage collection enabled, the above sequence
continues indefinitely.  The list built on the global stack by each
recursive call is inaccessible to future calls (since `p/1' ignores its
argument) and can be reclaimed by the garbage collector.

   Garbage collection does not guarantee freedom from out-of-space
errors, however.  Compiling a file containing the sequence
     p(X) :- p([X]).
     :- p(a).

expands the global stack until the Prolog process eventually runs out of
space.  This happens in spite of the garbage collector, because all the
terms built on the global stack are accessible to future computation
and cannot be reclaimed.


File: sicstus.info,  Node: ref-mgc-ove-rsp,  Next: ref-mgc-ove-sta,  Up: ref-mgc-ove

4.10.1.1 Reclaiming Space
.........................

`trimcore/0' reclaims space in all of Prolog's data areas.  At any
given time, each data area contains some free space.  For example, the
local stack space contains the local stack and some free space for that
stack to grow into.  The data area is automatically expanded when it
runs out of free space, and it remains expanded until `trimcore/0' is
called, even though the stack may have shrunk considerably in the
meantime.  The effect of `trimcore/0' is to reduce the free space in
all the data areas as much as possible, and to endeavor to give the
space no longer needed back to the operating system.

   The system property `PROLOGKEEPSIZE' can be used to define a lower
bound on the amount of memory to be retained.  Also, the system property
`PROLOGINITSIZE' can be used to request that an initial amount of
memory be allocated.  This initially allocated memory will not be
touched by `trimcore/0'.

   When trimming a given stacks, `trimcore/0' will retain at least the
amount of space initially allocated for that stack.

   `trimcore/0' is called each time Prolog returns to the top-level or
the top of a break level, except it does not trim the stacks then.
*Note mpg-ref-trimcore::.


File: sicstus.info,  Node: ref-mgc-ove-sta,  Prev: ref-mgc-ove-rsp,  Up: ref-mgc-ove

4.10.1.2 Displaying Statistics
..............................

Statistics relating to memory usage, run time, and garbage collection,
including information about which areas of memory have overflowed and
how much time has been spent expanding them, can be displayed by
calling `statistics/0'.

   The output from `statistics/0' looks like this:

     memory (total)       3334072 bytes
        global stack      1507184 bytes:       2516 in use,   1504668 free
        local stack         49296 bytes:        276 in use,     49020 free
        trail stack         34758 bytes:        248 in use,     34510 free
        control stack       34874 bytes:        364 in use,     34510 free
        program space     1707960 bytes:    1263872 in use,    444088 free
        program space breakdown:
                 compiled code               575096 bytes
                 atom                        166528 bytes
                 predicate                   157248 bytes
                 try_node                    144288 bytes
                 sw_on_key                   105216 bytes
                 incore_info                  51096 bytes
                 atom table                   36864 bytes
                 interpreted code             13336 bytes
                 atom buffer                   2560 bytes
                 SP_malloc                     2288 bytes
                 FLI stack                     2048 bytes
                 miscellaneous                 1640 bytes
                 BDD hash table                1560 bytes
                 source info (B-tree)          1024 bytes
                 numstack                      1024 bytes
                 int_info                       880 bytes
                 file table                     400 bytes
                 source info (itable)           328 bytes
                 module                         320 bytes
                 source info (lheap)             80 bytes
                 foreign resource                32 bytes
                 all solutions                   16 bytes
         4323 atoms (151927 bytes) in use, 1044252 free
         No memory resource errors

            0.020 sec. for 7 global, 20 local, and 0 choice stack overflows
            0.060 sec. for 15 garbage collections which collected 5461007 bytes
            0.000 sec. for 0 atom garbage collections which collected 0 atoms (0 bytes)
            0.000 sec. for 4 defragmentations
            0.000 sec. for 7 dead clause reclamations
            0.000 sec. for 0 dead predicate reclamations
           39.410 sec. runtime
         ========
           39.490 sec. total runtime
          109.200 sec. elapsed time

   Note the use of indentation to indicate sub-areas.  That is, memory
contains the program space and the four stacks: global, local, choice,
and trail.

   The memory (total) figure shown as "in use" is the sum of the spaces
for the program space and stacks. The "free" figures for the stacks are
for free space within those areas.  However, this free space is
considered used as far as the memory (total) area is concerned, because
it has been allocated to the stacks. The program space is not
considered to have its own free space.  It always allocates new space
from the general memory (total) free area.

   If a memory resource error has occurred previously in the execution,
the memory area for which memory could not be allocated is displayed.

   Individual statistics can be obtained by `statistics/2', which
accepts a keyword and returns a list of statistics related to that
keyword.

   The keys and values for `statistics(KEYWORD, VALUE)' are summarized
below.  The keywords `core' and `heap' are included to retain
compatibility with other Prologs.  Times are given in milliseconds and
sizes are given in bytes.

`KEYWORD'
     VALUE

`runtime'
     `[SINCE START OF PROLOG,SINCE PREVIOUS STATISTICS]'
     These refer to CPU time used while executing, excluding time spent
     in memory management tasks or or in system calls.  The second
     element is the time since the latest call to `statistics/2' with
     this key or to `statistics/0'.

`total_runtime'
     `[SINCE START OF PROLOG,SINCE PREVIOUS STATISTICS]'
     These refer to total CPU time used while executing, including
     memory management tasks such as garbage collection but excluding
     system calls.  The second element is the time since the latest
     call to `statistics/2' with this key or to `statistics/0'.

`walltime'
     `[SINCE START OF PROLOG,SINCE PREVIOUS STATISTICS]'
     These refer to absolute time elapsed.  The second element is the
     time since the latest call to `statistics/2' with this key or to
     `statistics/0'.

`global_stack'
     `[SIZE USED,FREE]'
     This refers to the global stack, where compound terms are stored.
     The values are gathered before the list holding the answers is
     allocated.  Formed from basic values below.

`local_stack'
     `[SIZE USED,FREE]'
     This refers to the local stack, where recursive predicate
     environments are stored.  Formed from basic values below.

`trail'
     `[SIZE USED,FREE]'
     This refers to the trail stack, where conditional variable
     bindings are recorded.  Formed from basic values below.

`choice'
     `[SIZE USED,FREE]'
     This refers to the choice stack, where partial states are stored
     for backtracking purposes.  Formed from basic values below.

`memory'

`core'
     `[SIZE USED,0]'
     These refer to the amount of memory actually allocated by the
     Prolog engine.  The zero is there for compatibility with other
     Prolog implementations.  Formed from basic values below.

`program'
`heap'
     `[SIZE USED,SIZE FREE]'
     These refer to the amount of memory allocated for the database,
     symbol tables, and the like.  Formed from basic values below.

`garbage_collection'
     `[NO. OF GCS,BYTES FREED,TIME SPENT]'
     Formed from basic values below.

`stack_shifts'
     `[NO. OF GLOBAL SHIFTS,NO. OF LOCAL/CHOICE SHIFTS,TIME SPENT]'
     Formed from basic values below.

`atoms'
     `[NO. OF ATOMS,BYTES USED,ATOMS FREE]'
     The number of atoms free is the number of atoms allocated (the
     first element in the list) subtracted from the maximum number of
     atoms, i.e. 262143 (33554431) on 32-bit (64-bit) architectures.
     Note that atom garbage collection may be able to reclaim some of
     the allocated atoms.  Formed from basic values below.

`atom_garbage_collection'
     `[NO. OF AGCS,BYTES FREED,TIME SPENT]'
     Formed from basic values below.

`defragmentation'
     `[NO. OF DEFRAGMENTATIONS,TIME SPENT]'
     Formed from basic values below.

`memory_used   *since release 4.1*'
     BYTES USED
`memory_free   *since release 4.1*'
     BYTES FREE
`global_stack_used   *since release 4.1*'
     BYTES USED
`global_stack_free   *since release 4.1*'
     BYTES FREE
`local_stack_used   *since release 4.1*'
     BYTES USED
`local_stack_free   *since release 4.1*'
     BYTES FREE
`trail_used   *since release 4.1*'
     BYTES USED
`trail_free   *since release 4.1*'
     BYTES FREE
`choice_used   *since release 4.1*'
     BYTES USED
`choice_free   *since release 4.1*'
     BYTES FREE
`atoms_used   *since release 4.1*'
     BYTES USED
`atoms_nbused   *since release 4.1*'
     ATOMS USED
`atoms_nbfree   *since release 4.1*'
     ATOMS FREE
`ss_global   *since release 4.1*'
     NUMBER OF GLOBAL STACK SHIFTS
`ss_local   *since release 4.1*'
     NUMBER OF LOCAL STACK SHIFTS
`ss_choice   *since release 4.1*'
     NUMBER OF CHOICE STACK SHIFTS
`ss_time   *since release 4.1*'
     TIME SPENT STACK SHIFTING
`gc_count   *since release 4.1*'
     NUMBER OF GARBAGE COLLECTIONS
`gc_freed   *since release 4.1*'
     NUMBER OF BYTES FREED
`gc_time   *since release 4.1*'
     TIME SPENT COLLECTING GARBAGE
`agc_count   *since release 4.1*'
     NUMBER OF ATOM GARBAGE COLLECTIONS
`agc_nbfreed   *since release 4.1*'
     NUMBER OF GARBAGE COLLECTED ATOMS
`agc_freed   *since release 4.1*'
     NUMBER OF BYTES FREED BY ATOM GARBAGE COLLECTED
`agc_time   *since release 4.1*'
     TIME SPENT GARBAGE COLLECTED ATOMS
`defrag_count   *since release 4.1*'
     NUMBER OF MEMORY DEFRAGMENTATIONS
`defrag_time   *since release 4.1*'
     TIME SPENT DEFRAGMENTING MEMORY
`dpgc_count   *since release 4.1*'
     NUMBER OF DEAD PREDICATE RECLAMATIONS
`dpgc_time   *since release 4.1*'
     TIME SPENT RECLAIMING DEAD PREDICATES
`dcgc_count   *since release 4.1*'
     NUMBER OF DEAD CLAUSE RECLAMATIONS
`dcgc_time   *since release 4.1*'
     TIME SPENT RECLAIMING DEAD CLAUSES
`memory_culprit   *since release 4.1*'
     MEMORY BUCKET IN WHICH LATEST MEMORY RESOURCE ERROR OCCURRED
`memory_buckets   *since release 4.1*'
     LIST OF BUCKET-SIZE PAIR
     where SIZE is the amount of memory in use for memory bucket BUCKET.

`jit_count   *since release 4.3*'
     NUMBER OF JIT-COMPILED PREDICATES
     This is zero when JIT compilation is not available.

`jit_time   *since release 4.3*'
     TIME SPENT JIT-COMPILING PREDICATES
     This is zero when JIT compilation is not available.


   To see an example of the use of each of these keywords, type
     | ?- statistics(K, L).

and then repeatedly type `;' to backtrack through all the possible
keywords.  As an additional example, to report information on the
runtime of a predicate `p/0', add the following to your program:

     :- statistics(runtime, [T0| _]),
        p,
        statistics(runtime, [T1|_]),
        T is T1 - T0,
        format('p/0 took ~3d sec.~n', [T]).
*Note mpg-ref-statistics::.


File: sicstus.info,  Node: ref-mgc-gcp,  Next: ref-mgc-egc,  Prev: ref-mgc-ove,  Up: ref-mgc

4.10.2 Garbage Collection and Programming Style
-----------------------------------------------

The availability of garbage collection can lead to a more natural
programming style.  Without garbage collection, a procedure that
generates heap garbage may have to be executed in a failure-driven loop.
Failure-driven loops minimize heap usage from iteration to iteration of
a loop via SICStus Prolog's automatic recovery of heap space on failure.
For instance, in the following procedure `echo/0' echoes Prolog terms
until it reads an end-of-file character.  It uses a failure-driven loop
to recover inaccessible heap space.
     echo :- repeat,
             read(Term),
             echo_term(Term),
             !.

     echo_term(Term) :-
             Term == end_of_file.
     echo_term(Term) :-
             write(Term), nl,
             fail.

   Any heap garbage generated by `read/1' or `write/1' is automatically
reclaimed by the failure of each iteration.

   Although failure-driven loops are an accepted Prolog idiom, they are
not particularly easy to read or understand.  So we might choose to
write a clearer version of `echo/0' using recursion instead, as in
     echo :- read(Term),
             echo_term(Term).

     echo_term(Term) :-
             Term == end_of_file,
             !.
     echo_term(Term) :-
             write(Term), nl,
             echo.

   Without garbage collection the more natural recursive loop
accumulates heap garbage that cannot be reclaimed automatically.  While
it is unlikely that this trivial example will run out of heap space,
larger and more practical applications may be unable to use the clearer
recursive style without garbage collection.  With garbage collection,
all inaccessible heap space will be reclaimed by the garbage collector.

   Using recursion rather than failure-driven loops can improve
programming style further.  We might want to write a predicate that
reads terms and collects them in a list.  This is naturally done in a
recursive loop by accumulating results in a list that is passed from
iteration to iteration.  For instance,
     collect(List) :-
             read(Term),
             collect_term(Term, List).

     collect_term(Term, []) :-
             Term == end_of_file,
             !.
     collect_term(Term, [Term|List0]) :-
             collect(List0).

   For more complex applications this sort of construction might prove
unusable without garbage collection.  Instead, we may be forced to use a
failure-driven loop with side-effects to store partial results, as in
the following much less readable version of `collect/1':
     collect(List) :-
             repeat,
             read(Term),
             store_term(Term),
             !,
             collect_terms(List).

     store_term(Term) :-
             Term == end_of_file.

     store_term(Term) :-
             assertz(term(Term)),
             fail.

     collect_terms([M|List]) :-
             retract(term(M)),
             !,
             collect_terms(List).
     collect_terms([]).

   The variable bindings made in one iteration of a failure-driven loop
are unbound on failure of the iteration.  Thus partial results cannot
simply be stored in a data structure that is passed along to the next
iteration.  We must instead resort to storing partial results via
side-effects (here, `assertz/1') and collect (and clean up) partial
results in a separate pass.  The second example is much less clear to
most people than the first.  It is also much less efficient than the
first.  However,  if there were no garbage collector, larger examples
of the second type might be able to run where those of the first type
would run out of memory.


File: sicstus.info,  Node: ref-mgc-egc,  Next: ref-mgc-mgc,  Prev: ref-mgc-gcp,  Up: ref-mgc

4.10.3 Enabling and Disabling the Garbage Collector
---------------------------------------------------

The user has the option of executing programs with or without garbage
collection.  Procedures that don't use a large amount of heap space
before backtracking may not be affected when garbage collection is
enabled.  Procedures that do use a large amount of heap space may
execute more slowly due to the time spent garbage collecting, but will
be more likely to run to completion.  On the other hand, such programs
may run faster when the garbage collector is enabled because the
virtual memory is not expanded to the extent that "thrashing" occurs.
The `gc' Prolog flag can be set to `on' or `off'.  To monitor garbage
collections in verbose mode, set the `gc_trace' flag to `verbose'.  By
default, garbage collection is enabled.  


File: sicstus.info,  Node: ref-mgc-mgc,  Next: ref-mgc-gch,  Prev: ref-mgc-egc,  Up: ref-mgc

4.10.4 Monitoring Garbage Collections
-------------------------------------

By default, the user is given no indication that the garbage collector
is operating.  If no program ever runs out of space and no program
using a lot of heap space requires an inordinate amount of processing
time, such information is unlikely to be needed.

   However, if a program thought to be using much heap space runs out of
space or runs inordinately slowly, the user may want to determine
whether more or less frequent garbage collections are necessary.
Information obtained from the garbage collector by turning on the
`gc_trace' Prolog flag can be helpful in this determination.  


File: sicstus.info,  Node: ref-mgc-gch,  Next: ref-mgc-gcd,  Prev: ref-mgc-mgc,  Up: ref-mgc

4.10.5 Interaction of Garbage Collection and Heap Expansion
-----------------------------------------------------------

For most programs, the default settings for the garbage collection
parameters should suffice.  For programs that have high heap
requirements, the default parameters may result in a higher ratio of
garbage collection time to run time.  These programs should be given
more space in which to run.

   The `gc_margin' is a non-negative integer specifying the desired
margin in kilobytes.  For example, the default representation of 1000 means that
the heap will not be expanded if garbage collection can reclaim at least
one megabyte.  The advantage of this criterion is that it takes into
account both the user's estimate of the heap usage and the
effectiveness of garbage collecting.

  1.  Setting the `gc_margin' higher than the default will cause fewer
     heap expansions and garbage collections.  However, it will use
     more space, and garbage collections will be more time-consuming
     when they do occur.

     Setting the margin too large will cause the heap to expand so that
     if it does overflow, the resulting garbage collection will
     significantly disrupt normal processing.  This will be especially
     so if much of the heap is accessible to future computation.

  2.  Setting the `gc_margin' lower than the default will use less
     space, and garbage collections will be less time-consuming.
     However, it will cause more heap expansions and garbage
     collections.

     Setting the margin too small will cause many garbage collections
     in a small amount of time, so that the ratio of garbage-collecting
     time to computation time will be abnormally high.

  3. Setting the margin correctly will cause the heap to expand to a
     size where expansions and garbage collections are infrequent and
     garbage collections are not too time-consuming, if they occur at
     all.

   The correct representation for the `gc_margin' is dependent upon many factors.
Here is a non-prioritized list of some of them:
   * The amount of memory available to the Prolog process

   * The maximum memory limit imposed on the Prolog process

   * The program's rate of heap garbage generation

   * The program's rate of heap non-garbage generation

   * The program's backtracking behavior

   * The amount of time needed to collect the generated garbage

   * The growth rate of the other Prolog stacks

   The algorithm used when the heap overflows is as follows:


     if `gc' is on
     and the heap is larger than `gc_margin' kilobytes then
        garbage collect the heap
        if less than `gc_margin' kilobytes are reclaimed then
           try to expand the heap
        endif
     else
        try to expand the heap
     endif

   The user can use the `gc_margin' option of `prolog_flag/3' to reset
the `gc_margin' (see *note ref-lps-ove::).  If a garbage collection
reclaims at least the `gc_margin' kilobytes of heap space the heap is
not expanded after garbage collection completes.  Otherwise, the heap
is expanded after garbage collection.  This expansion provides space
for the future heap usage that will presumably occur.  In addition, no
garbage collection occurs if the heap is smaller than `gc_margin'
kilobytes.


File: sicstus.info,  Node: ref-mgc-gcd,  Next: ref-mgc-ago,  Prev: ref-mgc-gch,  Up: ref-mgc

4.10.6 Invoking the Garbage Collector Directly
----------------------------------------------

Normally, the garbage collector is invoked only when some Prolog data
area overflows, so the time of its invocation is not predictable.  In
some applications it may be desirable to invoke the garbage collector
at regular intervals (when there is known to be a significant amount of
garbage on the heap) so that the time spent garbage collecting is more
evenly distributed in the processing time.  For instance, it may prove
desirable to invoke the garbage collector after each iteration of a
question-and-answer loop that is not failure-driven.

   In rare cases the default garbage collection parameters result in
excessive garbage collecting costs or heap expansion, and the user
cannot tune the `gc_margin' parameter adequately.  Explicitly invoking
the garbage collector using the built-in predicate `garbage_collect/0'
can be useful in these circumstances.  

   *Note mpg-ref-garbage_collect::.


File: sicstus.info,  Node: ref-mgc-ago,  Next: ref-mgc-sum,  Prev: ref-mgc-gcd,  Up: ref-mgc

4.10.7 Atom Garbage Collection
------------------------------

* Menu:

* ref-mgc-ago-agc::                     The Atom Garbage Collector User Interface
* ref-mgc-ago-pat::                     Protecting Atoms in Foreign Memory
* ref-mgc-ago-prm::                     Permanent Atoms
* ref-mgc-ago-are::                     Details of Atom Registration

   By default, atoms created during the execution of a program remain
permanently in the system until Prolog exits. For the majority of
applications this behavior is not a problem and can be ignored.
However, for two classes of application this can present problems.
Firstly the internal architecture of SICStus Prolog limits the number
of atoms that be can created to 1,048,575 on 32-bit machines, and this
can be a problem for database applications that read large numbers of
atoms from a database. Secondly, the space occupied by atoms can become
significant and dominate memory usage, which can be a problem for
processes designed to run perpetually.

   These problems can be overcome by using atom garbage collection to
reclaim atoms that are no longer accessible to the executing program.

   Atoms can be created in many ways: when an appropriate token is read
with `read_term/3', when source or PO files are loaded, when
`atom_codes/2' is called with a character list, or when
`SP_atom_from_string()' is called in C code.  In any of these contexts
an atom is only created if it does not already exist; all atoms for a
given string are given the same identification number, which is
different from the atom of any other string.  Thus, atom recognition
and comparison can be done quickly, without having to look at strings.
An occurrence of an atom is always of a fixed, small size, so where a
given atom is likely to be used in several places simultaneously the
use of atoms can also be more compact than the use of strings.

   A Prolog functor is implemented like an atom, but also has an
associated arity.  For the purposes of atom garbage collection, a
functor is considered to be an occurrence of the atom of that same name.

   Atom garbage collection is similar to heap garbage collection,
invoked automatically as well as through a call to the built-in
predicate `garbage_collect_atoms/0'.  The atom garbage collector scans
Prolog's data areas looking for atoms that are currently in use and
then throws away all unused atoms, reclaiming their space.

   Atom garbage collection can turn an application that continually
grows and eventually either runs into the atom number limit or runs out
of space into one that can run perpetually.  It can also make feasible
applications that load and manipulate huge quantities of atom-rich data
that would otherwise become full of useless atoms.


File: sicstus.info,  Node: ref-mgc-ago-agc,  Next: ref-mgc-ago-pat,  Up: ref-mgc-ago

4.10.7.1 The Atom Garbage Collector User Interface
..................................................

Because the creation of atoms does not follow any other system behaviors
like memory growth or heap garbage collection, SICStus has chosen to
keep the invocation of atom garbage collection independent of any other
operation and to keep the invocation of atom garbage collection explicit
rather than making it automatic.  It is often preferable for the
programmer to control when it will occur in case preparations need to
be made for it.

   Atom garbage collection is invoked automatically when the number of
new atoms created since the last atom garbage collection reaches the
representation of the `agc_margin' flag.

   Atom garbage collection can be invoked explicitly by calling
`garbage_collect_atoms/0'.  The predicate normally succeeds silently.
The user may determine whether to invoke atom garbage collection at a
given point based on information returned from a call to `statistics/2'
with the keyword `atoms'.  That call returns a list of the form

     [NUMBER OF ATOMS, ATOM SPACE IN USE, ATOM SPACE FREE]

   For example,

     | ?- statistics(atoms, Stats).

     Stats = [4313,121062,31032]

   One would typically choose to call `garbage_collect_atoms/0' prior
to each iteration of an iterative application, when either the number
of atoms or the atom space in use passes some threshold, e.g.

     <driver loop> :-
             ...
             repeat,
                maybe_atom_gc,
                <do next iteration>
                ...
             fail.
     <driver loop>.

where

     maybe_atom_gc :-
             statistics(atoms, [_,Inuse,_]),
             atom_gc_space_threshold(Space),
             ( Inuse > Space -> garbage_collect_atoms ; true ).

     % Atom GC if there are more than 100000 bytes of atoms:
     atom_gc_space_threshold(100000).

   More sophisticated approaches might use both atom number, atom space
and `agc_margin' thresholds, or could adjust a threshold if atom
garbage collection didn't free an adequate number of atoms.

   To be most effective, atom garbage collection should be called when
as few as possible atoms are actually in use.  In the above example,
for instance, it makes the most sense to do atom garbage collection at
the beginning of each iteration rather than at the end, as at the
beginning of the iteration the previous failure may just have freed
large amounts of atom-rich global and local stack.  Similarly, it's
better to invoke atom garbage collection after abolishing or retracting
a large database than to do so before.  *Note
mpg-ref-garbage_collect_atoms::.


File: sicstus.info,  Node: ref-mgc-ago-pat,  Next: ref-mgc-ago-prm,  Prev: ref-mgc-ago-agc,  Up: ref-mgc-ago

4.10.7.2 Protecting Atoms in Foreign Memory
...........................................

SICStus Prolog's foreign language interface allows atoms to be passed
to foreign functions.  When calling foreign functions from Prolog,
atoms are passed via the `+atom' argument type in the predicate
specifications of `foreign/[2,3]' facts.  The strings of atoms can be
passed to foreign functions via the `+string' argument type.  In the
latter case a pointer to the Prolog symbol table's copy of the string
for an atom is what is passed.  When calling Prolog from C, atoms are
passed back from C to Prolog using the `-atom' and `-string' argument
types in `extern/1' declarations.  Atoms can also be created in foreign
code via functions like `SP_atom_from_string()'.

   Prolog does not keep track of atoms (or strings of atoms) stored in
foreign memory.  As such, it cannot guarantee that those atoms will be
retained by atom garbage collection.  Therefore SICStus Prolog provides
functions to "register" atoms (or their strings) with the atom garbage
collector.  Registered atoms will not be reclaimed by the atom garbage
collector.  Atoms can be registered while it is undesirable for them to
be reclaimed, and then unregistered when they are no longer needed.

   Of course, the majority of atoms passed as atoms or strings to
foreign functions don't need to be registered.  Only those that will be
stored across foreign function calls (in global variables) or across
nested calls to Prolog are at risk.  An extra margin of control is
given by the fact the programmer always invokes atom garbage collection
explicitly, and can ensure that this is only done in contexts that are
"safe" for the individual application.

   To register or unregister an atom, one of the following functions is
used:

     int SP_register_atom(atom)
     SP_atom atom;

     int SP_unregister_atom(atom)
     SP_atom atom;

   These functions return either `SP_ERROR' or a non-negative integer.
The return values are discussed further in *note ref-mgc-ago-are::.

   As noted above, when an atom is passed as a string (`+string') to a
foreign function, the string the foreign function receives is the one
in Prolog's symbol table.  When atom garbage collection reclaims the
atom for that string, the space for the string will also be reclaimed.

   Thus, if the string is to be stored across foreign calls, either a
copy of the string or else the atom (`+atom') should be passed into the
foreign function so that it can be registered and
`SP_string_from_atom()' can be used to access the string from the atom.

   Keep in mind that the registration of atoms only pertains to those
passed to foreign functions or created in foreign code.  Atoms in
Prolog's data areas are maintained automatically.  Note also that even
though an atom may be unregistered in foreign code, atom garbage
collection still may not reclaim it as it may be referenced from
Prolog's data areas.  But if an atom is registered in foreign code, it
will be preserved regardless of its presence in Prolog's data areas.

   The following example illustrates the use of these functions. In this
example the current representation of an object (which is an atom) is being
stored in a C global variable. There are two C functions that can be
called from Prolog, one to update the current representation and one to access
the representation.

     #include <sicstus/sicstus.h>

     SP_atom current_object = NULL;

     update_object(newvalue)
     SP_atom newvalue;
     {
             /* if current_object contains an atom, unregister it */
             if (current_object)
                     (void) SP_unregister_atom(current_object);

             /* register new representation */
             (void) SP_register_atom(newvalue);
             current_object = newvalue;
     }

     SP_atom get_object()
     {
             return current_object;
     }


File: sicstus.info,  Node: ref-mgc-ago-prm,  Next: ref-mgc-ago-are,  Prev: ref-mgc-ago-pat,  Up: ref-mgc-ago

4.10.7.3 Permanent Atoms
........................

Atom garbage collection scans all Prolog's dynamic data areas when
looking for atoms that are in use.  Scanning finds atoms in the Prolog
stacks and in all compiled and interpreted code that has been
dynamically loaded into Prolog via `consult/1', `use_module/1',
`assert/2', etc.  However, there are certain potential sources of atoms
in the Prolog image from which atoms cannot be reclaimed.  Atoms for
Prolog code that has been statically linked with either the Prolog
Development Environment or the Runtime Environment have been placed in
the text space, making them (and the code that contains them)
effectively permanent.  Although such code can be abolished, its space
can never be reclaimed.

   These atoms are internally flagged as permanent by the system and are
always retained by atom garbage collection.  An atom that has become
permanent cannot be made non-permanent, so can never be reclaimed.


File: sicstus.info,  Node: ref-mgc-ago-are,  Prev: ref-mgc-ago-prm,  Up: ref-mgc-ago

4.10.7.4 Details of Atom Registration
.....................................

The functions that register and unregister atoms are in fact using
reference counting to keep track of atoms that have been registered.
As a result, it is safe to combine your code with libraries and code
others have written.  If the other code has been careful to register
and unregister its atoms as appropriate, atoms will not be reclaimed
until everyone has unregistered them.

   Of course, it is possible when writing code that needs to register
atoms that errors could occur.  Atoms that are registered too many
times simply will not be garbage collected until they are fully
unregistered.  However, atoms that aren't registered when they should
be may be reclaimed on atom garbage collection.  One normally doesn't
need to think about the reference counting going on in
`SP_register_atom()' and `SP_unregister_atom()', but some understanding
of its details could prove helpful when debugging.

   To help you diagnose problems with registering and unregistering
atoms, `SP_register_atom()' and `SP_unregister_atom()' both normally
return the current reference count for the atom.  If an error occurs,
e.g. a nonexistent atom is registered or unregistered, `SP_ERROR' is
returned.

   An unregistered atom has a reference count of 0.  Unregistering an
atom that is unregistered is a no-op; in this case,
`SP_unregister_atom()' returns 0.  A permanent atom has a reference
count of 256.  In addition, if an atom is simultaneously registered 256
times, it becomes permanent.  (An atom with 256 distinct references is
an unlikely candidate for reclamation!)  Registering or unregistering
an atom that is permanent is also a no-op;  `SP_register_atom()' and
`SP_unregister_atom()' return 256.


File: sicstus.info,  Node: ref-mgc-sum,  Prev: ref-mgc-ago,  Up: ref-mgc

4.10.8 Summary of Predicates
----------------------------

`garbage_collect'
     force an immediate garbage collection

`garbage_collect_atoms'
     garbage collect atom space

`statistics'
     display various execution statistics

`statistics(?K,?V)'
     the execution statistic with key K has representation V

`trimcore'
     reduce free stack space to a minimum



File: sicstus.info,  Node: ref-mod,  Next: ref-mdb,  Prev: ref-mgc,  Up: Prolog Intro

4.11 Modules
============

* Menu:

* ref-mod-ove::                         Overview
* ref-mod-bas::                         Basic Concepts
* ref-mod-def::                         Defining a Module
* ref-mod-n2m::                         Converting Non-module-files into Module-files
* ref-mod-lod::                         Loading a Module
* ref-mod-vis::                         Visibility Rules
* ref-mod-som::                         The Source Module
* ref-mod-tyi::                         The Type-in Module
* ref-mod-dmo::                         Creating a Module Dynamically
* ref-mod-mpc::                         Module Prefixes on Clauses
* ref-mod-cim::                         Debugging Code in a Module
* ref-mod-ncl::                         Name Clashes
* ref-mod-ilm::                         Obtaining Information about Loaded Modules
* ref-mod-idp::                         Importing Dynamic Predicates
* ref-mod-mne::                         Module Name Expansion
* ref-mod-met::                         The meta_predicate Declaration
* ref-mod-sem::                         Semantics of Module Name Expansion
* ref-mod-sum::                         Predicate Summary


File: sicstus.info,  Node: ref-mod-ove,  Next: ref-mod-bas,  Up: ref-mod

4.11.1 Overview
---------------

The module system lets the user divide large Prolog programs into
"modules", or rather smaller sub-programs, and define the interfaces
between those modules.  Each module has its own name space; that is, a
predicate defined in one module is distinct from any predicates with
the same name and arity that may be defined in other modules.  The
module system encourages a group of programmers to define the
dependence each has on others' work before any code is written, and
subsequently allows all to work on their own parts independently.  It
also helps to make library predicates behave as extensions of the
existing set of built-in predicates.

   The SICStus Prolog library uses the module system and can therefore
serve as an extended example of the concepts presented in the following
text.  The design of the module system is such that loading library
files and calling library predicates can be performed without knowledge
of the module system.

   Some points to note about the module system are that:
   * It is based on predicate modularity rather than on data
     modularity; that is, atoms and functors are global.  

   * It is flat rather than hierarchical; any module may refer to any
     other module by its name--there is no need to specify a path of
     modules.

   * It is not strict; modularity rules can be explicitly overridden.
     This is primarily for flexibility during debugging.

   * It is efficient; calls to predicates across module boundaries incur
     little or no overhead.


File: sicstus.info,  Node: ref-mod-bas,  Next: ref-mod-def,  Prev: ref-mod-ove,  Up: ref-mod

4.11.2 Basic Concepts
---------------------

Each predicate in a program is identified by its "module", as well as by
its name and arity.

   A module defines a set of predicates, among which some have the
property of being "public".  Public predicates are predicates that can
be "imported" by other modules, which means that they can then be
called from within those modules.  Predicates that are not public are
"private" to the module in which they are defined; that is, they cannot
be called from outside that module (except by explicitly overriding the
modularity rules as described in *note ref-mod-vis::).

   There are two kinds of importation:

  1. A module M1 may import a specified set of predicates from another
     module M2.  All the specified predicates should be public in M2.

  2. A module M1 may import all the public predicates of another module
     M2.

   Built-in predicates don't need to be imported; they are automatically
available from within any module.

   There is a special module called `user', which is used by default
when predicates are being defined and no other module has been
specified.

   The other predefined module is the `prolog' module where all the
built-in predicates reside.  The exported built-in predicates are
automatically imported into each new module as it is created.

   If you are using a program written by someone else, you need not be
concerned as to whether or not that program has been made into a module.
The act of loading a module from a file using `compile/1', or
`ensure_loaded/1' (see *note ref-lod::) will automatically import all
the public predicates in that module.  Thus the command
     :- ensure_loaded(library(lists)).

will load the list-processing predicates from the library and make them
available.


File: sicstus.info,  Node: ref-mod-def,  Next: ref-mod-n2m,  Prev: ref-mod-bas,  Up: ref-mod

4.11.3 Defining a Module
------------------------

The normal way to define a module is by creating a "module-file" for it
and loading it into the Prolog system.  A module-file is a Prolog file
that begins with a "module declaration".

   A module declaration has one of the forms:
     :- module(+MODULENAME, +PUBLICPREDLIST).

     :- module(+MODULENAME, +PUBLICPREDLIST, +OPTIONS).

   Such a declaration must appear as the first term in a file, and
declares that file to be a module-file.  The predicates in the file
will become part of the module MODULENAME, and the predicates specified
in PUBLICPREDLIST are those that can be imported by other modules; that
is, the public predicates of this module.

   OPTIONS is an optional argument, and should be a list.  The only
available option is `hidden(BOOLEAN)', where BOOLEAN is `false' (the
default) or `true'.  In the latter case, tracing of the predicates of
the module is disabled (although spypoints can be set), and no source
information is generated at compile time.

   Instead of creating and loading a module-file, it is also possible
to define a module dynamically by, for example, asserting clauses into
a specified module.  A module created in this way has no public
predicates; all its predicates are private.  This means that they
cannot be called from outside that module except by explicitly
overriding the modularity rules as described in *note ref-mod-vis::.
Dynamic creation of modules is described in more detail in *note
ref-mod-dmo::.


File: sicstus.info,  Node: ref-mod-n2m,  Next: ref-mod-lod,  Prev: ref-mod-def,  Up: ref-mod

4.11.4 Converting Non-module-files into Module-files
----------------------------------------------------

The Prolog cross-referencer can automatically generate `module/2'
declarations from its cross-reference information.  This is useful if
you want to take a set of files making up a program and make each of
those files into a module-file.  For more information, *note The
Cross-Referencer::

   Alternatively, if you have a complete Prolog program consisting of a
set of source files `{file1, file2, ...}', and you wish to encapsulate
it in a single module MOD, this can be done by creating a "driver" file
of the following form:


     :- module(MOD, [ ... ]).

     :- ensure_loaded(file1).
     :- ensure_loaded(file2).
        .
        .
        .

   When a module is created in this way, none of the files in the
program `{file1, file2, ...}' have to be changed.


File: sicstus.info,  Node: ref-mod-lod,  Next: ref-mod-vis,  Prev: ref-mod-n2m,  Up: ref-mod

4.11.5 Loading a Module
-----------------------

To gain access to the public predicates of a module-file, load it as you
would any other file--using `compile/1', or `ensure_loaded/1' as
appropriate.  For example, if your code contains a directive such as
     :- ensure_loaded(FILE).

this directive will load the appropriate file FILE whether or not FILE
is a module-file.  The only difference is that if FILE is a module-file
any private predicates that it defines will not be visible to your
program.

   The load predicates are adequate for use at Prolog's top-level, or
when the file being loaded is a utility such as a library file.  When
you are writing modules of your own, `use_module/[1,2,3]' is the most
useful.

   The following predicates are used to load modules:

`use_module(F)'
     import the module-file(s) F, loading them if necessary; same as
     `ensure_loaded(F)' if all files in F are module-files

`use_module(:F,+I)'
     import the procedure(s) I from the module-file F, loading
     module-file F if necessary

`use_module(?M,:F,+I)'
     import I from module M, loading module-file F if necessary


   Before a module-file is loaded, the associated module is
"reinitialized": any predicates previously imported into or defined in
that module are forgotten by the module.

   If a module of the same name with a different PUBLICPREDLIST or
different meta-predicate list has previously been loaded from a
different module-file, a warning is printed and you are given the
option of abandoning the load.  Only one of these two modules can exist
in the system at one time.

   Normally, a module-file can be reloaded after editing with no need to
reload any other modules.  However, when a module-file is reloaded after
its PUBLICPREDLIST has been changed, any modules that import predicates
from it may have become inconsistent.  This is because a module is
associated with a predicate at compile time, rather than run time.
Thus, other modules may refer to predicates in a module-file that are
no longer public.  In the case of module-importation (where all, rather
than specific, public predicates of a module are imported), it is
possible that some predicates in the importing module should now refer
to a newly-public predicate but don't.  SICStus Prolog tries to detect
such inconsistencies, and issues a warning when it does detect one.
Similarly, if a meta-predicate declaration of an exported predicate
changes, modules that have already imported that predicate become
inconsistent, because module name expansion requirements have changed.
The current release of SICStus Prolog is unable to detect such
inconsistencies.

   Modules may be saved to a PO file by calling
`save_modules(MODULES,FILE)' (see *note ref-sls::).


File: sicstus.info,  Node: ref-mod-vis,  Next: ref-mod-som,  Prev: ref-mod-lod,  Up: ref-mod

4.11.6 Visibility Rules
-----------------------

By default, predicates defined in one module cannot be called from
another module.  This section enumerates the exceptions to this--the
ways in which a predicate can be "visible" to modules other than the
one in which it is defined.
  1. The built-in predicates can be called from any module.

  2. Any predicate that is named in the PUBLICPREDLIST of a module, and
     that is imported by some other module M, can be called from within
     M.

  3. Module Prefixing: Any predicate, whether public or not, can be
     called from any other module if its module is explicitly given as
     a prefix to the goal, attached with the `:/2' operator.  The
     module prefix overrides the default module.  For example,
          :- mod:foo(X,Y).

     always calls `foo/2' in module MOD.  This is effectively a
     loophole in the module system, which allows you to override the
     normal module visibility rules.  It is intended primarily to
     facilitate program development and debugging, and it should not be
     used extensively since it subverts the original purposes of using
     the module system.

     Note that a predicate called in this way does not necessarily have
     to be defined in the specified module.  It may be imported into
     it.  It can even be a built-in predicate, and this is sometimes
     useful--see *note ref-mod-som:: for an example.


File: sicstus.info,  Node: ref-mod-som,  Next: ref-mod-tyi,  Prev: ref-mod-vis,  Up: ref-mod

4.11.7 The Source Module
------------------------

For any given procedure call, or goal, the "source module" is the module
in which the corresponding predicate must be visible.  That is, unless
the predicate is built-in, it must be defined in, or imported into, the
source module.

   For goals typed at the top-level, the source module is the "type-in
module", which is `user' by default--see *note ref-mod-tyi::.  For
goals appearing in a file, whether in a directive or in the body of a
clause, the source module is the one into which that file has been
loaded.

   There are a number of built-in predicates that take predicate
specifications, clauses, or goals as arguments.  Each of these types of
argument must be understood with reference to some module.  For
example, `assert/1' takes a clause as its argument, and it must decide
into which module that clause should be asserted.  The default
assumption is that it asserts the clause into the source module.
Another example is `call/1'.  The goal (A) calls the predicate `foo/1'
in the source module; this ensures that in the compound goal (B) both
occurrences of `foo/1' refer to the same predicate.

     call(foo(X))  (A)

     call(foo(X)), foo(Y)   (B)

   All predicates that refer to the source module allow you to override
it by explicitly naming some other module to be used instead.  This is
done by prefixing the relevant argument of the predicate with the
module to be used followed by a `:' operator.  For example (C), asserts
`f(x)' in module `m'.

     | ?- assert(m:f(x)).  (C)

   Note that if you call a goal in a specified module, overriding the
normal visibility rules (see *note ref-mod-vis::), the source module
for that goal is the one you specify, not the module in which this call
occurs.  For example (D), has exactly the same effect as (C)--`f(x)' is
asserted in module `m'.  In other words, prefixing a goal with a module
duplicates the effect of calling that goal from that module.
     | ?- m:assert(f(x)).  (D)

   Another built-in predicate that refers to the source module is
`compile/1'.  In this case, the argument is a file, or list of files,
rather than a predicate specification, clause, or goal.  However, in
the case where a file is not a module-file, `compile/1' must decide
into which module to compile its clauses, and it chooses the source
module by default.  This means that you can compile a file FILE into a
specific module M using
     | ?- compile(M:FILE).

   Thus if FILE is a module-file, this command would cause its public
predicates to be imported into module M.  If FILE is a non-module-file,
it is loaded into module M.

   For a list of the built-in predicates that depend on the source
module, see *note ref-mod-mne::.  In some cases, user-defined
predicates may also require the concept of a source module.  This is
discussed in *note ref-mod-met::.


File: sicstus.info,  Node: ref-mod-tyi,  Next: ref-mod-dmo,  Prev: ref-mod-som,  Up: ref-mod

4.11.8 The Type-in Module
-------------------------

The "type-in" module is the module that is taken as the source module
for goals typed in by the user.  The name of the default type-in module
is `user'.  That is, the predicates that are available to be called
directly by the user are those that are visible in the module `user'.

   When debugging, it is often useful to call, directly from the
top-level, predicates that are private to a module, or predicates that
are public but that are not imported into `user'.  This can be done by
prefixing each goal with the module name, as described in *note
ref-mod-vis::; but rather than doing this extensively, it may be more
convenient to make this module the type-in module.

   The type-in module can be changed using the built-in predicate
`set_module/1'; for example,
     | ?- set_module(mod).

   This command will cause subsequent goals typed at the top-level to be
executed with `mod' as their source module.

   The name of the type-in module is always displayed, except when it
is `user'.  If you are running Prolog under the editor interface, the
type-in module is displayed in the status line of the Prolog window.
If you are running Prolog without the editor interface, the type-in
module is displayed before each top-level prompt.

   For example, if you are running Prolog without the editor:
     | ?- set_module(foo).

     yes
     [foo]
     | ?-

   It should be noted that it is unlikely to be useful to change the
type-in module via a directive embedded in a file to be loaded, because
this will have no effect on the load--it will only change the type-in
module for commands subsequently entered by the user.


File: sicstus.info,  Node: ref-mod-dmo,  Next: ref-mod-mpc,  Prev: ref-mod-tyi,  Up: ref-mod

4.11.9 Creating a Module Dynamically
------------------------------------

There are several ways in which you can create a module without loading
a module-file for it.  One way to do this is by asserting clauses into
a specified module.  For example, the command (A) will create the
dynamic predicate `f/1' and the module `m' if they did not previously
exist.

     | ?- assert(m:f(x)).  (A)

   Another way to create a module dynamically is to compile a
non-module-file into a specified module.  For example (B), will compile
the clauses in FILE into the module M.

     | ?- compile(M:FILE).  (B)

   The same effect can be achieved by (temporarily) changing the type-in
module to M (see *note ref-mod-tyi::) and then calling `compile(FILE)',
or executing the command in module M as in (C).

     | ?- M:compile(FILE).  (C)


File: sicstus.info,  Node: ref-mod-mpc,  Next: ref-mod-cim,  Prev: ref-mod-dmo,  Up: ref-mod

4.11.10 Module Prefixes on Clauses
----------------------------------

* Menu:

* ref-mod-mpc-cmo::                     Current Modules

   Every clause in a Prolog file has a source module implicitly
associated with it.  If the file is a module-file, the module named in
the module declaration at the top of the file is the source module for
all the clauses.  If the file is not a module-file, the relevant module
is the source module for the command that caused this file to be loaded.

   The source module of a predicate decides in which module it is
defined (the module of the head), and in which module the goals in the
body are going to be called (the module of the body). It is possible to
override the implicit source module, both for head and body, of clauses
and directives, by using prefixes. For example, consider the
module-file:
     :- module(a, []).

     :- dynamic m:a/1.
     b(1).
     m:c([]).
     m:d([H|T]) :- q(H), r(T).
     m:(e(X) :- s(X), t(X)).
     f(X) :- m:(u(X), v(X)).

   In the previous example, the following modules apply:
  1. `a/1' is declared dynamic in the module `m'.

  2. `b/1' is defined in module `a' (the module of the file).

  3. `c/1' is defined in module `m'.

  4. `d/1' is defined in module `m', but `q/1' and `r/1' are called in
     module `a' (and must therefore be defined in module `a').

  5. `e/1' is defined in module `m', and `s/1' and `t/1' are called in
     module `m'.

  6. `f/1' is defined in module `a', but `u/1' and `v/1' are called in
     module `m'.

   Module prefixing is especially useful when the module prefix is
`user'.  There are several predicates that have to be defined in module
`user' but that you may want to define (or extend) in a program that is
otherwise entirely defined in some other module or modules; *note
mpg-top-hok::.

   Note that if clauses for one of these predicates are to be spread
across multiple files, it will be necessary to declare that predicate
to be multifile by putting a multifile declaration in each of the files.


File: sicstus.info,  Node: ref-mod-mpc-cmo,  Up: ref-mod-mpc

4.11.10.1 Current Modules
.........................

A loaded, or dynamically created, module becomes current as soon as it
is encountered, and a module can never lose the property of being
current. The set of current modules can be obtained with
`current_module/1', see *note ref-mod-ilm::.


File: sicstus.info,  Node: ref-mod-cim,  Next: ref-mod-ncl,  Prev: ref-mod-mpc,  Up: ref-mod

4.11.11 Debugging Code in a Module
----------------------------------

Having loaded a module to be debugged, you can trace through its
execution in the normal way.  When the debugger stops at a port, the
procedure being debugged is displayed with its module name as a prefix
unless the module is `user'.

   The predicate `spy/1'  depends on the source module.  It can be
useful to override this during debugging.  For example,
     | ?- spy mod1:f/3.

puts a spypoint on `f/3' in module `mod1'.

   It can also be useful to call directly a predicate that is private
to its module in order to test that it is doing the right thing.  This
can be done by prefixing the goal with its module; for example,
     | ?- mod1:f(a,b,X).


File: sicstus.info,  Node: ref-mod-ncl,  Next: ref-mod-ilm,  Prev: ref-mod-cim,  Up: ref-mod

4.11.12 Name Clashes
--------------------

A "name clash" can arise if:
  1. a module tries to import a predicate from some other module `m1'
     and it has already imported a predicate with the same name and
     arity from a module `m2';

  2. a module tries to import a predicate from some other module `m1'
     and it already contains a definition of a predicate with the same
     name and arity; or

  3. a module tries to define a predicate with the same name and arity
     as one that it has imported.

   Whenever a name clash arises, a message is displayed beginning with
the words `NAME CLASH'.  The user is asked to choose from one of
several options; for example,
     NAME CLASH: f/3 is already imported into module user
                 from module m1;
                 do you want to override this definition with
                 the one in m2? (y,n,p,s,a or ?)

   The meanings of the five recognized replies are as follows:

`y'
     forget the previous definition of `f/3' from `m1' and use the new
     definition of `f/3' from `m2' instead.

`n'
     retain the previous definition of `f/3' from `m1' and ignore the
     new definition of `f/3' from `m2'.

`p'
     (for proceed) means forget the previous definition of `f/3' and of
     all subsequent predicate definitions in `m1' that clash during the
     current load of `m2'.  Instead, use the new definitions in `m2'.
     When the `p' option is chosen, predicates being loaded from `m1'
     into `m2' will cause no `NAME CLASH' messages for the remainder of
     the load, though clashes with predicates from other modules will
     still generate such messages.

`s'
     (for suppress) means forget the new definition of `f/3' and of all
     subsequent predicate definitions in `m1' that clash during the
     current load of `m2'.  Instead, use the old definitions in `m2'.
     When the `s' option is chosen, predicates being loaded from `m1'
     into `m2' will cause no `NAME CLASH' messages for the remainder of
     the load, though clashes with predicates from other modules will
     still generate such messages.

`?'
     gives brief help information.


File: sicstus.info,  Node: ref-mod-ilm,  Next: ref-mod-idp,  Prev: ref-mod-ncl,  Up: ref-mod

4.11.13 Obtaining Information about Loaded Modules
--------------------------------------------------

* Menu:

* ref-mod-ilm-def::                     Predicates Defined in a Module
* ref-mod-ilm-vis::                     Predicates Visible in a Module

   The built-in predicate `current_module/2' can be used to find all
the currently loaded module, and where they were loaded from.  *Note
mpg-ref-current_module::.  

`current_module(?M)'
     M is the name of a current module

`current_module(?M,?F)'
     F is the name of the file in which M's module declaration appears.
     Not all modules have a corresponding file.


File: sicstus.info,  Node: ref-mod-ilm-def,  Next: ref-mod-ilm-vis,  Up: ref-mod-ilm

4.11.13.1 Predicates Defined in a Module
........................................

The built-in predicate `current_predicate/2' can be used to find the
predicates that are defined in a particular module.

   To backtrack through all of the predicates defined in module `m', use 

     | ?- current_predicate(_, m:Goal).

   To backtrack through _all_ predicates defined in _any_ module, use
     | ?- current_predicate(_, M:Goal).

   This succeeds once for every predicate in your program.  *Note
mpg-ref-current_predicate::.


File: sicstus.info,  Node: ref-mod-ilm-vis,  Prev: ref-mod-ilm-def,  Up: ref-mod-ilm

4.11.13.2 Predicates Visible in a Module
........................................

The built-in predicate `predicate_property/2' can be used to find the
properties of any predicate that is visible to a particular module.

   To backtrack through all of the predicates imported by module `m',
use 

     | ?- predicate_property(m:Goal, imported_from(_)).

   To backtrack through all of the predicates imported by module `m1'
from module `m2', use 

     | ?- predicate_property(m1:Goal, imported_from(m2)).

   For example, you can load the `between' module from the library and
then remind yourself of what predicates it defines like this:

     | ?- compile(library(between)).
     % ... loading messages ...

     yes
     | ?- predicate_property(P, imported_from(between)).
     P = numlist(_A,_B) ? ;
     P = numlist(_A,_B,_C,_D,_E) ? ;
       .
       .
       .

   This tells you what predicates are imported into the type-in module
from `basics'.

   You can also find _all_ imports into _all_ modules using
     | ?- predicate_property(M1:G, imported_from(M2)).

   To backtrack through all of the defined predicates exported by
module `m', use 

     | ?- predicate_property(m:Goal, exported).
*Note mpg-ref-predicate_property::.


File: sicstus.info,  Node: ref-mod-idp,  Next: ref-mod-mne,  Prev: ref-mod-ilm,  Up: ref-mod

4.11.14 Importing Dynamic Predicates
------------------------------------

Imported dynamic predicates may be asserted and retracted.  For
example, suppose the following file is loaded via `use_module/1':

     :- module(m1, [f/1]).
     :- dynamic f/1.
     f(0).

   Then `f/1' can be manipulated as if it were defined in the current
module.  For example,
     | ?- clause(f(X), true).

     X = 0

   The built-in predicate `listing/[0,1]' distinguishes predicates that
are imported into the current source module by prefixing each clause
with the module name.  Thus, 

     | ?- listing(f).

     m1:f(0).

   However, `listing/[0,1]' does not prefix clauses with their module
if they are defined in the source module itself.  Note that
     | ?- listing.

can be used to see all the dynamic predicates defined in or imported
into the current type-in module.  And
     | ?- listing(m1:_).

can be used to see all such predicates that are defined in or imported
into module `m1'.  *Note mpg-ref-listing::.


File: sicstus.info,  Node: ref-mod-mne,  Next: ref-mod-met,  Prev: ref-mod-idp,  Up: ref-mod

4.11.15 Module Name Expansion
-----------------------------

The concept of a source module is explained in *note ref-mod-som::.
For any goal, the applicable source module is determined when the goal
is compiled rather than when it is executed.

   A procedure that needs to refer to the source module has arguments
designated for module name expansion.  These arguments are expanded
when code is consulted, compiled or asserted by the transformation X ->
M:X where M is the name of the source module.  For example, the goal
`call(X)' is expanded into `call(M:X)' and the goal `clause(Head, Body)'
is expanded into `clause(M:Head, Body)'.

   Module name expansion is avoided if the argument to be expanded is
already a `:/2' term.  In this case it is unnecessary since the module
to be used has already been supplied by the programmer.


File: sicstus.info,  Node: ref-mod-met,  Next: ref-mod-sem,  Prev: ref-mod-mne,  Up: ref-mod

4.11.16 The `meta_predicate' Declaration
----------------------------------------

Sometimes a user-defined predicate will require module name expansion
(see *note ref-mod-mne::).  This can be specified by providing a
`meta_predicate' declaration for that procedure.

   Module name expansion is needed whenever the argument of a predicate
has some module-dependent meaning.  For example, if this argument is a
goal that is to be called, it will be necessary to know in which module
to call it--or, if the argument is a clause to be asserted, in which
module it should go.

   Consider, for example, a sort routine to which the name of the
comparison predicate is passed as an argument.  In this example, the
comparison predicate should be called, with two arguments like the
built-in `@=</2', with respect to the module containing the call to the
sort routine.  Suppose that the sort routine is
     mysort(COMPAREPROC, INPUTLIST, OUTPUTLIST)

   An appropriate `meta_predicate' declaration for this is
     :- meta_predicate mysort(2, +, -).

   The significant argument in the `mysort/3' term is the `2', which
indicates that module name expansion is required for this argument and
that two additional arguments will be added when this argument is
invoked as a goal.  This means that whenever a goal `mysort(A, B, C)'
appears in a clause, it will be transformed at load time into
`mysort(M:A, B, C)', where M is the source module.  There are some
exceptions to this compile-time transformation rule; the goal is not
transformed if either of the following applies:

  1. A is of the form MODULE:GOAL.

  2. A is a variable and the same variable appears in the head of the
     clause in a module-name-expansion position.

   The reason for (2) is that otherwise module name expansion could
build larger and larger structures of the form MN: ... :M2:M1:GOAL.
For example, consider the following program fragment adapted from the
library (see `library(samsort)' for the full program):

     :- module(samsort, [samsort/3]).

     :- meta_predicate
             samsort(2, +, ?),
             sam_sort(+, 2, +, +, ?).

     samsort(_, [], []) :- !.
     samsort(Order, List, Sorted) :-
             sam_sort(List, Order, [], 0, Sorted).
       .
       .
       .

   Normally, the `sam_sort/5' goal in this example would have the
module name of its second argument expanded thus:
     sam_sort(List, samsort:Order, [], 0, Sorted)

because of the `meta_predicate' declaration.  However, in this
situation the appropriate source module will have already been attached
to ORDER because it is the first argument of `samsort/3', which also
has a `meta_predicate' declaration.  Therefore it is not useful to
attach the module name (`samsort') to ORDER in the call of `sam_sort/5'.

   The argument of a `meta_predicate' declaration can be a term, or a
sequence of terms separated by commas.  Each argument of each of these
terms must be one of the following:

`:'
     requires module name expansion

     If the argument will be treated as a goal, it is better to
     explicitly indicate this using an integer; see the next item.

NSUPPRESSED
     a non-negative integer.

     This is a special case of `:' which means that the argument can be
     made into a goal by adding NSUPPRESSED additional arguments. E.g.,
     if the argument will be passed to `call/1' then `0' (zero) should
     be used.

     An integer is treated the same as `:' above by the SICStus
     runtime. Other tools, such as the cross referencer (*note The
     Cross-Referencer::) and the SICStus Prolog IDE (*note SICStus
     Prolog IDE: SPIDER.), will use this information to better follow
     predicate references in analyzed source code.

     If the number of extra arguments is unknown or varies, the generic
     `:' is always safe to use, but will give less accurate results from
     source analysis tools.

`*'
`+'
`-'
`?'
     ignored

   The reason for `+', `-' and `?' is simply so that the information
contained in a DEC-10 Prolog-style "mode" declaration may be represented
in the `meta_predicate' declaration if you wish.  There are many
examples of `meta_predicate' declarations in the library.

   Prior to release 4.1, only `:' (colon) was used and the integer form
was undocumented (but supported, e.g. by the cross referencer).


File: sicstus.info,  Node: ref-mod-sem,  Next: ref-mod-sum,  Prev: ref-mod-met,  Up: ref-mod

4.11.17 Semantics of Module Name Expansion
------------------------------------------

Although module name expansion is performed when code is consulted,
compiled or asserted, it is perhaps best explained in terms of an
interpreter, especially the issue of how deeply clauses are expanded.
The semantics of `call/1', taking `meta_predicate' declarations into
account, is shown as if defined by the interpreter shown below.  The
interpreter's case analysis is as follows:

CONTROL CONSTRUCTS
     (Including cuts and module prefixes).  The interpreter implements
     the semantics of the construct, expanding its argument.

CALLABLE TERMS WITH FUNCTOR N/A
     First, we look for a `meta_predicate' declaration for N/A.  If one
     exists, the relevant arguments are expanded.  Otherwise, the goal
     is left unexpanded.  Then, if N/A is a built-in predicate, it is
     called.  Otherwise, a clause with head functor N/A is looked up
     using the imaginary predicate `:-/2', unified against, and its
     body is interpreted.

NON-CALLABLE TERMS
     Raise error exception.

   Throughout the interpretation, we must keep track of the module
context.  The interpreter is as follows, slightly simplified.  `-->/2'
is _not_ a predicate:

     call(M:Body) :-
             call(Body, M).

     call(Var, M) :- \+callable(Var), !,
             must_be(Term, callable, call(M:Var), 1).
     call(!, _) :- !,
             % _cut relevant choicepoints._
     call((A, B), M) :- !,
             call(A, M),
             call(B, M).
     call((A -> B), M) :- !,
         (   call(A, M) ->
             call(B, M)
         ).
     call((A -> B ; C), M) :- !,
         (   call(A, M) ->
             call(B, M)
         ;   call(C, M)
         ).
     call((A ; B), M) :- !,
         (   call(A, M)
         ;   call(B, M)
         ).
     call(\+(A), M) :- !,
         (   call(A, M) ->
             fail
         ;   true
         ).
     call(_^A, M) :- !,
             call(A, M).
     call(do(Iter,Body), M) :- !,
         (   Iter
         do  call(Body, M)
         ).
     call(if(A,B,C), M) :- !,
          if(call(A, M),
             call(B, M),
             call(C, M)).
     call(once(A), M) :- !,
         (   call(A, M) -> true
         ).
     call(Goal, M) :-
         (   predicate_property(M:Goal, meta_predicate(Meta)) ->
             functor(Goal, Name, Arity),
             functor(AGoal, Name, Arity),
             (   foreacharg(Spec,Meta),
                 foreacharg(Arg,Goal),
                 foreacharg(Ann,AGoal),
                 param(M)
             do  (   Spec==(:) -> Ann = M:Arg
                 ;   integer(Spec) -> Ann = M:Arg
                 ;   Ann = Arg
                 )
             ),
             call_goal(AGoal, M)
         ;   call_goal(Goal, M)
         ).

     call_goal(asserta(X), _) :- !,
             asserta(X).
     call_goal(asserta(X,R), _) :- !,
             asserta(X, R).
     % _and so on for all built-in predicates_
     call_goal(Goal, M) :-
             (M:Goal :- Body),
             call(Body, M).


File: sicstus.info,  Node: ref-mod-sum,  Prev: ref-mod-sem,  Up: ref-mod

4.11.18 Predicate Summary
-------------------------

`current_module(?M)'
     M is the name of a current module

`current_module(?M,?F)'
     F is the name of the file in which M's module declaration appears

`meta_predicate :P   *declaration*'
     declares predicates P that are dependent on the module from which
     they are called

`module(+M,+L)   *declaration*'
`module(+M,+L,+O)   *declaration*'
     declaration that module M exports predicates in L, options O

`save_modules(+L,+F)'
     save the modules specifed in L into file F

`set_module(+M)'
     make M the type-in module

`use_module(:F)'
     import the module-file(s) F, loading them if necessary

`use_module(:F,+I)'
     import the procedure(s) I from the module-file F

`use_module(?M,:F,+I)'
     import I from module M, loading module-file F if necessary



File: sicstus.info,  Node: ref-mdb,  Next: ref-all,  Prev: ref-mod,  Up: Prolog Intro

4.12 Modification of the Database
=================================

* Menu:

* ref-mdb-bas::                         Introduction
* ref-mdb-dsp::                         Dynamic and Static Procedures
* ref-mdb-dre::                         Database References
* ref-mdb-acd::                         Adding Clauses to the Database
* ref-mdb-rcd::                         Removing Clauses from the Database
* ref-mdb-acl::                         Accessing Clauses
* ref-mdb-exa::                         Modification of Running Code: Examples
* ref-mdb-idb::                         The Internal Database
* ref-mdb-bbd::                         The Blackboard
* ref-mdb-sum::                         Summary of Predicates


File: sicstus.info,  Node: ref-mdb-bas,  Next: ref-mdb-dsp,  Up: ref-mdb

4.12.1 Introduction
-------------------

The family of assertion and retraction predicates described below
enables you to modify a Prolog program by adding or deleting clauses
while it is running.  These predicates should not be overused.   Often
people who are experienced with other programming languages have a
tendency to think in terms of global data structures, as opposed to
data structures that are passed as procedure arguments, and hence they
make too much use of assertion and retraction.  This leads to less
readable and less efficient programs.

   An interesting question in Prolog is what happens if a procedure
modifies itself, by asserting or retracting a clause, and then fails.
On backtracking, does the current execution of the procedure use new
clauses that are added to the bottom of the procedure?

     *Historical note:* In some non-ISO-conforming implementations of
     Prolog, changes to the Prolog database become globally visible upon
     the success of the built-in predicate modifying the database.  An
     unsettling consequence is that the definition of a procedure can
     change while it is being run.  This can lead to code that is
     difficult to understand.  Furthermore, the memory performance of
     the interpreter implementing these semantics is poor.  Worse yet,
     the semantics rendered ineffective the added determinacy detection
     available through indexing.

   SICStus Prolog implements the "logical" view in updating dynamic
predicates, conforming to the ISO standard.  This means that the
definition of a dynamic procedure that is visible to a call is
effectively frozen when the call is made.  A procedure always contains,
as far as a call to it is concerned, exactly the clauses it contained
when the call was made.

   A useful way to think of this is to consider that a call to a
dynamic procedure makes a "virtual copy" of the procedure and then runs
the copy rather than the original procedure.  Any changes to the
procedure made by the call are immediately reflected in the Prolog
database, but not in the copy of the procedure being run.  Thus,
changes to a running procedure will not be visible on backtracking.  A
subsequent call, however, makes and runs a copy of the modified Prolog
database.  Any changes to the procedure that were made by an earlier
call will now be visible to the new call.

   In addition to being more intuitive and easy to understand, the new
semantics allow interpreted code to execute with the same determinacy
detection (and excellent memory performance) as static compiled code
(*note Indexing:: for more information on determinacy detection).


File: sicstus.info,  Node: ref-mdb-dsp,  Next: ref-mdb-dre,  Prev: ref-mdb-bas,  Up: ref-mdb

4.12.2 Dynamic and Static Procedures
------------------------------------

All Prolog procedures are classified as being either "static" or
"dynamic procedures".  Static procedures can be changed only by
completely redefining them using the Load Predicates (see *note
ref-lod::).  Dynamic procedures can be modified by adding or deleting
individual clauses using the assert and retract procedures.

   If a procedure is defined by loading source code, it is static by
default.  If you need to be able to add, delete, or inspect the
individual clauses of such a procedure, you must make the procedure
dynamic.

   There are two ways to make a procedure dynamic:
   * If the procedure is defined by loading source code, it must be
     declared to be dynamic before it is defined.

   * If the procedure is to be created by assertions only, the first
     `assert' operation on the procedure automatically makes it dynamic.

   A procedure is declared dynamic by preceding its definition with a
declaration of the form:
     :- dynamic :PRED

where PRED must be a procedure specification of the form NAME/ARITY, or
a sequence of such specifications, separated by commas.  For example,
     :- dynamic exchange_rate/3, spouse_of/2,
                gravitational_constant/1.

where `dynamic' is a built-in prefix operator.  If PRED is not of the
specified form an exception is raised, and the declaration is ignored.

   Note that the symbol `:- ' preceding the word `dynamic' is essential.
If this symbol is omitted, a permission error is raised because it
appears that you are trying to define a clause for the built-in
predicate `dynamic/1'.  Although `dynamic/1' is a built-in predicate,
it may only be used in declarations.

   When a dynamic declaration is encountered in a file being loaded, it
is considered to be a part of the redefinition of the procedures
specified in its argument.  Thus, if you load a file containing only
     :- dynamic hello/0

the effect will be to remove any previous definition of `hello/0' from
the database, and to make the procedure dynamic.  You cannot make a
procedure dynamic retroactively.  If you wish to make an
already-existing procedure dynamic it must be redefined.

   It is often useful to have a dynamic declaration for a procedure
even if it is to be created only by assertions.  This helps another
person to understand your program, since it emphasizes the fact that
there are no pre-existing clauses for this procedure, and it also
avoids the possibility of Prolog stopping to tell you there are no
clauses for this procedure if you should happen to call it before any
clauses have been asserted.  This is because unknown procedure catching
(see *note Undefined Predicates::) does not apply to dynamic
procedures; it is presumed that a call to a dynamic procedure should
simply fail if there are no clauses for it.  

   If a program needs to make an undefined procedure dynamic, this can
be achieved by calling `clause/2' on that procedure.  The call will
fail because the procedure has no clauses, but as a side-effect it will
make the procedure dynamic and thus prevent unknown procedure catching
on that procedure.  See the Reference page for details of `clause/2'.

   Although you can simultaneously declare several procedures to be
dynamic, as shown above, it is recommended that you use a separate
dynamic declaration for each procedure placed immediately before the
clauses for that procedure.  In this way when you reload the procedure
using the editor interface, you will be reminded to include its dynamic
declaration.

   Dynamic procedures are implemented by interpretation, even if they
are included in a file that is compiled.  This means that they are
executed more slowly than if they were static, and also that they can be
printed using `listing/0'.  Dynamic procedures, as well as static
procedures, are indexed on their first argument; see *note Indexing::.  


File: sicstus.info,  Node: ref-mdb-dre,  Next: ref-mdb-acd,  Prev: ref-mdb-dsp,  Up: ref-mdb

4.12.3 Database References
--------------------------

A "database reference" is a term that uniquely identifies a clause or
recorded term (see *note ref-mdb-idb::) in the database.  Database
references are provided only to increase efficiency in programs that
access the database in complex ways.  Use of a database reference to a
clause can save repeated searches using `clause/2'.  However, it does
_not_ normally pay to access a clause via a database reference when
access via first argument indexing is possible.


File: sicstus.info,  Node: ref-mdb-acd,  Next: ref-mdb-rcd,  Prev: ref-mdb-dre,  Up: ref-mdb

4.12.4 Adding Clauses to the Database
-------------------------------------

The assertion predicates are used to add clauses to the database in
various ways.  The relative position of the asserted clause with
respect to other clauses for the same predicate is determined by the
choice among `assert/1', `asserta/1', and `assertz/1'.  A database
reference that uniquely identifies the clause being asserted is
established by providing an optional second argument to any of the
assertion predicates.

`assert(:C)'
     clause C is asserted in an arbitrary position in its predicate

`assert(:C,-R)'
     as `assert/1'; reference R is returned

`asserta(:C)'
     clause C is asserted before existing clauses

`asserta(:C,-R)'
     as `asserta/1'; reference R is returned

`assertz(:C)'
     clause C is asserted after existing clauses

`assertz(:C,-R)'
     as `assertz/1'; reference R is returned

   *Please note*: If the term being asserted contains attributed
variables (*note lib-atts::) or suspended goals (*note ref-sem-sec::),
those attributes are not stored in the database.  To retain the
attributes, you can use `copy_term/3' (*note ref-lte-cpt::).


File: sicstus.info,  Node: ref-mdb-rcd,  Next: ref-mdb-acl,  Prev: ref-mdb-acd,  Up: ref-mdb

4.12.5 Removing Clauses from the Database
-----------------------------------------

* Menu:

* ref-mdb-rcd-efu::                     A Note on Efficient Use of retract/1

   This section briefly describes the predicates used to remove the
clauses and/or properties of a predicate from the system.

     *Please note:*  Removing all of a predicate's clauses by
     `retract/1' and/or `erase/1' (see *note ref-mdb-rcd-efu::) does
     not remove the predicate's properties (and hence its definition)
     from the system.  The only way to completely remove a predicate's
     clauses _and_ properties is to use `abolish/[1,2]'.

`retract(:C)'
     erase the first dynamic clause that matches C

`retractall(:H)'
     erase every clause whose head matches H

`abolish(:F)'
     abolish the predicate(s) specified by F

`abolish(:F,+O)'
     abolish the predicate(s) specified by F with options O

`erase(+R)'
     erase the clause or recorded term (see *note ref-mdb-idb::) with
     reference R


File: sicstus.info,  Node: ref-mdb-rcd-efu,  Up: ref-mdb-rcd

4.12.5.1 A Note on Efficient Use of `retract/1'
...............................................

_WARNING:_ `retract/1' is a nondeterminate procedure.  Thus, we can use
     | ?- retract((foo(X) :- Body)), fail.

to retract all clauses for `foo/1'.  A nondeterminate procedure in
SICStus Prolog uses a "choicepoint", a data  structure kept on an
internal stack, to implement backtracking.  This applies to
user-defined procedures as well as to built-in and library procedures.
In a simple model, a choicepoint is created for each call to a
nondeterminate procedure, and is deleted on determinate success or
failure of that call, when backtracking is no longer possible.  In
fact, SICStus Prolog improves upon this simple model by recognizing
certain contexts in which choicepoints can be avoided, or are no longer
needed.

   The Prolog "cut" (`!') works by removing choicepoints, disabling the
potential backtracking they represented.  A choicepoint can thus be
viewed as an "outstanding call", and a "cut" as deleting outstanding
calls.

   To avoid leaving inconsistencies between the Prolog database and
outstanding calls, a retracted clause is reclaimed only when the system
determines that there are no choicepoints on the stack that could allow
backtracking to the clause.  Thus, the existence of a single
choicepoint on the stack can disable reclamation of retracted clauses
for the procedure whose call created the choicepoint.  Space is
recovered only when the choicepoint is deleted.

   Often `retract/1' is used determinately; for example, to retract a
single clause, as in
     | ?- <do some stuff>
           retract(Clause),
          <do more stuff without backtracking>.

   No backtracking by `retract/1' is intended.  Nonetheless, if Clause
may match more than one clause in its procedure, a choicepoint will be
created by `retract/1'.  While executing "<do more stuff without
backtracking>", that choicepoint will remain on the stack, making it
impossible to reclaim the retracted Clause.  Such choicepoints can also
disable tail recursion optimization.  If not cut away, the choicepoint
can also lead to runaway retraction on the unexpected failure of a
subsequent goal.  This can be avoided by simply cutting away the
choicepoint with an explicit `cut' or a local cut (`->').  Thus, in the
previous example, it is preferable to write either
     | ?- <do some stuff>
           retract(Clause),
           !,
          <do more stuff without backtracking>.

or

     | ?- <do some stuff>
          ( retract(Clause) -> true ),
          <do more stuff without backtracking>.

   This will reduce stack size and allow the earliest possible
reclamation of retracted clauses.


File: sicstus.info,  Node: ref-mdb-acl,  Next: ref-mdb-exa,  Prev: ref-mdb-rcd,  Up: ref-mdb

4.12.6 Accessing Clauses
------------------------

`Goal'
     Succeeds If:

`clause(:P,?Q)'
     there is a clause for a dynamic predicate with head P and body Q

`clause(:P,?Q,?R)'
     there is a clause for a dynamic predicate with head P, body Q, and
     reference R

`instance(+R,-T)'
     T is an instance of the clause or term referenced by R



File: sicstus.info,  Node: ref-mdb-exa,  Next: ref-mdb-idb,  Prev: ref-mdb-acl,  Up: ref-mdb

4.12.7 Modification of Running Code: Examples
---------------------------------------------

* Menu:

* ref-mdb-exa-asz::                     Example: assertz
* ref-mdb-exa-rtr::                     Example: retract
* ref-mdb-exa-abo::                     Example: abolish

   The following examples show what happens when a procedure is
modified while it is running.  This can happen in two ways:
  1. The procedure calls some other procedure that modifies it.

  2. The procedure succeeds nondeterminately, and a subsequent goal
     makes the modification.
         In either case, the question arises as to whether the
modifications take effect upon backtracking into the modified
procedure.  In SICStus Prolog the answer is that they don't.  As
explained in the overview to this section (see *note ref-mdb-bas::),
modifications to a procedure affect only calls to that procedure that
occur after the modification.


File: sicstus.info,  Node: ref-mdb-exa-asz,  Next: ref-mdb-exa-rtr,  Up: ref-mdb-exa

4.12.7.1 Example: assertz
.........................

Consider the procedure `foo/0' defined by

     :- dynamic foo/0.
     foo :- assertz(foo), fail.

   Each call to `foo/0' asserts a new last clause for `foo/0'.  After
the Nth call to `foo/0' there will be N+1 clauses for `foo/0'.  When
`foo/0' is first called, a virtual copy of the procedure is made,
effectively freezing the definition of `foo/0' for that call.  At the
time of the call, `foo/0' has exactly one clause.  Thus, when `fail/0'
forces backtracking, the call to `foo/0' simply fails: it finds no
alternatives.  For example,

     | ?- compile(user).
     | :- dynamic foo/0.
     | foo :- assertz(foo), fail.
     | ^D
     % user compiled in module user, 0.100 sec 2.56 bytes

     yes
     | ?- foo.  % The asserted clause is not found

     no
     | ?- foo.  % A later call does find it, however

     yes
     | ?-

   Even though the virtual copy of `foo/0' being run by the first call
is not changed by the assertion, the Prolog database is.  Thus, when a
second call to `foo/0' is made, the virtual copy for that call contains
two clauses.  The first clause fails, but on backtracking the second
clause is found and the call succeeds.


File: sicstus.info,  Node: ref-mdb-exa-rtr,  Next: ref-mdb-exa-abo,  Prev: ref-mdb-exa-asz,  Up: ref-mdb-exa

4.12.7.2 Example: retract
.........................

     | ?- assert(p(1)), assert(p(2)), assert(p(3)).

     yes
     | ?- p(N), write(N), nl, retract(p(2)),
          retract(p(3)), fail.
     1
     2
     3

     no
     | ?- p(N), write(N), fail.
     1
     no
     | ?-

At the first call to `p/1', the procedure has three clauses.  These
remain visible throughout execution of the call to `p/1'.  Thus, when
backtracking is forced by `fail/0', N is bound to 2 and written.  The
retraction is again attempted, causing backtracking into `p/1'.  N is
bound to 3 and written out.  The call to `retract/1' fails.  There are
no more clauses in `p/1', so the query finally fails.  A subsequent
call to `p/1', made after the retractions, sees only one clause.


File: sicstus.info,  Node: ref-mdb-exa-abo,  Prev: ref-mdb-exa-rtr,  Up: ref-mdb-exa

4.12.7.3 Example: abolish
.........................

     | ?- compile(user).
     | :- dynamic q/1.
     | q(1).
     | q(2).
     | q(3).
     | ^D
     % user compiled in modules user, 0.117 sec 260 bytes

     yes
     | ?- q(N), write(N), nl, abolish(q/1), fail.
     1
     2
     3

     no
     | ?-

Procedures that are abolished while they have outstanding calls don't
become invisible to those calls.  Subsequent calls however, will find
the procedure undefined.


File: sicstus.info,  Node: ref-mdb-idb,  Next: ref-mdb-bbd,  Prev: ref-mdb-exa,  Up: ref-mdb

4.12.8 The Internal Database
----------------------------

The following predicates are provided solely for compatibility with
other Prolog systems.  Their semantics can be understood by imagining
that they are defined by the following clauses:
     recorda(Key, Term, Ref) :-
          functor(Key, Name, Arity),
          functor(F, Name, Arity),
          asserta('$recorded'(F,Term), Ref).
     recordz(Key, Term, Ref) :-
          functor(Key, Name, Arity),
          functor(F, Name, Arity),
          assertz('$recorded'(F,Term), Ref).
     recorded(Key, Term, Ref) :-
          functor(Key, Name, Arity),
          functor(F, Name, Arity),
          clause('$recorded'(F,Term), _, Ref).

   The reason for the calls to `functor/3' in the above definition is
that only the principal functor of the key is significant.  If KEY is a
compound term, its arguments are ignored.

     *Please note:* Equivalent functionality and performance, with
     reduced memory costs, can usually be had through normal dynamic
     procedures and indexing (see *note ref-mdb-bas:: and *note
     Indexing::).

   `recorda(KEY, TERM, REF)' records the TERM in the internal database
as the first item for the key KEY; a database reference to the
newly-recorded term is returned in REF.

   `recordz(KEY, TERM, REF)' is like `recorda/3' except that it records
the term as the last item in the internal database.

   `recorded(KEY, TERM, REF)' searches the internal database for a term
recorded under the key KEY that unifies with TERM, and whose database
reference unifies with REF.

   `current_key(KEYNAME, KEYTERM)' succeeds when KEYNAME is the atom or
integer that is the name of KEYTERM.  KEYTERM is an integer, atom, or
compound term that is the key for a currently recorded term.


File: sicstus.info,  Node: ref-mdb-bbd,  Next: ref-mdb-sum,  Prev: ref-mdb-idb,  Up: ref-mdb

4.12.9 Blackboard Primitives
----------------------------

The predicates described in this section store arbitrary terms in a
per-module repository known as the "blackboard".  The main purpose of
the blackboard was initially to provide a means for communication
between branches executing in parallel, but the blackboard works
equally well during sequential execution.  The blackboard implements a
mapping from keys to values.  Keys are restricted to being atoms or
small integers, whereas values are arbitrary terms.  In contrast to the
predicates described in the previous sections, a given key can map to
at most a single term.

   Each Prolog module maintains its own blackboard, so as to avoid name
clashes if different modules happen to use the same keys.  The "key"
arguments of these predicates are subject to module name expansion, so
the module name does not have to be explicitly given unless multiple
Prolog modules are supposed to share a single blackboard.

   The predicates below implement atomic blackboard actions.

`bb_put(:KEY, +TERM)'
     A copy of TERM is stored under KEY.  *Note mpg-ref-bb_put::.

`bb_get(:KEY, ?TERM)'
     If a term is currently stored under KEY, a copy of it is unified
     with TERM.  Otherwise, `bb_get/2' silently fails.  *Note
     mpg-ref-bb_get::.

`bb_delete(:KEY, ?TERM)'
     If a term is currently stored under KEY, the term is deleted, and
     a copy of it is unified with TERM.  Otherwise, `bb_delete/2'
     silently fails.  *Note mpg-ref-bb_delete::.

`bb_update(:KEY, ?OLDTERM, ?NEWTERM)'
     If a term is currently stored under KEY and unifies with OLDTERM,
     the term is replaced by a copy of NEWTERM.  Otherwise,
     `bb_update/3' silently fails.  This predicate provides an atomic
     swap operation.  *Note mpg-ref-bb_update::.

   *Please note*: If the term being stored contains attributed variables
(*note lib-atts::) or suspended goals (*note ref-sem-sec::), those
attributes are not stored.  To retain the attributes, you can use
`copy_term/3' (*note ref-lte-cpt::).

   The following example illustrates how these primitives may be used to
implement a "maxof" predicate that finds the maximum representation computed by
some nondeterminate goal.  We use a single key `max'.  We assume that
GOAL does not produce any "false" solutions that would be eliminated by
cuts in a sequential execution.  Thus, GOAL may need to include
redundant checks to ensure that its solutions are valid, as discussed
above.

     maxof(Value, Goal, _) :-
             bb_put(max, -1),                % initialize max-so-far
             call(Goal),
             update_max(Value),
             fail.
     maxof(_, _, Max) :-
             bb_delete(max, Max),
             Max > 1.

     update_max(New):-
             bb_get(max, Old),
             compare(C, Old, New),
             update_max(C, Old, New).

     update_max(<, Old, New) :- bb_update(max, Old, New).
     update_max(=, _, _).
     update_max(>, _, _).


File: sicstus.info,  Node: ref-mdb-sum,  Prev: ref-mdb-bbd,  Up: ref-mdb

4.12.10 Summary of Predicates
-----------------------------

`abolish(:F)   "ISO"'
     abolish the predicate(s) specified by F

`abolish(:F,+O)'
     abolish the predicate(s) specified by F with options O

`assert(:C)'
`assert(:C,-R)'
     clause C is asserted; reference R is returned

`asserta(:C)   "ISO"'
`asserta(:C,-R)'
     clause C is asserted before existing clauses; reference R is
     returned

`assertz(:C)   "ISO"'
`assertz(:C,-R)'
     clause C is asserted after existing clauses; reference R is
     returned

`bb_delete(:KEY,-TERM)'
     Delete from the blackboard TERM stored under KEY.

`bb_get(:KEY,-TERM)'
     Get from the blackboard TERM stored under KEY.

`bb_put(:KEY,+TERM)'
     Store TERM under KEY on the blackboard.

`bb_update(:KEY, -OLDTERM, +NEWTERM)'
     Replace OLDTERM by NEWTERM under KEY on the blackboard.

`clause(:P,?Q)   "ISO"'
`clause(:P,?Q,?R)'
     there is a clause for a dynamic predicate with head P, body Q, and
     reference R

`current_key(?N, ?K)'
     N is the name and K is the key of a recorded term

`dynamic :P   *ISO,declaration*'
     predicates specified by P are dynamic

`erase(+R)'
     erase the clause or record with reference R

`instance(+R,-T)'
     T is an instance of the clause or term referenced by R

`recorda(+K,+T,-R)'
     make term T the first record under key K; reference R is returned

`recorded(?K,?T,?R)'
     term T is recorded under key K with reference R

`recordz(+K,+T,-R)'
     make term T the last record under key K; reference R is returned

`retract(:C)   "ISO"'
     erase the first dynamic clause that matches C

`retractall(:H)'
     erase every clause whose head matches H


File: sicstus.info,  Node: ref-all,  Next: ref-gru,  Prev: ref-mdb,  Up: Prolog Intro

4.13 Sets and Bags:  Collecting Solutions to a Goal
===================================================

* Menu:

* ref-all-bas::                         Introduction
* ref-all-cse::                         Collecting a Sorted List
* ref-all-cba::                         Collecting a Bag of Solutions
* ref-all-sum::                         Predicate Summary


File: sicstus.info,  Node: ref-all-bas,  Next: ref-all-cse,  Up: ref-all

4.13.1 Introduction
-------------------

When there are many solutions to a goal, and a list of all those
solutions is desired, one means of collecting them is to write a
procedure that repeatedly backtracks into that goal to get another
solution.  In order to collect all the solutions together, it is
necessary to use the database (via assertion) to hold the solutions as
they are generated, because  backtracking to redo the goal would undo
any list construction that had been done after satisfying the goal.

   The writing of such a backtracking loop can be avoided by the use of
one of the built-in predicates `setof/3', `bagof/3' and
`findall/[3,4]', which are described below.  These provide a nice
logical abstraction, whereas with a user-written backtracking loop the
need for explicit side-effects (assertions) destroys the declarative
interpretation of the code.  The built-in predicates are also more
efficient than those a user could write.

   *Please note*: If the solutions being collected contain attributed
variables (*note lib-atts::) or suspended goals (*note ref-sem-sec::),
those attributes are not retained in the list of solutions.  To retain
the attributes, you can use `copy_term/3' (*note ref-lte-cpt::).


File: sicstus.info,  Node: ref-all-cse,  Next: ref-all-cba,  Prev: ref-all-bas,  Up: ref-all

4.13.2 Collecting a Sorted List
-------------------------------

* Menu:

* ref-all-cse-equ::                     Existential Quantifier

   `setof(TEMPLATE, GENERATOR, SET)' returns the set SET of all
instances of TEMPLATE such that GENERATOR is provable, where that set
is non-empty.  The term GENERATOR specifies a goal to be called as if
by `call/1'.  SET is a set of terms represented as a list of those
terms, without duplicates,  in the standard order for terms (see *note
ref-lte-cte::).

   Obviously, the set to be enumerated should be finite, and should be
enumerable by Prolog in finite time.  It is possible for the provable
instances to contain variables, but in this case SET will only provide
an imperfect representation of what is in reality an infinite set.

   If GENERATOR is instantiated, but contains uninstantiated variables
that don't also appear in TEMPLATE, `setof/3' can succeed
nondeterminately, generating alternative values for SET corresponding
to different instantiations of the free variables of GENERATOR.  (It is
to allow for such usage that SET is constrained to be non-empty.)  For
example, if your program contained the clauses
     likes(tom, beer).
     likes(dick, beer).
     likes(harry, beer).
     likes(bill, cider).
     likes(jan, cider).
     likes(tom, cider).

the call
     | ?- setof(X, likes(X,Y), S).

might produce two alternative solutions via backtracking:
     X = _872,
     Y = beer,
     S = [dick,harry,tom] ;

     X = _872,
     Y = cider,
     S = [bill,jan,tom] ;

     no

   The call
     | ?- setof((Y,S), setof(X,likes(X,Y),S), SS).

would then produce

     Y = _402,
     S = _417,
     X = _440,
     SS = [(beer,[dick,harry,tom]),(cider,[bill,jan,tom])] ;

     no
*Note mpg-ref-setof::.


File: sicstus.info,  Node: ref-all-cse-equ,  Up: ref-all-cse

4.13.2.1 Existential Quantifier
...............................

X `^' P is recognized as meaning "there exists an X such that P is
true", and is treated as equivalent to simply calling P.  The use of
the explicit existential quantifier outside `setof/3' and `bagof/3' is
superfluous.

   Variables occurring in GENERATOR will not be treated as free if they
are explicitly bound within GENERATOR by an existential quantifier.  An
existential quantification is written:
     Y^Q

meaning "there exists a Y such that Q is true", where Y is some Prolog
variable.  For example:
     | ?- setof(X, Y^likes(X,Y), S).

would produce the single result
     X = _400,
     Y = _415,
     S = [bill,dick,harry,jan,tom] ;

     no

in contrast to the earlier example.

   Furthermore, it is possible to existentially quantify a term, where
all the variables in that term are taken to be existentially quantified
in the goal.  e.g.

     A=term(X,Y), setof(Z, A^foo(X,Y,Z), L).

will treat X and Y as if they are existentially quantified.


File: sicstus.info,  Node: ref-all-cba,  Next: ref-all-sum,  Prev: ref-all-cse,  Up: ref-all

4.13.3 Collecting a Bag of Solutions
------------------------------------

* Menu:

* ref-all-cba-cal::                     Collecting All Instances

   `bagof/3' is is exactly the same as `setof/3' except that the list
(or alternative lists) returned will not be ordered, and may contain
duplicates.  This relaxation saves time and space in execution.  *Note
mpg-ref-bagof::.


File: sicstus.info,  Node: ref-all-cba-cal,  Up: ref-all-cba

4.13.3.1 Collecting All Instances
.................................

`findall/3' is a special case of `bagof/3', where all free variables in
the generator are taken to be existentially quantified.  Thus the use
of the operator `^' is avoided.  Because `findall/3' avoids the
relatively expensive variable analysis done by `bagof/3', using
`findall/3' where appropriate rather than `bagof/3' can be considerably
more efficient.

   `findall/4' is a variant of `findall/3' with an extra argument to
which the list of solutions is appended. This can reduce the amount of
append operations in the program.  *Note mpg-ref-findall::.


File: sicstus.info,  Node: ref-all-sum,  Prev: ref-all-cba,  Up: ref-all

4.13.4 Predicate Summary
------------------------

`?X ^ :P'
     there exists an X such that P is provable (used in `setof/3' and
     `bagof/3')

`bagof(?X,:P,-B)   "ISO"'
     B is the bag of instances of X such that P is provable

`findall(?T,:G,-L)   "ISO"'
`findall(?T,:G,?L,?R)'
     L is the list of all solutions T for the goal G, concatenated with
     R or with the empty list

`setof(?X,:P,-S)   "ISO"'
     S is the set of instances of X such that P is provable



File: sicstus.info,  Node: ref-gru,  Next: ref-ere,  Prev: ref-all,  Up: Prolog Intro

4.14 Grammar Rules
==================

* Menu:

* ref-gru-dcg::                         Definite Clause Grammars
* ref-gru-gru::                         How to Use the Grammar Rule Facility
* ref-gru-exa::                         An Example
* ref-gru-tra::                         Semantics of Grammar Rules
* ref-gru-sum::                         Summary of Predicates

   This section describes SICStus Prolog's grammar rules, and the
translation of these rules into Prolog clauses.  At the end of the
section is a list of grammar-related built-in predicates.


File: sicstus.info,  Node: ref-gru-dcg,  Next: ref-gru-gru,  Up: ref-gru

4.14.1 Definite Clause Grammars
-------------------------------

Prolog's grammar rules provide a convenient notation for expressing
definite clause grammars, which are useful for the analysis of both
artificial and natural languages.

   The usual way one attempts to make precise the definition of a
language, whether it is a natural language or a programming language,
is through a collection of rules called a "grammar".  The rules of a
grammar define which strings of words or symbols are valid sentences of
the language.  In addition, the grammar generally analyzes the sentence
into a structure that makes its meaning more explicit.

   A fundamental class of grammar is the context-free grammar (CFG),
familiar to the computing community in the notation of "BNF"
(Backus-Naur form). In CFGs, the words, or basic symbols, of the
language are identified by "terminal symbols", while categories of
phrases of the language are identified by non-terminal symbols.  Each
rule of a CFG expresses a possible form for a non-terminal, as a
sequence of terminals and non-terminals.  The analysis of a string
according to a CFG is a parse tree, showing the constitutent phrases of
the string and their hierarchical relationships.

   Context-free grammars (CFGs) consist of a series of rules of the
form:
     NT --> BODY.

where NT is a non-terminal symbol and body is a sequence of one or more
items separated by commas.  Each item is either a non-terminal symbol
or a sequence of terminal symbols.  The meaning of the rule is that
BODY is a possible form for a phrase of type NT. A non-terminal symbol
is written as a Prolog atom, while a sequence of terminals is written
as a Prolog list, whereas a terminal may be any Prolog term.

   Definite clause grammars (DCGs) are a generalization of context-free
grammars and rules corresponding to DCGs are referred to as "Grammar
Rules".  A grammar rule in Prolog takes the general form
     HEAD --> BODY.

meaning "a possible form for  HEAD  is  BODY".  Both  BODY  and  HEAD
are sequences  of  one  or  more  items  linked  by  the  standard
Prolog conjunction operator `,' (comma).

   Definite clause grammars  extend  context-free  grammars  in  the
following ways:

   * A non-terminal symbol  may  be  any  callable Prolog  term.

   * A  terminal  symbol  may  be  any  Prolog  term.   To  distinguish
     terminals  from  non-terminals,  a  sequence  of  one or more
     terminal symbols is written within a grammar rule as a Prolog
     list.   An  empty sequence  is  written  as the empty list `[]'.
     If the terminal symbols are character codes, such lists can be
     written (as elsewhere) as strings.  An empty sequence is written
     as the empty list (`[]' or `""').  

   * Extra conditions, in the form of Prolog procedure  calls,  may  be
     included  in  the  right-hand  side of a grammar rule.  These
     extra conditions allow the explicit use of procedure calls in the
     body of a rule to restrict the constitutents accepted.  Such
     procedure calls are written enclosed in curly brackets (`{' and
     `}').

   * The left-hand side of a grammar rule consists of  a  non-terminal,
     optionally  followed  by  a  sequence of terminals (again written
     as a Prolog list).

   * Alternatives may be stated explicitly in the right-hand side of  a
     grammar rule, using the disjunction operator `;' (semicolon) as in
     Prolog.

   * The cut symbol `!' may be included in the right-hand side of a
     grammar rule, as in a Prolog clause.  The cut symbol does not need
     to be enclosed in curly brackets.  The same is true for the control
     constructs. However, all other built-in predicates not enclosed in
     curly brackets will be treated as non-terminal symbols.  The
     precise meaning of this rule is clarified in *note ref-gru-tra::.  

   * The extra arguments of non-terminals provide the means of building
     structure (such as parse trees) in grammar rules.  As non-terminals
     are "expanded" by matching against grammar rules, structures are
     progressively built up in the course of the unification process.

   * The extra arguments of non-terminals can also provide a general
     treatment of context dependency by carrying test and contextual
     information.


File: sicstus.info,  Node: ref-gru-gru,  Next: ref-gru-exa,  Prev: ref-gru-dcg,  Up: ref-gru

4.14.2 How to Use the Grammar Rule Facility
-------------------------------------------

Following is a summary of the steps that enable you to construct and
utilize definite clause grammars:

   STEPS:

  1. Write a grammar, using `-->/2' to formulate rules.

  2. Compile the file containing the grammar rules.  The Load
     Predicates automatically translate the grammar rules into Prolog
     clauses.

  3. Use `phrase/[2,3]' to parse or generate strings.

   OPTIONAL STEPS:

  1. Modify the way in which Prolog translates your grammar rules by
     defining clauses for `user:term_expansion/6'; *note ref-lod-exp::.

  2. In debugging or in using the grammar facility for more obscure
     purposes it may be useful to understand more about `expand_term/2'.


File: sicstus.info,  Node: ref-gru-exa,  Next: ref-gru-tra,  Prev: ref-gru-gru,  Up: ref-gru

4.14.3 An Example
-----------------

As an example, here is a simple grammar that parses an arithmetic
expression (made up of digits and operators) and computes its representation.
Create a file containing the following rules:

                                                           _grammar.pl_

     expr(Z) --> term(X), "+", expr(Y), {Z is X + Y}.
     expr(Z) --> term(X), "-", expr(Y), {Z is X - Y}.
     expr(X) --> term(X).

     term(Z) --> number(X), "*", term(Y), {Z is X * Y}.
     term(Z) --> number(X), "/", term(Y), {Z is X / Y}.
     term(Z) --> number(Z).

     number(C) --> "+", number(C).
     number(C) --> "-", number(X), {C is -X}.
     number(X) --> [C], {"0"=<C, C=<"9", X is C - "0"}.

   In the last rule, C is the character code of a decimal digit.

   This grammar can now be used to parse and evaluate an expression by
means of the built-in predicates `phrase/[2,3]'.  *Note
mpg-ref-phrase::.  For example,

     | ?- [grammar].
     | ?- phrase(expr(Z), "-2+3*5+1").

     Z = 14

     | ?- phrase(expr(Z), "-2+3*5", Rest).

     Z = 13,
     Rest = [] ;

     Z = 1,
     Rest = "*5" ;

     Z = -2,
     Rest = "+3*5" ;

     no


File: sicstus.info,  Node: ref-gru-tra,  Next: ref-gru-sum,  Prev: ref-gru-exa,  Up: ref-gru

4.14.4 Semantics of Grammar Rules
---------------------------------

Grammar rules are best explained in terms of an interpreter.  The
semantics of `phrase/3' is shown as if defined by the interpreter shown
below.  The interpreter's case analysis is as follows:

CONTROL CONSTRUCTS
     (Including cuts and module prefixes).  The interpreter implements
     the semantics of the construct, descending into its argument. Note
     that other built-in predicates are _not_ treated this way.

LISTS
     Treated as terminal symbols.

CURLY BRACKETS
     Treated as procedure calls.

CALLABLE TERMS WITH FUNCTOR N/A
     A grammar rule with head functor N/A is looked up using the
     imaginary predicate `-->/2', unified against, and its body is
     interpreted.  If none exists, this is treated as a procedure call
     to a predicate N/A+2.

NON-CALLABLE TERMS
     Raise error exception.

   The following points are worth noting:

   * The code below defines what constructs of and to what depth
     grammar rule bodies are interpreted, as opposed to being treated as
     non-terminals.

   * Throughout the interpretation, we must keep track of the module
     context.

   * The head non-terminal of a grammar rule is optionally  followed
     by  a  sequence of terminals. This feature is not supported by the
     interpreter, but is supported in the actual implementation.

   * As a general rule, the last argument is unified _after_ any
     side-effects, including cuts.  This is in line with the rule that
     output arguments should not be unified before a cut (*note Eff
     Overview::). In other words, grammar rules are "steadfast".

   * The last clause gives a clue to how grammar rules are actually
     implemented, i.e. by compile-time transformation to ordinary Prolog
     clauses. A grammar rule with head functor N/A is transformed to a
     Prolog clause with head functor N/A+2, the extra arguments being
     `S0' and `S'. `-->/2' is _not_ a predicate.

   The interpreter is as follows, slightly simplified:

     phrase(M:Body, S0, S) :-
             phrase(Body, M, S0, S).

     phrase(Var, M, S0, S) :- \+callable(Var), !,
             must_be(Var, callable, phrase(M:Var,S0,S), 1).
     phrase(M:Body, _, S0, S) :- !,
             phrase(Body, M, S0, S).
     phrase(!, _, S0, S) :- !,
             _cut relevant choicepoints_,
             S0 = S.                 % _unification AFTER action_
     phrase((A, B), M, S0, S) :- !,
             phrase(A, M, S0, S1),
             phrase(B, M, S1, S).
     phrase((A -> B), M, S0, S) :- !,
         (   phrase(A, M, S0, S1) ->
             phrase(B, M, S1, S)
         ).
     phrase((A -> B ; C), M, S0, S) :- !,
         (   phrase(A, M, S0, S1) ->
             phrase(B, M, S1, S)
         ;   phrase(C, M, S0, S)
         ).
     phrase((A ; B), M, S0, S) :- !,
         (   phrase(A, M, S0, S)
         ;   phrase(B, M, S0, S)
         ).
     phrase(\+(A), M, S0, S) :- !,
         (   phrase(A, M, S0, _) ->
             fail
         ;   S0 = S
         ).
     phrase(_^A, M, S0, S) :- !,
             phrase(A, M, S0, S).
     phrase(do(Iter,Body), M, S0, S) :- !,
         (   Iter,
             fromto(S0,S1,S2,S)
         do  phrase(Body, M, S1, S2)
         ).
     phrase(if(A,B,C), M, S0, S) :- !,
             if(phrase(A, M, S0, S1),
                phrase(B, M, S1, S),
                phrase(C, M, S0, S)).
     phrase(once(A), M, S0, S) :- !,
         (   phrase(A, M, S0, S1) ->
             S1 = S                  % _unification AFTER call_
         ).
     phrase([], _, S0, S) :- !,
             S0 = S.
     phrase([H|T], M, S0, S) :- !,
             S0 = [H|S1],
             phrase(T, M, S1, S).
     phrase({G}, M, S0, S) :- !,
             call(M:G),              % *Please note:* _transparent to cuts_
             S0 = S.                 % _unification AFTER call_
     phrase(NT, M, S0, S) :-
             \+ \+(M:NT --> Rhs), !, % _grammar rule exists?_
             (M:NT --> Rhs),
             phrase(Rhs, M, S0, S).
     phrase(NT, M, S0, S) :-
             call(M:NT, S0, S).      % _otherwise, treat as procedure call_

   As mentioned above, grammar rules are merely a convenient
abbreviation for ordinary Prolog clauses.  Each grammar rule is
translated into a Prolog clause as it is compiled.  This translation is
exemplified below.

   The procedural interpretation of a grammar rule is that it takes an
input list of symbols or character codes, analyzes some initial portion
of that list, and produces the remaining portion (possibly enlarged) as
output for further analysis.  The arguments required for the input and
output lists are not written explicitly in a grammar rule, but are
added when the rule is translated into an ordinary Prolog clause.  The
translations shown differ from the output of `listing/[0,1]' in that
internal translations such as variable renaming are not represented.
This is done in the interests of clarity.  For example, a rule such as
(A) will be depicted as translating into (B) rather than (C).
     p(X) --> q(X).  (A)

     p(X, S0, S) :-
             q(X, S0, S).  (B)

     p(A, B, C) :-
             q(A, B, C).  (C)

   If there is more than one non-terminal on the right-hand side, as in
(D) the corresponding input and output arguments are identified,
translating into (E):

     p(X, Y) --> q(X), r(X, Y), s(Y).  (D)

     p(X, Y, S0, S) :-  (E)
         q(X, S0, S1),
         r(X, Y, S1, S2),
         s(Y, S2, S).

   Terminals are translated using the built-in predicate `=/2'.  For
instance, (F) is translated into (G):

     p(X) --> [go, to], q(X), [stop].  (F)

     p(X, S0, S) :-  (G)
         S0 = [go,to|S1],
         q(X, S1, S2),
         S2 = [stop|S].

   Extra conditions expressed as explicit procedure calls, enclosed in
curly braces, naturally translate into themselves.  For example (H)
translates to (I):
     p(X) --> [X], {integer(X), X > 0}, q(X).  (H)

     p(X, S0, S) :-  (I)
         S0 = [X|S1],
         integer(X),
         X > 0,
         q(X, S1, S).

   Terminals on the left-hand side of a rule, enclosed in square
brackets, also translate into a unification.  For example, (J) becomes
(K):
     is(N), [not] --> [aint].  (J)

     is(N, S0, S) :-  (K)
         S0 = [aint|S1],
         S = [not|S1].

   Disjunction and other control constructs have a fairly obvious
translation.  For example, (L), a rule that equates phrases like
"(sent) a letter to him" and "(sent) him a letter", translates to (M):
     args(X, Y) -->  (L)
         (   indir(X), [to], indir(Y)
         ;   indir(Y), dir(X)
         ).

     args(X, Y, S0, S) :-  (M)
         (   dir(X, S0, S1),
             S1 = [to|S2],
             indir(Y, S2, S)
         ;   indir(Y, S0, S1),
             dir(X, S1, S)
         ).

   In order to look at these translations, declare the grammar rules
dynamic and use `listing/[0,1]'.  However, bear in mind that a grammar
rule with head functor N/A is transformed to a Prolog clause with head
functor N/A+2.  For example, the following declaration for grammar rule
(L) would enable you to list its translation, (M):
      :- dynamic args/4.


File: sicstus.info,  Node: ref-gru-sum,  Prev: ref-gru-tra,  Up: ref-gru

4.14.5 Summary of Predicates
----------------------------

`:HEAD --> :BODY'
     A possible form for HEAD is BODY

`expand_term(+T,-X)   *hookable*'
     term T expands to term X using `user:term_expansion/6' or grammar
     rule expansion

`phrase(:P, -L)'
`phrase(:P, ?L, ?R)'
     R or the empty list is what remains of list L after phrase P has
     been found

`user:term_expansion(+TERM1, +LAYOUT1, +TOKENS1, -TERM2, -LAYOUT2, -TOKENS2)   *hook*'
     Overrides or complements the standard transformations to be done by
     `expand_term/2'.



File: sicstus.info,  Node: ref-ere,  Next: ref-msg,  Prev: ref-gru,  Up: Prolog Intro

4.15 Errors and Exceptions
==========================

* Menu:

* ref-ere-ove::                         Overview
* ref-ere-rex::                         Throwing Exceptions
* ref-ere-hex::                         Handling Exceptions
* ref-ere-err::                         Error Classes
* ref-ere-exa::                         An Example
* ref-ere-leg::                         Legacy Predicates
* ref-ere-int::                         Interrupting Execution
* ref-ere-sum::                         Summary of Predicates


File: sicstus.info,  Node: ref-ere-ove,  Next: ref-ere-rex,  Up: ref-ere

4.15.1 Overview
---------------

Whenever the Prolog system encounters a situation where it cannot
continue execution, it throws an exception.  For example, if a built-in
predicate detects an argument of the wrong type, it throws a
`type_error' exception.  The manual page description of each built-in
predicate lists the kinds of exceptions that can be thrown by that
built-in predicate.

   The default effect of throwing an exception is to terminate the
current computation and then print an error message.  After the error
message, you are back at Prolog's top-level.  For example, if the goal
     X is a/2

is executed somewhere in a program you get
     ! Type error in argument 2 of (is)/2
     ! expected evaluable, but found a/0
     ! goal:  _255 is a/2
     | ?-

   Particular things to notice in this message are:

`!'
     This character indicates that this is an error message rather than
     a warning(1) or informational message.

`Type Error'
     This is the "error class".  Exceptions thrown by the Prolog system
     are called "errors".  Every error is categorized into one of a
     small number of classes.  The classes are listed in *note
     ref-ere-err::.

`goal:'
     The goal that caused the exception to be thrown.

   Built-in predicates check their arguments, but predicates exported by
library modules generally don't, although some do check their arguments
to a lesser or greater extent.

   ---------- Footnotes ----------

   (1) The difference between an error (including exceptions) and a
warning: A "warning" is issued if Prolog detects a situation that is
likely to cause problems, though it is possible that you intended it.
An "error", however, indicates that Prolog recognizes a situation where
it cannot continue.


File: sicstus.info,  Node: ref-ere-rex,  Next: ref-ere-hex,  Prev: ref-ere-ove,  Up: ref-ere

4.15.2 Throwing Exceptions
--------------------------

You can throw exceptions from your own code using:

`throw(+EXCEPTIONTERM)   "ISO"'

   The argument to this predicate is the "exception term", an arbitrary
non-variable term.  *Note mpg-ref-throw::.

   *Please note*: If the exception term contains attributed variables
(*note lib-atts::) or suspended goals (*note ref-sem-sec::), those
attributes don't become part of the exception.  To retain the
attributes, you can use `copy_term/3' (*note ref-lte-cpt::).


File: sicstus.info,  Node: ref-ere-hex,  Next: ref-ere-err,  Prev: ref-ere-rex,  Up: ref-ere

4.15.3 Handling Exceptions
--------------------------

* Menu:

* ref-ere-hex-pgo::                     Protecting a Particular Goal
* ref-ere-hex-hup::                     Handling Unknown Predicates

   It is possible to protect a part of a program against abrupt
termination in the event of an exception.  There are several ways to do
this:

   * Trap exceptions to a particular goal by calling `catch/3' as
     described in *note ref-ere-hex-pgo::.

   * Handle undefined predicates or subsets of them through the hook
     predicate `user:unknown_predicate_handler/3'; *note
     ref-ere-hex-hup::.

   * Trap exceptions matching EXCEPTION to the debugger by defining the
     following hook predicate:

    `user:error_exception(+EXCEPTION)   *hook,development*'
          *Note mpg-ref-error_exception::.

   * Control syntax errors with the `syntax_errors' Prolog flag or with
     the same option to `read_term/[2,3]'; *note ref-ere-err-syn::.

   * Control existence and permission errors in the context of opening
     files with the `fileerrors' Prolog flag or with the same option to
     `absolute_file_name/3'; *note ref-ere-err-exi:: and *note
     ref-ere-err-per::.



File: sicstus.info,  Node: ref-ere-hex-pgo,  Next: ref-ere-hex-hup,  Up: ref-ere-hex

4.15.3.1 Protecting a Particular Goal
.....................................

The built-in predicate `catch/3' enables you to handle exceptions to a
specific goal:

`catch(:PROTECTEDGOAL, ?EXCEPTIONTERM, :HANDLER)   "ISO"'

   PROTECTEDGOAL is executed.  If all goes well, it will behave just as
if you had written `call(PROTECTEDGOAL)' instead.  If an exception is
thrown while PROTECTEDGOAL is running, Prolog will abandon
PROTECTEDGOAL entirely.  Any bindings made by PROTECTEDGOAL will be
undone, just as if it had failed.  If the exception occurred in the
scope of a `call_cleanup(GOAL,CLEANUP)', CLEANUP will be called.
Side-effects, such as asserts and retracts, are not undone, just as
they are not undone when a goal fails.  After undoing the bindings,
Prolog tries to unify the exception term thrown with the EXCEPTIONTERM
argument.  If this unification succeeds, HANDLER will be executed as if
you had written

     EXCEPTIONTERM=<the actual exception term>,
     HANDLER

   If this unification fails, Prolog will keep searching up the ancestor
list looking for another exception handler.  If during this search it
reaches a recursive call to Prolog from C, the recursive calls returns
with an uncaught exception.  If it reaches the top-level (or a break
level), an appropriate error message is printed (using
`print_message/2').

   PROTECTEDGOAL need not be determinate.  That is, backtracking into
PROTECTEDGOAL is possible, and the exception handler becomes reactivated
in this case.  However, if PROTECTEDGOAL is determinate, the call to
`catch/3' is also determinate.

   The PROTECTEDGOAL is logically _inside_ the `catch/3' goal, but the
HANDLER is _not_.  If an exception is thrown inside the HANDLER, this
`catch/3' goal will _not_ be reactivated.  If you want an exception
handler that protects itself, you have to program it, perhaps like this:
     recursive_catch_handler(Err, Goal, Handler) :-
         catch(Goal, Err,
             recursive_catch_handler(Err, Handler, Handler)).
*Note mpg-ref-catch::.

   Certain built-in and library predicates rely on the exception
mechanism, so it is usually a bad idea to let PATTERN be a variable,
matching any exception.  If it must be a variable, the HANDLER should
examine the exception and pass it on if it is not relevant to the
current invocation.


File: sicstus.info,  Node: ref-ere-hex-hup,  Prev: ref-ere-hex-pgo,  Up: ref-ere-hex

4.15.3.2 Handling Unknown Predicates
....................................

Users can write a handler for the specific exception occurring when an
undefined predicate is called by defining clauses for the hook
predicate `user:unknown_predicate_handler/3'.  This can be thought of as
a "global" exception handler for this particular exception, because
unlike `catch/3', its effect is not limited to a particular goal.
Furthermore, the exception is handled at the point where the undefined
predicate is called.

   The handler can be written to apply to all unknown predicates, or to
a class of them.  The reference page contains an example of
constraining the handler to certain predicates.

   If `call(MODULE:GOAL)' is the trapped call to the undefined
predicate, then the hook is called as:

`user:unknown_predicate_handler(+GOAL, +MODULE, -NEWGOAL)   *hook*'

   If this succeeds, then Prolog replaces the call to the undefined
predicate with the call to MODULE:NEWGOAL. Otherwise, the action taken
is governed by the `unknown' Prolog flag (*note ref-lps-flg::), the
allowed values of which are:

`trace'
     Causes calls to undefined predicates to be reported and the
     debugger to be entered at the earliest opportunity.  Not available
     in runtime systems.

`error   "ISO"'
     Causes calls to such predicates to raise an exception (the
     default).

`warning   "ISO"'
     Causes calls to such predicates to display a warning message and
     then fail.

`fail   "ISO"'
     Causes calls to such predicates to fail.

   Finally, this flag can be accessed by the built-in predicate:

`unknown(?OLDVALUE, ?NEWVALUE)   *development*'

   This unifies OLDVALUE with the current representation, sets the flag to
NEWVALUE, and prints a message about the new representation.  *Note
mpg-ref-unknown_predicate_handler::.


File: sicstus.info,  Node: ref-ere-err,  Next: ref-ere-exa,  Prev: ref-ere-hex,  Up: ref-ere

4.15.4 Error Classes
--------------------

* Menu:

* ref-ere-err-ins::                     Instantiation Errors
* ref-ere-err-uns::                     Uninstantiation Errors
* ref-ere-err-typ::                     Type Errors
* ref-ere-err-dom::                     Domain Errors
* ref-ere-err-eva::                     Evaluation Errors
* ref-ere-err-rep::                     Representation Errors
* ref-ere-err-exi::                     Existence Errors
* ref-ere-err-per::                     Permission Errors
* ref-ere-err-con::                     Context Errors
* ref-ere-err-cns::                     Consistency Errors
* ref-ere-err-syn::                     Syntax Errors
* ref-ere-err-res::                     Resource Errors
* ref-ere-err-sys::                     System Errors

   Exceptions thrown by the Prolog system are called errors.

   Error terms have the form:

     error(ISO_ERROR, SICSTUS_ERROR)

where the principal functor of ISO_ERROR (resp.  SICSTUS_ERROR)
indicates the error class (*note ref-ere-err::).  The classification
always coincides.

   *Please note:* Don't throw error terms except when you re-throw a
previously caught error term. They correspond to the exceptions thrown
by the built-in predicates. Throwing such forged error terms can lead
to unexpected results.

   *Note lib-types:: for an alternative interface to throwing error
exceptions, which tries to include line number information for
source-linked debugging.

   Error messages like the one shown earlier are printed using the
built-in predicate `print_message/2'.  One of the arguments to
`print_message/2' is the exception term.  `print_message/2' can be
customized, as described in *note ref-msg::.

   The set of error classes used by the system has been kept small:

Instantiation Error   "ISO"
     An input argument is insufficiently instantiated.

Uninstantiation Error   "ISO"
     An input argument is too instantiated.

Type Error   "ISO"
     An input argument is of the wrong type.

Domain Error   "ISO"
     An input argument is illegal but of the right type.

Evaluation Error   "ISO"
     An incorrect arithmetic expression was evaluated.

Representation Error   "ISO"
     A computed representation cannot be represented.

Existence Error   "ISO"
     Something does not exist.

Permission Error   "ISO"
     Specified operation is not permitted.

Context Error
     Specified operation is not permitted in this context.

Consistency Error
     Two otherwise correct values are inconsistent with each other.

Syntax Error   "ISO"
     Error in reading a term.

Resource Error   "ISO"
     Some resource limit has been exceeded.

System Error   "ISO"
     An error detected by the operating system.


   The format of the exception thrown by the built-in predicates is:

     error(ISO_ERROR, SICSTUS_ERROR)

where ISO_ERROR is the error term prescribed by the ISO Prolog
standard, while SICSTUS_ERROR is the part defined by the standard to be
implementation defined. This so called SICStus error term has the same
principal functor as ISO_ERROR but more arguments containing additional
information, such as the goal and the argument number causing the
error.  Arguments are numbered from 1 upwards.  An argument number
given as zero means that an unspecific argument caused the error.

   The list below itemizes the error terms, showing the ISO_ERROR and
SICSTUS_ERROR form of each one, in that order.  The SICStus and ISO
error terms always belong to the same error class, but note that the
Context and Consistency error classes are extensions to the ISO Prolog
standard.

   The goal part of the error term may optionally have the form
`$@(CALLABLE,PC)' where PC is an internal encoding of the line of code
containing the culprit goal or one of its ancestors.  To decompose an
annotated goal AGOAL into a GOAL proper and a SOURCEINFO descriptor
term, indicating the source position of the goal, use:

     ?- goal_source_info(AGOAL, GOAL, SOURCEINFO).

   The reference page gives details about the SOURCEINFO format.  *Note
mpg-ref-goal_source_info::.

`instantiation_error   "ISO"'
`instantiation_error(GOAL,ARGNO)'
     GOAL was called with insufficiently instantiated arguments.

`uninstantiation_error(CULPRIT)   "ISO"'
`uninstantiation_error(GOAL,ARGNO,CULPRIT)'
     GOAL was called with too instantiated arguments, expecting CULPRIT
     to be uninstantiated.

`type_error(TYPENAME,CULPRIT)   "ISO"'
`type_error(GOAL,ARGNO,TYPENAME,CULPRIT)'
     GOAL was called with the wrong type of argument(s).  TYPENAME is
     the expected type and CULPRIT what was actually found.

`domain_error(DOMAIN,CULPRIT)   "ISO"'
`domain_error(GOAL,ARGNO,DOMAIN,CULPRIT)'
     GOAL was called with argument(s) of the right type but with
     illegal representation(s).  DOMAIN is the expected domain and CULPRIT what
     was actually found.

`existence_error(OBJECTTYPE,CULPRIT)   "ISO"'
`existence_error(GOAL,ARGNO,OBJECTTYPE,CULPRIT,RESERVED)'
     Something does not exist as indicated by the arguments.  *Note
     ref-ere-err-exi:: for ways of controlling this behavior.

`permission_error(OPERATION,OBJECTTYPE,CULPRIT)   "ISO"'
`permission_error(GOAL,OPERATION,OBJECTTYPE,CULPRIT,RESERVED)'
     The OPERATION is not permitted on CULPRIT of the OBJECTTYPE.
     *Note ref-ere-err-per:: for ways of controlling this behavior.

`context_error(CONTEXTTYPE,COMMANDTYPE)'
`context_error(GOAL,CONTEXTTYPE,COMMANDTYPE)'
     The COMMANDTYPE is not permitted in CONTEXTTYPE.

`syntax_error(MESSAGE)   "ISO"'
`syntax_error(GOAL,POSITION,MESSAGE,TOKENS,AFTERERROR)'
     A syntax error was found when reading a term with `read/[1,2]' or
     assembling a number from its characters with `number_chars/2' or
     `number_codes/2'. *Note ref-ere-err-syn:: for ways of controlling
     this behavior.

`evaluation_error(ERRORTYPE,CULPRIT)   "ISO"'
`evaluation_error(GOAL,ARGNO,ERRORTYPE,CULPRIT)'
     An incorrect arithmetic expression was evaluated.

`representation_error(ERRORTYPE)   "ISO"'
`representation_error(GOAL,ARGNO,ERRORTYPE)'
     A representation error occurs when the program tries to compute
     some well-defined representation that cannot be represented, such as a
     compound term with arity > 255.

`consistency_error(CULPRIT1,CULPRIT2,MESSAGE)'
`consistency_error(GOAL,CULPRIT1,CULPRIT2,MESSAGE)'
     A consistency error occurs when two otherwise valid values or
     operations have been specified that are inconsistent with each
     other.

`resource_error(RESOURCETYPE)   "ISO"'
`resource_error(GOAL,RESOURCETYPE)'
     A resource error occurs when SICStus Prolog has insufficient
     resources to complete execution.  The only representation for RESOURCETYPE
     that is currently in use is `memory'.

`system_error   "ISO"'
`system_error(MESSAGE)'
     An error occurred while dealing with the operating system.

   Most exception terms include a copy of the GOAL that threw the
exception.

   In general, built-in predicates that cause side-effects, such as the
opening of a stream or asserting a clause into the Prolog database,
attempt to do all error checking before the side-effect is performed.
Unless otherwise indicated in the documentation for a particular
predicate or error class, it should be assumed that goals that throw
exceptions have not performed any side-effect.


File: sicstus.info,  Node: ref-ere-err-ins,  Next: ref-ere-err-uns,  Up: ref-ere-err

4.15.4.1 Instantiation Errors
.............................

An instantiation error occurs when a predicate or command is called with
one of its input arguments insufficiently instantiated.

   The SICSTUS_ERROR term associated with an instantiation error is
     instantiation_error(GOAL, ARGNO)

where ARGNO is a non-negative integer indicating which argument caused
the problem.  ARGNO=0 means that the problem could not be localized to
a single argument.

   Note that the ARGNOth argument of GOAL might well be a non-variable:
the error is _in_ that argument.  For example, the goal
     X is Y+1

where Y is uninstantiated throws the exception
     error(instantiation_error,
           instantiation_error(_A is _B+1,2))

because the second argument to `is/2' contains a variable.


File: sicstus.info,  Node: ref-ere-err-uns,  Next: ref-ere-err-typ,  Prev: ref-ere-err-ins,  Up: ref-ere-err

4.15.4.2 Uninstantiation Errors
...............................

An uninstantiation error occurs when a predicate or command is called
with one of its input arguments instantiated when an unbound variable
was expected.

   The SICSTUS_ERROR term associated with an instantiation error is
     uninstantiation_error(GOAL,ARGNO,CULPRIT)

   For example, the goal

     open(f, write, bar)

throws the exception
     error(uninstantiation_error(bar),
           uninstantiation_error(open(f,write,bar),3,bar))

because the third argument was not a variable.


File: sicstus.info,  Node: ref-ere-err-typ,  Next: ref-ere-err-dom,  Prev: ref-ere-err-uns,  Up: ref-ere-err

4.15.4.3 Type Errors
....................

A type error occurs when an input argument is of the wrong "type".  In
general, a "type" is taken to be a class of terms for which there
exists a unary "type test predicate".  Some types are built-in, such as
`atom/1' and `integer/1'.

   The type of a term is the sort of thing you can tell just by looking
at it, without checking to see how _big_ it is.  So "integer" is a
type, but "non-negative integer" is not, and "atom" is a type, but
"atom with 5 letters in its name" and "atom starting with `x'" are not.

   The point of a type error is that you have _obviously_ passed the
wrong sort of argument to a command; perhaps you have switched two
arguments, or perhaps you have called the wrong predicate, but it isn't
a subtle matter of being off by one.

   Most built-in predicates check all their input arguments for type
errors.

   The SICSTUS_ERROR term associated with a type error is
     type_error(GOAL, ARGNO, TYPENAME, CULPRIT)

ARGNO
     CULPRIT occurs somewhere in the ARGNOth argument of GOAL.

TYPENAME
     says what sort of term was expected; it should be the name of a
     unary predicate that is true of whatever terms would not provoke a
     type error.

CULPRIT
     is the actual term being complained about: TYPENAME(CULPRIT)
     should be false.

   For example:
     | ?- catch((write(3),1), Error, true).
     Error = error(type_error(callable,(write(3),1)),
                   type_error(user:(write(3),1),0,callable,(write(3),1)))


File: sicstus.info,  Node: ref-ere-err-dom,  Next: ref-ere-err-eva,  Prev: ref-ere-err-typ,  Up: ref-ere-err

4.15.4.4 Domain Errors
......................

A domain error occurs when an input argument is of the right type but
there is something wrong with its representation.  For example, the second
argument to `open/[3,4]' is supposed to be an atom that represents a
valid mode for opening a file, such as `read' or `write'.  If a number
or a compound term is given instead, that is a type error.  If an atom
is given that is not a valid mode, that is a domain error.

   The main reason that we distinguish between type errors and domain
errors is that they usually represent different sorts of mistakes in
your program.  A type error usually indicates that you have passed the
wrong argument to a command, whereas a domain error usually indicates
that you passed the argument you meant to check, but you hadn't checked
it enough.

   The SICSTUS_ERROR term associated with a domain error is
     domain_error(GOAL, ARGNO, DOMAINNAME, CULPRIT)

   The arguments correspond to those of the SICSTUS_ERROR term for a
type error, except that DOMAINNAME is not in general the name of a unary
predicate: it needn't even be an atom.  For example, if some command
requires an argument to be an integer in the range 1..99, it might use
`between(1,99)' as the DOMAINNAME.  With respect to the `date_plus'
example under Type Errors, if the month had been given as 13 it would
have passed the type test but would throw a domain error.

   For example, the goal
     open(somefile,rread,S)

throws the exception
     error(domain_error(io_mode,rread),
           domain_error(open(somefile,rread,_A),2,io_mode,rread))

   The MESSAGE argument is used to provide extra information about the
problem.


File: sicstus.info,  Node: ref-ere-err-eva,  Next: ref-ere-err-rep,  Prev: ref-ere-err-dom,  Up: ref-ere-err

4.15.4.5 Evaluation Errors
..........................

An evaluation error occurs when an incorrect arithmetic expression was
evaluated.  Floating-point overflow is another evaluation error.  The
SICSTUS_ERROR term associated with an evaluation error is
     evaluation_error(GOAL, ARGNO, TYPENAME, CULPRIT)

   This has the same arguments as a type error.


File: sicstus.info,  Node: ref-ere-err-rep,  Next: ref-ere-err-exi,  Prev: ref-ere-err-eva,  Up: ref-ere-err

4.15.4.6 Representation Errors
..............................

A representation error occurs when your program calls for the
computation of some well-defined representation that cannot be represented.

   Most representation errors are some sort of overflow.  For example,
creating a compound term with arity greater than 255 results in a
representation error.

   The SICSTUS_ERROR term for a representation error is
     representation_error(GOAL, ARGNO, MESSAGE)

ARGNO
     identifies the argument of the goal that cannot be constructed.

MESSAGE
     further classifies the problem.  A message of `0' or `''' provides
     no further information.


File: sicstus.info,  Node: ref-ere-err-exi,  Next: ref-ere-err-per,  Prev: ref-ere-err-rep,  Up: ref-ere-err

4.15.4.7 Existence Errors
.........................

An existence error occurs when a predicate attempts to access something
that does not exist.  For example, trying to compile a file that does
not exist, erasing a database reference that has already been erased.

   The SICSTUS_ERROR term associated with an existence error is
     existence_error(GOAL, ARGNO, OBJECTTYPE, CULPRIT, MESSAGE)

ARGNO
     index of argument of GOAL where CULPRIT appears

OBJECTTYPE
     expected type of non-existent object

CULPRIT
     name for the non-existent object

MESSAGE
     the constant `0' or `''', or some additional information provided
     by the operating system or other support system indicating why
     CULPRIT is thought not to exist.

   For example, `see('../brother/niece')' might throw the exception
     error(existence_error(source_sink,'../brother/niece'),
           existence_error(see('../brother/niece'),1,file,'../brother/niece',0))

   An existence error does not necessarily cause an exception to be
thrown.  For I/O predicates, the behavior can be controlled with the
`fileerrors' Prolog flag (*note ref-lps-flg::) or with the
`fileerrors/1' alias `file_errors/1' option to `absolute_file_name/3'.
The following values are possible:

`on (fileerrors flag representation)'
`error (absolute_file_name/3 fileerrors representation)'
     Throw an exception if a given file can't be opened.  The default.

`off (fileerrors flag representation)'
`fail (absolute_file_name/3 fileerrors representation)'
     Merely fail if a given file can't be opened.


File: sicstus.info,  Node: ref-ere-err-per,  Next: ref-ere-err-con,  Prev: ref-ere-err-exi,  Up: ref-ere-err

4.15.4.8 Permission Errors
..........................

A permission error occurs when an operation is attempted that is among
the kinds of operation that the system is in general capable of
performing, and among the kinds that you are in general allowed to
request, but this particular time it isn't permitted.  Usually, the
reason for a permission error is that the "owner" of one of the objects
has requested that the object be protected.

   For example, an attempts to assert or retract clauses for a
predicate that has not been declared `:-dynamic' is rejected with a
permission error.

   File system protection is another major source of such errors.

   The SICSTUS_ERROR term associated with a permission error is
     permission_error(GOAL, OPERATION, OBJECTTYPE, CULPRIT, MESSAGE)

OPERATION
     operation attempted; OPERATION exists but is not permitted with
     CULPRIT.

OBJECTTYPE
     CULPRIT's type.

CULPRIT
     name of protected object.

MESSAGE
     provides such operating-system-specific additional information as
     may be available.  A message of `0' or `''' provides no further
     information.

   A permission error does not necessarily cause an exception to be
thrown.  For I/O predicates, the behavior can be controlled with the
`fileerrors' Prolog flag (*note ref-lps-flg::) or with the
`fileerrors/1' alias `file_errors/1' option to `absolute_file_name/3',
exactly as for existence errors.


File: sicstus.info,  Node: ref-ere-err-con,  Next: ref-ere-err-cns,  Prev: ref-ere-err-per,  Up: ref-ere-err

4.15.4.9 Context Errors
.......................

A context error occurs when a goal or declaration appears in the wrong
place.  There may or may not be anything wrong with the goal or
declaration as such; the point is that it is out of place.  Calling
`multifile/1' as a goal is a context error, as is having `:-module/2'
anywhere but as the first term in a source file.  This error classe is
an extension to the ISO Prolog standard.

   The SICSTUS_ERROR term associated with a context error is
     context_error(GOAL, CONTEXTTYPE, COMMANDTYPE)

CONTEXTTYPE
     the context in which the command was attempted.

COMMANDTYPE
     the type of command that was attempted.



File: sicstus.info,  Node: ref-ere-err-cns,  Next: ref-ere-err-syn,  Prev: ref-ere-err-con,  Up: ref-ere-err

4.15.4.10 Consistency Errors
............................

A consistency error occurs when two otherwise valid values or operations
have been specified that are inconsistent with each other.  For example,
if two modules each import the same predicate from the other, that is a
consistency error.  This error classe is an extension to the ISO Prolog
standard.

   The SICSTUS_ERROR term associated with a consistency error is
     consistency_error(GOAL, CULPRIT1, CULPRIT2, MESSAGE)

CULPRIT1
     One of the conflicting values/operations.

CULPRIT2
     The other conflicting representation/operation.

MESSAGE
     Additional information, or `0', or `'''.


File: sicstus.info,  Node: ref-ere-err-syn,  Next: ref-ere-err-res,  Prev: ref-ere-err-cns,  Up: ref-ere-err

4.15.4.11 Syntax Errors
.......................

A syntax error occurs when data are read from some external source but
have an improper format or cannot be processed for some other reason.
This category mainly applies to `read/1' and its variants.

   The SICSTUS_ERROR term associated with a syntax error is
     syntax_error(GOAL, POSITION, MESSAGE, LEFT, RIGHT)

where GOAL is the goal in question, POSITION identifies the position in
the stream where reading started, and MESSAGE describes the error.
Left and right are lists of tokens before and after the error,
respectively.

   Note that the POSITION is where reading started, not where the error
_is_.

   `read/1' does two things.  First, it reads a sequence of characters
from the current input stream up to and including a clause terminator,
or the end of file marker, whichever comes first.  Then it attempts to
parse the sequence of characters as a Prolog term.  If the parse is
unsuccessful, a syntax error occurs.  Thus, in the case of syntax
errors, `read/1' disobeys the normal rule that predicates should detect
and report errors before they perform any side-effects, because the
side-effect of reading the characters has been done.

   A syntax error does not necessarily cause an exception to be thrown.
For I/O predicates, but not for `number_chars/2' and `number_codes/2',
The behavior can be controlled via the `syntax_errors' Prolog flag
(*note ref-lps-flg::), or via the `syntax_errors/1' option to
`read_term/[2,3]'.  The following values are possible:

`quiet'
     When a syntax error is detected, nothing is printed, and `read/1'
     just quietly fails.

`dec10'
     This provides compatibility with other Prologs:  when a syntax
     error is detected, a syntax error message is issued with
     `print_message/2', and the `read' is repeated.  This is the
     default.

`fail'
     This provides compatibility with other Prologs.  When a syntax
     error is detected, a syntax error message is printed on
     `user_error', and the `read' then fails.

`error'
     When a syntax error is detected, an exception is thrown.


File: sicstus.info,  Node: ref-ere-err-res,  Next: ref-ere-err-sys,  Prev: ref-ere-err-syn,  Up: ref-ere-err

4.15.4.12 Resource Errors
.........................

A resource error occurs when some resource runs out.  For example, you
can run out of virtual memory, or you can exceed the operating system
limit on the number of simultaneously open files.

   Often a resource error arises because of a programming mistake:  for
example, you may exceed the maximum number of open files because your
program doesn't close files when it has finished with them.  Or, you
may run out of virtual memory because you have a non-terminating
recursion in your program.

   The SICSTUS_ERROR term for a resource error is
     resource_error(GOAL, RESOURCE)

GOAL
     A copy of the goal, or `0' if no goal was responsible; for example
     there is no particular goal to blame if you run out of virtual
     memory.

RESOURCE
     identifies the resource that was exhausted.  The only representation
     currently in use is `memory'.



File: sicstus.info,  Node: ref-ere-err-sys,  Prev: ref-ere-err-res,  Up: ref-ere-err

4.15.4.13 System Errors
.......................

System errors are problems that the operating system notices (or
causes).  Note that many of the exception indications returned by the
operating system (such as "file does not exist") are mapped to Prolog
exceptions; it is only really unexpected things that show up as system
errors.

   The SICSTUS_ERROR term for a system error is
     system_error(MESSAGE)

where MESSAGE is not further specified.


File: sicstus.info,  Node: ref-ere-exa,  Next: ref-ere-leg,  Prev: ref-ere-err,  Up: ref-ere

4.15.5 An Example
-----------------

Suppose you want a routine that is to prompt for a file name and open
the file if it can; otherwise it is to prompt the user for a replacement
name.  If the user enters an empty name, it is to fail.  Otherwise, it
is to keep asking the user for a name until something works, and then it
is to return the stream that was opened.  There is no need to return the
file name that was finally used.  We can get it from the stream.  Code:

     retry_open_output(Stream) :-
         ask_query(filename, format('Type name of file to open\n',[]), -, FileName),
         FileName \== '',
         catch(open(FileName, write, Stream),
               Error,
               (   Error = error(_,Excp),
                   file_error(Excp)
               ->  print_message(warning, Excp),
                   retry_open_output(Stream)
               ;   throw(Error)
               )).

     file_error(existence_error(open(_,_,_), 1, _, _, _)).
     file_error(permission_error(open(_,_,_), _, _, _, _)).

     :- multifile 'SU_messages':query_class/5.
     'SU_messages':query_class(filename, '> ', line, atom_codes, help_query) :- !.

     :- multifile 'SU_messages':query_map/4.
     'SU_messages':query_map(atom_codes, Codes, success, Atom) :- !,
             (Codes==end_of_file -> Atom = '' ; atom_codes(Atom, Codes)).

   Sample session:

     | ?- retry_open_output(S).
     Type name of file to open
     > nodir/nofile
     * Existence error in argument 1 of open/3
     * file '/tmp/nodir/nofile' does not exist
     * goal:  open('nodir/nofile',write,_701)
     Type name of file to open
     > newfile
     S = '$stream'(3491752)

   What this example does _not_ catch is as interesting as what it
does.  All errors except existence and permission errors are re-thrown,
as they represent errors in the program.  The example also shows that
you generally don't want to catch _all_ exceptions that a particular
goal might throw.


File: sicstus.info,  Node: ref-ere-leg,  Next: ref-ere-int,  Prev: ref-ere-exa,  Up: ref-ere

4.15.6 Legacy Predicates
------------------------

Exception handling for Prolog was originally introduced in Quintus
Prolog, and later inherited by SICStus Prolog, with an API that predated
the ISO standard.  This API is still supported but should be regarded as
legacy, and consists of the two predicates `raise_exception/1' and
`on_exception/3': 

`on_exception(?TEMPLATE, :PROTECTEDGOAL, :HANDLER)'
     Equivalent to `catch(:PROTECTEDGOAL, ?TEMPLATE, :HANDLER)'.  Any
     exception term matching TEMPLATE is caught and handled.  *Note
     mpg-ref-on_exception::.

`raise_exception(+EXCEPTIONTERM)'
     If EXCEPTIONTERM matches one of the SICStus error terms listed in
     *note ref-ere-err::, then the corresponding error term
     `error(ISO_ERROR, SICSTUS_ERROR)' is constructed and thrown.
     Otherwise, EXCEPTIONTERM is thrown as is.

   Prior to release 4.3, `throw/1' and `raise_exception/3' used to be
equivalent and throw their argument as is, whereas `catch/3' and
`on_exception/3' both used to attempt to recognize and expand SICStus
error terms into `error/2' terms.  Unless a forged SICStus error term
is thrown by `throw/1', the net behavior is unchanged.  *Note
mpg-ref-raise_exception::.


File: sicstus.info,  Node: ref-ere-int,  Next: ref-ere-sum,  Prev: ref-ere-leg,  Up: ref-ere

4.15.7 Interrupting Execution
-----------------------------

There exist more drastic means of interrupting the normal control flow.
To invoke a recursive top-level, use:

     ?- break.
*Note mpg-ref-break::.

   To exit from Prolog, use:

     ?- halt.

   To exit from Prolog with return code CODE, use:

     ?- halt(CODE).
*Note mpg-ref-halt::.

   To abort the execution of the current query and return to the
top-level, use:

     ?- abort.
*Note mpg-ref-abort::.

     *Please note:* `halt/[0,1]' and `abort/0' are implemented by
     throwing a reserved exception, which has a handler at the
     top-level of development systems and executables built with the
     `spld' tool. Thus they give the opportunity for cleanup goals (see
     `call_cleanup/2') to run.



File: sicstus.info,  Node: ref-ere-sum,  Prev: ref-ere-int,  Up: ref-ere

4.15.8 Summary of Predicates
----------------------------

`abort'
     abort execution of the program; return to current break level

`break'
     start a new break-level to interpret commands from the user

`catch(:P,?E,:H)   "ISO"'
     specify a handler H for any exception E arising in the execution
     of the goal P

`user:error_exception(+EXCEPTION)   *hook,development*'
     EXCEPTION is an exception that traps to the debugger if it is
     switched on.

`goal_source_info(+AGOAL, -GOAL, -SOURCEINFO)'
     Decomposes the annotated goal AGOAL into a GOAL proper and the
     SOURCEINFO descriptor term, indicating the source position of the
     goal.

`halt   "ISO"'
`halt(C)   "ISO"'
     exit from Prolog with exit code C

`on_exception(?E,:P,:H)'
     specify a handler H for any exception E arising in the execution
     of the goal P

`raise_exception(+E)'
     raise exception E

`throw(+E)   "ISO"'
     raise exception E

`unknown(?OLDVALUE, ?NEWVALUE)   *development*'
     access the `unknown' Prolog flag and print a message

`user:unknown_predicate_handler(+GOAL, +MODULE, -NEWGOAL)   *hook*'
     tell Prolog to call `MODULE:NEWGOAL' if `MODULE:GOAL' is undefined



File: sicstus.info,  Node: ref-msg,  Next: ref-oth,  Prev: ref-ere,  Up: Prolog Intro

4.16 Messages and Queries
=========================

This section describes the two main aspects of user interaction,
displaying messages and querying the user.  We will deal with these two
issues in turn.

* Menu:

* Message Processing:: Message Processing
* Message Handling Predicates:: Message Handling Predicates
* Query Processing:: Query Processing
* Query Handling Predicates:: Query Handling Predicates
* Message Summary:: Predicate Summary


File: sicstus.info,  Node: Message Processing,  Next: Message Handling Predicates,  Up: ref-msg

4.16.1 Message Processing
-------------------------

Every message issued by the Prolog system is displayed using a single
predicate:
     `print_message(SEVERITY, MESSAGE)'

   MESSAGE is a term that encodes the message to be printed.  The
format of message terms is subject to change, but can be inspected in
the file `library('SU_messages')' of the SICStus Prolog distribution.

   The atom SEVERITY specifies the type (or importance) of the message.
The following table lists the severities known to the SICStus Prolog
system, together with the line prefixes used in displaying messages of
the given severity:

`error'           `'! ''   for error messages
`warning'         `'* ''   for warning messages
`informational'   `'% ''   for informational messages
`help'            `'''     for help messages
`query'           `'''     for query texts (*note Query Processing::)
`silent'          `'''     a special kind of message, which normally
                           does not produce any output, but can be
                           intercepted by hooks

   `print_message/2' is a built-in predicate, so that users can invoke
it to have their own messages processed in the same way as the system
messages.

   The processing and printing of the messages is highly customizable.
For example, this allows the user to change the language of the
messages, or to make them appear in dialog windows rather than on the
terminal.

* Menu:

* Message Phases:: Phases of Message Processing
* Message Generation Phase:: Message Generation Phase
* Message Printing Phase:: Message Printing Phase


File: sicstus.info,  Node: Message Phases,  Next: Message Generation Phase,  Up: Message Processing

4.16.1.1 Phases of Message Processing
.....................................

Messages are processed in two major phases.  The user can influence the
behavior of each phase using appropriate hooks, described later.

   The first phase is called the _message generation phase_: it
determines the text of the message from the input (the abstract message
term).  No printing is done here.  In this phase the user can change
the phrasing or the language of the messages.

   The result of the first phase is created in the form of a
"format-command list".  This is a list whose elements are
"format-commands", or the atom `nl' denoting the end of a line.  A
format-command describes a piece of text not extending over a line
boundary and it can be one of the following:

`FORMATSTRING-ARGS'
`format(FORMATSTRING, ARGS)'
     This indicates that the message text should appear as if printed by
          format(FORMATSTRING, ARGS).

`write_term(TERM, OPTIONS)'
     This indicates that the message text should appear as if printed by
          write_term(TERM, OPTIONS).

`write_term(TERM)'
     Equivalent to `write_term(TERM, OPTIONS)' where OPTIONS is the
     actual representation of the Prolog flag `toplevel_print_options'.

   As an example, let us see what happens in case of the toplevel call
`_ =:= 3'.  An instantiation error is raised by the Prolog system,
which is caught, and the abstract message term
`error(instantiation_error,instantiation_error(_=:=3,1))' is
generated--the first argument is the goal, and the second argument is
the position of the uninstantiated variable within the goal.  In the
first phase of message processing this is converted to the following
format-command list:
     ['Instantiation error'-[],' in argument ~d of ~q'-[1,=:= /2],nl,
      'goal:  '-[],write_term(_=:=3),nl]

   A minor transformation, so-called _line splitting_ is performed on
the message text before it is handed over to the second phase.  The
format-command list is broken up along the `nl' atoms into a list of
lines, where each line is a list of format-commands.  We will use the
term format-command lines to refer to the result of this transformation.

   In the example above, the result of this conversion is the following:
     [['Instantiation error'-[],' in argument ~d of ~q'-[1,=:= /2]],
      ['goal:  '-[],write_term(_=:=3)]]
The above format-command lines term is the input of the second phase of
message processing.

   The second phase is called the _message printing phase_, this is
where the message is actually displayed.  The severity of the message is
used here to prefix each line of the message with some characters
indicating the type of the message, as listed above.

   The user can change the exact method of printing (e.g. redirection of
messages to a stream, a window, or using different prefixes, etc.)
through appropriate hooks.

   In our example the following lines are printed by the second phase
of processing:
     ! Instantiation error in argument 1 of =:= /2
     ! goal:  _=:=3

   The user can override the default message processing mechanism in the
following two ways:
   * A global method is to define the hook predicate
     `portray_message/2', which is the first thing called by message
     processing.  If this hook exists and succeeds, it overrides all
     other processing--nothing further is done by `print_message/2'.

   * If a finer method of influencing the behavior of message
     processing is needed, there are several further hooks provided,
     which affect only one phase of the process.  These are described
     in the following paragraphs.


File: sicstus.info,  Node: Message Generation Phase,  Next: Message Printing Phase,  Prev: Message Phases,  Up: Message Processing

4.16.1.2 Message Generation Phase
.................................

The default message generation predicates are located in the
`library('SU_messages')' file, in the `'SU_messages'' module, together
with other message and query related predicates.  This is advantageous
when these predicates have to be changed as a whole (for example when
translating all messages to another language), because this can be done
simply by replacing the file `library('SU_messages')' by a new one.

   In the message generation phase three alternative methods are tried:

   * First the hook predicate `generate_message_hook/3' is executed, if
     it succeeds, it is assumed to deliver the output of this phase.

   * Next the default message generation is invoked via
     `'SU_messages':generate_message/3'.

   * In the case that neither of the above methods succeed, a built-in
     fall-back message generation method is used.

   The hook predicate `generate_message_hook/3' can be used to override
the default behavior, or to handle new messages defined by the
programmer that don't fit the default message generation schemes.  The
latter can also be achieved by adding new clauses to the extendible
`'SU_messages':generate_message/3' predicate.

   If both the hook and the default method refuses to handle the
message, the following simple format-command list is generated from the
abstract message term MESSAGE:
     ['~q'-[MESSAGE],nl]
This will result in displaying the abstract message term itself, as if
printed by `writeq/1'.

   For messages of the severity `silent' the message generation phase
is skipped, and the `[]' format-command list is returned as the output.


File: sicstus.info,  Node: Message Printing Phase,  Prev: Message Generation Phase,  Up: Message Processing

4.16.1.3 Message Printing Phase
...............................

By default this phase is handled by the built-in predicate
`print_message_lines/3'.  Each line of the message is prefixed with a
string depending on the severity, and is printed to `user_error'.  The
`query' severity is special--no newline is printed after the last line
of the message.

   This behavior can be overridden by defining the hook predicate
`message_hook/3', which is called with the severity of the message, the
abstract message term and its translation to format-command lines.  It
can be used to make smaller changes, for example by calling
`print_message_lines/3' with a stream argument other than `user_error',
or to implement a totally different display method such as using dialog
windows for messages.

   For messages of the severity `silent' the message printing phase
consists of calling the hook predicate `message_hook/3' only.  Even if
the hook fails, no printing is done.


File: sicstus.info,  Node: Message Handling Predicates,  Next: Query Processing,  Prev: Message Processing,  Up: ref-msg

4.16.2 Message Handling Predicates
----------------------------------

`print_message(+SEVERITY, +MESSAGE)   *hookable*'
     Portrays or else writes MESSAGE of a given SEVERITY on the
     standard error stream.  *Note mpg-ref-print_message::.

`portray_message(+SEVERITY, +MESSAGE)   *hook*'
`user:portray_message(+SEVERITY, +MESSAGE)'
     Tells `print_message/2' what to do.

`generate_message_hook(+MESSAGE, -L0, -L)   *hook*'
`user:generate_message_hook(+MESSAGE, -L0, -L)'
     A way for the user to override the call to
     `'SU_messages':generate_message/3' in the message generation phase
     in `print_message/2'.

`'SU_messages':generate_message(+MESSAGE, -L0, -L)   *extendible*'
     Predefined message generation rules.

`message_hook(+SEVERITY, +MESSAGE, +LINES)   *hook*'
`user:message_hook(+SEVERITY, +MESSAGE, +LINES)'
     Overrides the call to `print_message_lines/3' in
     `print_message/2'.  A way for the user to intercept the abstract
     message term MESSAGE of type SEVERITY, whose translation is LINES,
     before it is actually printed.

`print_message_lines(+STREAM, +SEVERITY, +LINES)'
     Print the LINES to STREAM, preceding each line with a prefix
     defined by SEVERITY.

`goal_source_info(+AGOAL, -GOAL, -SOURCEINFO)'
     Decomposes the annotated goal AGOAL into a GOAL proper and the
     SOURCEINFO descriptor term, indicating the source position of the
     goal.


File: sicstus.info,  Node: Query Processing,  Next: Query Handling Predicates,  Prev: Message Handling Predicates,  Up: ref-msg

4.16.3 Query Processing
-----------------------

All user input in the Prolog system is handled by a single predicate:
     `ask_query(QUERYCLASS, QUERY, HELP, ANSWER)'

   QUERYCLASS, described below, specifies the form of the query
interaction.  QUERY is an abstract message term specifying the query
text, HELP is an abstract message term used as a help message in
certain cases, and ANSWER is the (abstract) result of the query.

   `ask_query/4' is a built-in predicate, so that users can invoke it
to have their own queries processed in the same way as the system
queries.

   The processing of queries is highly customizable.  For example, this
allows changing the language of the input expected from the user, or to
make queries appear in dialog windows rather than on the terminal.

* Menu:

* Query Classes:: Query Classes
* Query Phases:: Phases of Query Processing
* Query Hooks:: Hooks in Query Processing
* Default Input Methods:: Default Input Methods
* Default Map Methods:: Default Map Methods
* Default Query Classes:: Default Query Classes


File: sicstus.info,  Node: Query Classes,  Next: Query Phases,  Up: Query Processing

4.16.3.1 Query Classes
......................

Queries posed by the system can be classified according to the kind of
input they expect, the way the input is processed, etc.  Queries of the
same kind form a _query class_.

   For example, queries requiring a yes/no answer form a query class
with the following characteristics:

   * the text ` (y or n) ' is used as the prompt;

   * a single line of text is input;

   * if the first non-whitespace character of the input is `y' or `n'
     (possibly in capitals), the query returns the atom `yes' or `no',
     respectively, as the abstract answer;

   * otherwise a help message is displayed and the query is repeated.

   There are built-in query classes for reading in yes/no answers,
toplevel queries, debugger commands, etc.

   A query class is characterized by a ground Prolog term, which is
supplied as the first argument to the query processing predicate
`ask_query/4'.  The characteristics of a query class are normally
described by the extendible predicate
     'SU_messages':query_class(QUERYCLASS, PROMPT, INPUTMETHOD,
                               MAPMETHOD, FAILUREMODE).

   The arguments of the `query_class' predicate have the following
meaning:
PROMPT
     an atom to be used for prompting the user.

INPUTMETHOD
     a non-variable term, which specifies how to obtain input from the
     user.

     For example, a built-in input method is described by the atom
     `line'.  This requests that a line is input from the user, and the
     code-list is returned.  Another built-in input method is
     `term(OPTIONS)'; here, a Prolog term is read and returned.

     The input obtained using INPUTMETHOD is called "raw input", as it
     may undergo further processing.

     In addition to the built-in input methods, the user can define
     his/her own extensions.

MAPMETHOD
     a non-variable term, which specifies how to process the raw input
     to get the abstract answer to the query.

     For example, the built-in map method `char([yes-"yY", no-"nN"])'
     expects a code-list as raw input, and gives the answer term `yes'
     or `no' depending on the first non-whitespace character of the
     input.  For another example, the built-in map method `=' requests
     that the raw input itself be returned as the answer term--this is
     often used in conjunction with the input method `term(OPTIONS)'.

     In addition to the built-in map methods the user can define his/her
     own extensions.

FAILUREMODE
     This is used only when the mapping of raw input fails, and the
     query must be repeated.  This happens for example if the user typed
     a character other than `y' or `n' in case of the `yes_or_no' query
     class.  FAILUREMODE determines what to print before re-querying
     the user.  Possible values are:

    `help_query'
          print a help message, then print the text of the query again

    `help'
          only print the help message

    `query'
          only print the text of the query

    `none'
          don't print anything


File: sicstus.info,  Node: Query Phases,  Next: Query Hooks,  Prev: Query Classes,  Up: Query Processing

4.16.3.2 Phases of Query Processing
...................................

Query processing is done in several phases, described below.  We will
illustrate what is done in each phase through a simple example: the
question put to the user when the solution to the toplevel query `X is
1+1' is displayed, requesting a decision whether to find alternative
answers or not:
     | ?- X is 1+1.

     X = 2 ? no
     Please enter ";" for more choices; otherwise, <return>
      ? ;

   We focus on the query `X = 2 ? ' in the above script.

   The example query belongs to the class `next_solution', its text is
described by the message term `solutions([binding("X",2)])', and its
help text by the message term `bindings_help'.  Accordingly, such a
query is executed by calling:
     ask_query(next_solution,               /* QUERYCLASS */
               solutions([binding("X",2)]), /* QUERY */
               bindings_help,               /* HELP */
               ANSWER)

   In general, execution of `ask_query(QUERYCLASS, QUERY, HELP,
ANSWER)' consists of the following phases:

_Preparation phase_
     The abstract message terms QUERY (for the text of the query) and
     HELP (for the help message) are converted to format-command lines
     via the message generation and line splitting phases (*note
     Message Processing::).  Let us call the results of the two
     conversions QUERYLINES and HELPLINES, respectively.  The text of
     the query, QUERYLINES is printed immediately (via the message
     printing phase, using `query' severity).  HELPLINES may be printed
     later, and QUERYLINES printed again, in case of invalid user input.

     The characteristics of QUERYCLASS (described in the previous
     subsubsection) are retrieved to control the exact behavior of the
     further phases.

     In our example, the following parameters are sent in the
     preparation phase:

     QUERYLINES    =   `[[],['~s = '-["X"],write_term(2)]]'
     HELPLINES     =   
       `[['Please enter ";" for more choices; otherwise, <return>'-[]]]'
     PROMPT        =   `' ? ''
     INPUTMETHOD   =   `line'
     MAPMETHOD     =   `char([yes-";", no-[0'\n]])'
     FAILUREMODE   =   `help'

     QUERYLINES is displayed immediately, printing:
          X = 2

     (Note that the first element of QUERYLINES is `[]', therefore the
     output is preceded by a newline.  Also note that no newline is
     printed at the end of the  last line, because the `query' severity
     is used.)

     The subsequent phases will be called repeatedly until the mapping
     phase succeeds in generating an answer.

_Input phase_
     By default, the input phase is implemented by the extendible
     predicate
          'SU_messages':query_input(INPUTMETHOD, PROMPT, RAWINPUT).

     This phase uses the PROMPT and INPUTMETHOD characteristics of the
     query class.  INPUTMETHOD specifies the method of obtaining input
     from the user.  This method is executed, and the result (RAWINPUT)
     is passed on to the next phase.

     The use of PROMPT may depend on INPUTMETHOD.  For example, the
     built-in input method `line' prints the prompt unconditionally,
     while the input method `term(_)' passes PROMPT to `prompt/2'.

     In the example, first the ` ? ' prompt is displayed.  Next, because
     INPUTMETHOD is `line', a line of input is read, and the code-list
     is returned in RAWINPUT.  Supposing that the user typed `
     no<RET>', RAWINPUT becomes `" no"' = `[32,110,111]'.

_Mapping phase_
     By default, the mapping phase is implemented by the extendible
     predicate
          'SU_messages':query_map(MAPMETHOD, RAWINPUT,
                                  RESULT, ANSWER).

     This phase uses the MAPMETHOD parameter to control the method of
     converting the raw input to the abstract answer.

     In some cases RAWINPUT is returned as it is, but otherwise it has
     to be processed (parsed) to generate the answer.

     The conversion process may have two outcomes indicated in the
     RESULT returned:
        * success, in which case the query processing is completed with
          the ANSWER term returned;

        * failure, the query has to be repeated.

     In the latter case a message describing the cause of failure may be
     returned, to be printed before the query is repeated.

     In our example, the map method is `char([yes-";", no-[0'\n]])'.
     The mapping phase fails for the RAWINPUT passed on by the previous
     phase of the example, as the first non-whitespace character is `n',
     which does not match any of the given characters.

_Query restart phase_
     This phase is executed only if the mapping phase returned with
     failure.

     First, if a message was returned by the mapping, it is printed.
     Subsequently, if requested by the FAILUREMODE parameter, the help
     message HELPLINES and/or the text of the query QUERYLINES is
     printed.

     The query is then repeated--the input and mapping phase will be
     called again to try to get a valid answer.

     In the above example, the user typed an invalid character, so the
     mapping failed.  The `char(_)' mapping does not return any message
     in case of failure.  The FAILUREMODE of the query class is `help',
     so the help message HELPLINES is printed, but the query is not
     repeated:
          Please enter ";" for more choices; otherwise, <return>

     Having completed the query restart phase, the example script
     continues by re-entering the input phase: the prompt ` ? ' is
     printed, another line is read, and is processed by the mapping
     phase.  If the user types the character `;' this time, the mapping
     phase returns successfully and gives the abstract answer term
     `yes'.



File: sicstus.info,  Node: Query Hooks,  Next: Default Input Methods,  Prev: Query Phases,  Up: Query Processing

4.16.3.3 Hooks in Query Processing
..................................

As explained above, the major parts of query processing are implemented
in the `'SU_messages'' module in the file `library('SU_messages')'
through the following extendible predicates:
   * `'SU_messages':query_class(+QUERYCLASS, -PROMPT, -INPUTMETHOD,
     -MAPMETHOD, -FAILUREMODE)'

   * `'SU_messages':query_input(+INPUTMETHOD, +PROMPT, -RAWINPUT)'

   * `'SU_messages':query_map(+MAPMETHOD, +RAWINPUT, -RESULT, -ANSWER)'

   This is to enable the user to change the language used, the
processing done, etc., simply by changing or replacing the
`library('SU_messages')' file.

   To give more control to the user and to make the system more robust
(for example if the `'SU_messages'' module is corrupt) the so-called
_four step procedure_ is used in the above three cases--obtaining the
query class parameters, performing the query input and performing the
mapping.  The four steps of this procedure, described below, are tried
in the given order until the first one that succeeds.  Note that if an
exception is raised within the first three steps, a warning is printed
and the step is considered to have failed.

   * First, a hook predicate is tried.  The name of the hook is derived
     from the name of the appropriate predicate by appending `_hook' to
     it, e.g. `user:query_class_hook/5' in case of the query class.  If
     this hook predicate exists and succeeds, it is assumed to have
     done all necessary processing, and the following steps are skipped.

   * Second, the predicate in the `'SU_messages'' module is called
     (this is the default case, these are the predicates listed above).
     Normally this should succeed, unless the module is corrupt, or an
     unknown query-class/input-method/map-method is encountered.  These
     predicates are extendible, so new classes and methods can be added
     easily by the user.

   * Third, as a fall-back, a built-in minimal version of the
     predicates in the original `'SU_messages'' is called.  This is
     necessary because the `library('SU_messages')' file is modifiable
     by the user, therefore vital parts of the Prolog system (e.g. the
     toplevel query) could be damaged.

   * If all the above steps fail, nothing more can be done, and an
     exception is raised.


File: sicstus.info,  Node: Default Input Methods,  Next: Default Map Methods,  Prev: Query Hooks,  Up: Query Processing

4.16.3.4 Default Input Methods
..............................

The following INPUTMETHOD types are implemented by the default
`'SU_messages':query_input(INPUTMETHOD, PROMPT, RAWINPUT)' (and these
are the input methods known to the third, fall-back step):

`line'
     The PROMPT is printed, a line of input is read using `read_line/2'
     and the code-list is returned as RAWINPUT.

`term(OPTIONS)'
     PROMPT is set to be the prompt (cf. `prompt/2'), and a Prolog term
     is read by `read_term/2' using the given OPTIONS, and is returned
     as RAWINPUT.

`FINALTERM^term(TERM,OPTIONS)'
     A Prolog term is read as above, and is unified with TERM.
     FINALTERM is returned as RAWINPUT.  For example, the
     `T-Vs^term(T,[variable_names(Vs)])' input method will return the
     term read, paired with the list of variable names.


File: sicstus.info,  Node: Default Map Methods,  Next: Default Query Classes,  Prev: Default Input Methods,  Up: Query Processing

4.16.3.5 Default Map Methods
............................

The following MAPMETHOD types are known to
`'SU_messages':query_map(MAPMETHOD, RAWINPUT, RESULT, ANSWER)' and to
the built-in fall-back mapping:

`char(PAIRS)'
     In this map method RAWINPUT is assumed to be a code-list.

     PAIRS is a list of `NAME-ABBREVIATIONS' pairs, where NAME is a
     ground term, and ABBREVIATIONS is a code-list.  The first
     non-whitespace character of RAWINPUT is used for finding the
     corresponding name as the answer, by looking it up in the
     abbreviation lists.  If the character is found, RESULT is
     `success', and ANSWER is set to the NAME found; otherwise, RESULT
     is `failure'.

`='
     No conversion is done, ANSWER is equal to RAWINPUT and RESULT is
     `success'.

`debugger'
     This map method is used when reading a single line debugger
     command.  It parses the debugger command and returns the
     corresponding abstract command term.  If the parse is
     unsuccessful, the answer `unknown(Line,Warning)' is returned.
     This is to allow the user to extend the debugger command language
     via `debugger_command_hook/2', see *note Debug Commands::.

     The details of this mapping can be obtained from the
     `library('SU_messages')' file.

     Note that the fall-back version of this mapping is simplified, it
     only accepts parameterless debugger commands.


File: sicstus.info,  Node: Default Query Classes,  Prev: Default Map Methods,  Up: Query Processing

4.16.3.6 Default Query Classes
..............................

Most of the default query classes are designed to support some specific
interaction with the user within the Prolog development environment.
The full list of query classes can be inspected in the file
`library('SU_messages')'.  Here, we only describe the two classes
defined by `'SU_messages':query_class/5' that may be of general use:

QUERYCLASS    `yes_or_no'          `yes_no_proceed'
PROMPT        `' (y or n) ''       `' (y, n, p, s, a, or ?) ''
INPUTMETHOD   `line'               `line'
MAPMETHOD     `char([yes-"yY",     `char([yes-"yY", no-"nN", proceed-"pP",
              no-"nN"])'           suppress-"sS", abort-"aA"])'
FAILUREMODE   `help_query'         `help_query'


File: sicstus.info,  Node: Query Handling Predicates,  Next: Message Summary,  Prev: Query Processing,  Up: ref-msg

4.16.4 Query Handling Predicates
--------------------------------

`ask_query(+QUERYCLASS, +QUERY, +HELP, -ANSWER)   *hookable*'
     Prints the question QUERY, then reads and processes user input
     according to QUERYCLASS, and returns the result of the processing,
     the abstract answer term ANSWER.  The HELP message is printed in
     case of invalid input.  *Note mpg-ref-ask_query::.

`query_hook(+QUERYCLASS, +QUERY, +QUERYLINES, +HELP, +HELPLINES, -ANSWER)   *hook*'
`user:query_hook(+QUERYCLASS, +QUERY, +QUERYLINES, +HELP, +HELPLINES, -ANSWER)'
     Called by `ask_query/4' before processing the query.  If this
     predicate succeeds, it is assumed that the query has been
     processed and nothing further is done.

`query_class_hook(+QUERYCLASS, -PROMPT, -INPUTMETHOD, -MAPMETHOD, -FAILUREMODE)   *hook*'
`user:query_class_hook(+QUERYCLASS, -PROMPT, -INPUTMETHOD, -MAPMETHOD, -FAILUREMODE)'
     Provides the user with a method of overriding the call to
     `'SU_messages':query_class/5' in the preparation phase of query
     processing.  This way the default query class characteristics can
     be changed.

`'SU_messages':query_class(+QUERYCLASS, -PROMPT, -INPUTMETHOD, -MAPMETHOD, -FAILUREMODE)   *extendible*'
     Predefined query class characteristics table.

`'SU_messages':query_abbreviation(+QUERYCLASS, -PROMPT, -PAIRS)   *extendible*'
     Predefined query abbreviation table.

`query_input_hook(+INPUTMETHOD, +PROMPT, -RAWINPUT)   *hook*'
`user:query_input_hook(+INPUTMETHOD, +PROMPT, -RAWINPUT)'
     Provides the user with a method of overriding the call to
     `'SU_messages':query_input/3' in the input phase of query
     processing.  This way the implementation of the default input
     methods can be changed.

`'SU_messages':query_input(+INPUTMETHOD, +PROMPT, -RAWINPUT)   *extendible*'
     Predefined query input methods.

`query_map_hook(+MAPMETHOD, +RAWINPUT, -RESULT, -ANSWER)   *hook*'
`user:query_map_hook(+MAPMETHOD, +RAWINPUT, -RESULT, -ANSWER)'
     Provides the user with a method of overriding the call to
     `'SU_messages':query_map/4' in the mapping phase of query
     processing.  This way the implementation of the default map methods
     can be changed.

`'SU_messages':query_map(+MAPMETHOD, +RAWINPUT, -RESULT, -ANSWER)   *extendible*'
     Predefined query map methods.


File: sicstus.info,  Node: Message Summary,  Prev: Query Handling Predicates,  Up: ref-msg

4.16.5 Predicate Summary
------------------------

`ask_query(+QUERYCLASS, +QUERY, +HELP, -ANSWER)   *hookable*'
     Prints the question QUERY, then reads and processes user input
     according to QUERYCLASS, and returns the result of the processing,
     the abstract answer term ANSWER.  The HELP message is printed in
     case of invalid input.

`user:message_hook(+M,+S,+L)   *hook*'
     intercept the printing of a message

`'SU_messages':generate_message(+M,?SO,?S)   *extendible*'
     determines the mapping from a message term into a sequence of
     lines of text to be printed

`user:generate_message_hook(+M,?S0,?S)   *hook*'
     intercept message before it is given to
     `'SU_messages':generate_message/3'

`goal_source_info(+AGOAL, -GOAL, -SOURCEINFO)'
     Decomposes the annotated goal AGOAL into a GOAL proper and the
     SOURCEINFO descriptor term, indicating the source position of the
     goal.

`user:portray_message(+SEVERITY,+MESSAGE)   *hook*'
     Tells `print_message/2' what to do.

`print_message(+S,+M)   *hookable*'
     print a message M of severity S

`print_message_lines(+S,+P,+L)'
     print the message lines L to stream S with prefix P

`'SU_messages':query_abbreviation(+T,-P)   *extendible*'
     specifies one letter abbreviations for responses to queries from
     the Prolog system

`user:query_hook(+QUERYCLASS, +QUERY, +QUERYLINES, +HELP, +HELPLINES, -ANSWER)   *hook*'
     Called by `ask_query/4' before processing the query.  If this
     predicate succeeds, it is assumed that the query has been
     processed and nothing further is done.

`'SU_messages':query_class(+QUERYCLASS, -PROMPT, -INPUTMETHOD, -MAPMETHOD, -FAILUREMODE)   *extendible*'
     Access the parameters of a given QUERYCLASS.

`user:query_class_hook(+QUERYCLASS, -PROMPT, -INPUTMETHOD, -MAPMETHOD, -FAILUREMODE)   *hook*'
     Provides the user with a method of overriding the call to
     `'SU_messages':query_class/5' in the preparation phase of query
     processing.  This way the default query class characteristics can
     be changed.

`'SU_messages':query_input(+INPUTMETHOD, +PROMPT, -RAWINPUT)   *extendible*'
     Implements the input phase of query processing.

`user:query_input_hook(+INPUTMETHOD, +PROMPT, -RAWINPUT)   *hook*'
     Provides the user with a method of overriding the call to
     `'SU_messages':query_input/3' in the input phase of query
     processing.  This way the implementation of the default input
     methods can be changed.

`'SU_messages':query_map(+MAPMETHOD, +RAWINPUT, -RESULT, -ANSWER)   *extendible*'
     Implements the mapping phase of query processing.

`user:query_map_hook(+MAPMETHOD, +RAWINPUT, -RESULT, -ANSWER)   *hook*'
     Provides the user with a method of overriding the call to
     `'SU_messages':query_map/4' in the mapping phase of query
     processing.  This way the implementation of the default map methods
     can be changed.



File: sicstus.info,  Node: ref-oth,  Prev: ref-msg,  Up: Prolog Intro

4.17 Other Topics
=================

This section describes topics that don't fit elsewhere.

* Menu:

* System Properties and Environment Variables:: System Properties and Environment Variables


File: sicstus.info,  Node: System Properties and Environment Variables,  Up: ref-oth

4.17.1 System Properties and Environment Variables
--------------------------------------------------

SICStus Prolog stores some information in named variables called system
properties. System properties are used since release 4.1, whereas
previous releases used environment variables.

   The default representation when reading a system property is taken from the
corresponding environment variable. This makes system properties largely
backward compatible with how environment variables were used in previous
releases. Any exceptions to this rule are explicitly mentioned in the
documentation.

   You can obtain the representation of system properties and environment
variables using `system:environ/[2,3]' (*note lib-system::) and
`SP_getenv()'.

   Some system properties affect the SICStus Prolog initialization
process and must therefore be set before SICStus Prolog has been
initialized. There are three ways to affect the initial values of system
properties:

  1. Set the corresponding environment variable.

     System properties get their default representation from the environment so
     this is often a convenient method. It was the only method available
     prior to release 4.1.

  2. Pass the `-DVAR=VALUE' option to the `sicstus' command line tool.
     *Note too-sicstus::.

  3. Pass an option block to `SP_initialize()' if you initialize the
     SICStus runtime from C. *Note Initializing the Prolog Engine::.


   Looking up system properties follows the platform convention for
environment variables. This means that the lookup is case sensitive on
UNIX-like platforms and case insensitive on Windows.

   On UNIX-like systems, the environment is assumed to use the UTF-8
character encoding; on Windows, the native Unicode encoding is used.

   SICStus reads and copies the process environment during
initialization, e.g. in `SP_initialize()'. Any subsequent changes to
the proces environment will not be detected by SICStus. Note that, at
least on UNIX-like systems, changing the process environment, e.g.
using `setenv()', has undefined behavior when the process has multiple
threads, which is the case for any process running SICStus.

   While copying the environment, each entry in the environment is
normalized as follows:
   * If it does not contain an equal sign, the entry is ignored.

   * On Windows only, if it starts with an equal sign but has no other
     equal signs, the entry is ignored.

   * If the entry consists of valid UTF-8, it is kept as is. This is
     always true on Windows where a Unicode encoding is used internally
     by the operating system.

   * If the entry does not consist of valid UTF-8, it is treated as
     Latin-1 and converted to UTF-8. This cannot happen on Windows.

   * On Windows only, if the entry starts with an equal sign, the equal
     sign is treated as part of the variable name.

   In particular, on UNIX-like systems, this means that the environment
should preferably be in UTF-8.

4.17.1.1 System Properties Set by SICStus Prolog
................................................

The following system properties are set automatically on startup.

`SP_APP_DIR'
     The absolute path to the directory that contains the executable.
     Also available as the `application' file search path.

`SP_APP_PATH'
     The absolute path to the executable. Unlike `SP_APP_DIR', this
     system property may not be available under all circumstances.

`SP_RT_DIR'
     The full path to the directory that contains the SICStus runtime.
     If the application was linked statically to the SICStus runtime,
     `SP_RT_DIR' is the same as `SP_APP_DIR'.  Also available as the
     `runtime' file search path.

`SP_RT_PATH'
     The absolute path to the SICStus runtime. Unlike `SP_RT_DIR', this
     system property may not be available under all circumstances, e.g.
     if the runtime is not a shared library.

`SP_LIBRARY_DIR'
     The absolute path to the directory that contains the SICStus
     library files.  Also available as the initial representation of the
     `library' file search path.

`SP_TEMP_DIR'
     A directory suitable for storing temporary files. It is
     particularly useful with the `open/4' option
     `if_exists(generate_unique_name)'.  Also available as the `temp'
     file search path.

`SP_STARTUP_DIR'
     During initialization the `SP_STARTUP_DIR' system property will be
     set to the working directory used by SICStus.

     Note that this system property can also be set prior to
     initialization, in order to tell SICStus which working directory
     to use. See below.


4.17.1.2 System Properties Affecting Initialization
...................................................

The following system properties can be set before starting SICStus
Prolog.

   Some of these override the default sizes of certain areas.  For
variables ending with `SIZE', the size is in bytes, but may be followed
by `K', `M', or `G' meaning 2**10, 2**20 and 2**30 respectively.

   Boolean values true and false are represented by `yes' and `no',
respectively.

   *Note Memory Use and Garbage Collection: ref-mgc for more information
about the properties that affect memory management.

`SP_PATH'
     Can be used to specify the location of the Runtime Library.  In
     most cases there is no need to use it, but see *note CPL Notes::.

`SP_STARTUP_DIR'
     The representation of this system property, if set, is used as the initial
     working directory. Note that this system property is also set
     automatically during initialization; see above.

     This representation of this system property is _not_ read from the
     corresponding environment variable.

`SP_ALLOW_CHDIR'
     If this system property is set to `no', then SICStus will not
     change the process's working directory when the SICStus working
     directory changes. This is useful when embedding SICStus and would
     probably be the better default behavior except for backwards
     compatibility.

`GLOBALSTKSIZE'
     Controls the initial size of the global stack.  *Please note*: The
     global stack will not be subsequently trimmed to a size smaller
     than this initial size.

`LOCALSTKSIZE'
     Controls the initial size of the local stack.  *Please note*: The
     local stack will not be subsequently trimmed to a size smaller
     than this initial size.

`CHOICESTKSIZE'
     Controls the initial size of the choicepoint stack.  *Please
     note*: The choicepoint stack will not be subsequently trimmed to a
     size smaller than this initial size.

`TRAILSTKSIZE'
     Controls the initial size of the trail stack.  *Please note*: The
     trail stack will not be subsequently trimmed to a size smaller
     than this initial size.

`GROWTHFACTOR   *since release 4.0.8*'
     Meaningful values are between 10 and 100; the default is 62.
     Controls the rate at which the Prolog stacks grow when they are
     expanded.  These stacks are stored in two data areas: one holding
     the global and local stacks; another one holding the choicepoint
     and trail stacks.  In addition, both data areas hold some memory
     reserved for the garbage collector.

     The sizes of the two data areas are constrained to take certain
     discrete values only.  The initial size as well as the size after
     expansion is constrained to be W*((1+G)^N) kilobytes, rounded up
     to an integral number of words, where W is the word length in
     bits, G is `GROWTHFACTOR'/100, and N is an integer.

`PROLOGINITSIZE'
     Controls the size of Prolog's initial memory allocation.  Only
     used by the default memory allocator (*note SP_set_memalloc_hooks:
     cpg-ref-SP_set_memalloc_hooks.).  *Please note*: This initially
     allocated memory will be kept by the Prolog process until
     `SP_deinitialize()' is called or the process exits.

`PROLOGMAXSIZE'
     Defines an upper bound on the amount of memory that Prolog will
     use.  If not set, Prolog will try to use the available address
     space.  Only used by the default memory allocator (*note
     SP_set_memalloc_hooks: cpg-ref-SP_set_memalloc_hooks.).  Thus if
     Prolog needs to allocate memory beyond this bound, a memory
     resource error will be raised.

`PROLOGINCSIZE'
     Controls the amount of memory Prolog asks the operating system for
     in any given memory expansion.  Only used by the default memory
     allocator (*note SP_set_memalloc_hooks:
     cpg-ref-SP_set_memalloc_hooks.).

`PROLOGKEEPSIZE'
     Defines a lower bound on the amount of memory retained by
     `trimcore/0'.  By default, Prolog gets memory from the O/S as the
     user program executes, whereas `trimcore/0' endeavors to return
     free memory back to the O/S.  If the programmer knows that her
     program, once it has grown to a certain size, is likely to need as
     much memory for future computations, she can advise Prolog not to
     return all the free memory back to the operating system by setting
     this variable.  `trimcore/0' only endeavors to return memory that
     is allocated above and beyond `PROLOGKEEPSIZE'; the rest will be
     kept.  Only used by the default memory allocator (*note
     SP_set_memalloc_hooks: cpg-ref-SP_set_memalloc_hooks.).  *Please
     note*: The initially allocated memory will be kept by the Prolog
     process forever, so it is not meaningful to set `PROLOGKEEPSIZE'
     smaller than `PROLOGINITSIZE'.

`SP_ULIMIT_DATA_SEGMENT_SIZE'
     Sets the maximum size of the data segment of the Prolog process.
     The representation can be `unlimited' or a numeric representation as described in the
     first paragraph in this section. A numeric representation of zero (0) is
     equivalent to `unlimited'. Not used under Windows.

`SP_USE_MALLOC'
     If `yes' then `malloc()' et al. will be used for memory management
     instead of the default memory allocator. This is sometimes useful,
     e.g$: with debugging tools like `valgrind'.

     *Please note*: Enabling `malloc()' allocation is not compatible
     with JIT compilation.

`SP_JIT   *since release 4.3*'
     Affects whether the JIT (Just In Time) compiler should be used to
     compile Prolog code inte native (machine) code. One of:

    `yes'
          JIT compilation is enabled and happens automatically. This is
          the default on platforms that support JIT compilation.

    `no'
          JIT compilation is enabled but does not happen automatically.
          Currently, there is no documented way to JIT compile
          predicates manually.

    `disabled'
          JIT compilation is disabled completely. Please report if you
          encounter any reason to disable the JIT compiler.

          JIT compilation may need to be disabled on certain
          security-hardened operating systems, e.g. because they do not
          permit memory to be both writeable and executable.

     This system property is ignored on platforms that do not support
     the JIT compiler.

`SP_JIT_COUNTER_LIMIT   *since release 4.3*'
     Determines how many times a predicate can be called before it is
     JIT compiled. The default is 0.

     The heuristics used in order to decide when, and whether, a
     predicate should be JIT compiled, is subject to change without
     notice. In particular, this system property may be treated
     differently in some future release.

`SP_JIT_CLAUSE_LIMIT   *since release 4.3*'
     Sets an upper bound on the number of clauses of a predicate for JIT
     compilation to be attempted.  The default is 1024.

`SP_SPTI_PATH   *since release 4.3*'
     Specify a plugin that will be told when predicates are JIT
     compiled. The details of writing or using such plugins are
     currently not documented, and subject to change without notice.

     There are two predefined plugins,
    `verbose'
          Write verbose information when a predicate is JIT compiled.
          This can be useful when troubleshooting problems with JIT
          compilation, e.g.  if some predicate takes too long to
          JIT-compile.

          This plugin can be activated by passing
          `-DSP_SPTI_PATH=verbose' to `sicstus'.

    `oprofile'
          Tell OProfile profiler about the location and name of the JIT
          compiled predicates. This makes it possible to use OProfile
          for getting accurate and low-overhead profiling info about
          JIT compiled code. Information about using OProfile for
          profiling jitted code is available at the OProfile site,
          `http://oprofile.sourceforge.net/'.

          This plugin can be activated either by passing
          `-DSP_SPTI_PATH=oprofile' to `sicstus', or, once SICStus has
          started, with the goal `use_module(library(oprofile))'.

          OProfile integration is only available on Linux.



4.17.1.3 Other System Properties
................................

In addition some system properties are read during normal execution. In
this case the system property is typically not meant to be explicitly
set, instead the representation is intended to be taken from the corresponding
environment variable. Examples of such system properties include `PATH'
and `HOME'.


File: sicstus.info,  Node: Debug Intro,  Next: Mixing C and Prolog,  Prev: Prolog Intro,  Up: Top

5 Debugging
***********

This chapter describes the debugging facilities that are available in
development systems.  The purpose of these facilities is to provide
information concerning the control flow of your program.

   The main features of the debugging package are as follows:

   * The "Procedure Box" model of Prolog execution, which provides a
     simple way of visualizing control flow, especially during
     backtracking.  Control flow is viewed at the predicate level,
     rather than at the level of individual clauses.

   * The ability to exhaustively trace your program or to selectively
     set "spypoints".  Spypoints allow you to nominate interesting
     predicates at which, for example, the program is to pause so that
     you can interact.

   * The ability to set advice-points. An advice-point allows you to
     carry out some actions at certain points of execution,
     independently of the tracing activity. Advice-points can be used,
     e.g. for checking certain program invariants (cf. the assert
     facility of the C programming language), or for gathering
     profiling or branch coverage information.  Spypoints and
     advice-points are collectively called breakpoints.

   * The wide choice of control and information options available during
     debugging.

   The Procedure Box model of execution is also called the Byrd Box
model after its inventor, Lawrence Byrd.

   Much of the information in this chapter is also in Chapter eight of
[Clocksin & Mellish 81], which is recommended as an introduction.

   Unless otherwise stated, the debugger prints goals using
`write_term/3' with the representation of the Prolog flag
`debugger_print_options'.  

   The debugger is not available in runtime systems and the predicates
defined in this chapter are undefined; *note Runtime Systems::.

* Menu:

* Procedure Box:: The Procedure Box Control Flow Model
* Basic Debug:: Basic Debugging Predicates
* Plain Spypoint:: Plain Spypoints
* Debug Format:: Format of Debugging Messages
* Debug Commands:: Commands Available during Debugging
* Advanced Debugging:: Advanced Debugging --- an Introduction
* Breakpoint Predicates:: Breakpoint Handling Predicates
* Breakpoint Processing:: The Processing of Breakpoints
* Breakpoint Conditions:: Breakpoint Conditions
* Consult:: Consulting during Debugging
* Exceptions Debug:: Catching Exceptions
* Debug Summary:: Predicate Summary


File: sicstus.info,  Node: Procedure Box,  Next: Basic Debug,  Up: Debug Intro

5.1 The Procedure Box Control Flow Model
========================================

During debugging, the debugger prints out a sequence of goals in
various states of instantiation in order to show the state the program
has reached in its execution.  However, in order to understand what is
occurring it is necessary to understand when and why the debugger
prints out goals.  As in other programming languages, key points of
interest are predicate entry and return, but in Prolog there is the
additional complexity of backtracking.  One of the major confusions
that novice Prolog programmers have to face is the question of what
actually happens when a goal fails and the system suddenly starts
backtracking.  The Procedure Box model of Prolog execution views
program control flow in terms of movement about the program text.  This
model provides a basis for the debugging mechanism in development
systems, and enables the user to view the behavior of the program in a
consistent way.

   Let us look at an example Prolog predicate :

                *--------------------------------------*
        Call    |                                      |    Exit
     ---------> +  descendant(X,Y) :- offspring(X,Y).  + --------->
                |                                      |
                |  descendant(X,Z) :-                  |
     <--------- +     offspring(X,Y), descendant(Y,Z). + <---------
        Fail    |                                      |    Redo
                *-------------------+------------------*
                                    |
     <------------------------------+
        Exception

   The first clause states that Y is a descendant of X if Y is an
offspring of X, and the second clause states that Z is a descendant of
X if Y is an offspring of X and if Z is a descendant of Y.  In the
diagram a box has been drawn around the whole predicate and labeled
arrows indicate the control flow in and out of this box.  There are
five such arrows, which we shall look at in turn.

CALL
     This arrow represents initial invocation of the predicate.  When a
     goal of the form `descendant(X,Y)' is required to be satisfied,
     control passes through the CALL port of the descendant box with
     the intention of matching a component clause and then satisfying
     the subgoals in the body of that clause.  Note that this is
     independent of whether such a match is possible; i.e. first the
     box is called, and then the attempt to match takes place.
     Textually we can imagine moving to the code for descendant when
     meeting a call to descendant in some other part of the code.

EXIT
     This arrow represents a successful return from the predicate.
     This occurs when the initial goal has been unified with one of the
     component clauses and the subgoals have been satisfied.  Control
     now passes out of the EXIT port of the descendant box.  Textually
     we stop following the code for descendant and go back to the place
     we came from.

REDO
     This arrow indicates that a subsequent goal has failed and that
     the system is backtracking in an attempt to find alternatives to
     previous solutions.  Control passes through the REDO port of the
     descendant box.  An attempt will now be made to resatisfy one of
     the component subgoals in the body of the clause that last
     succeeded; or, if that fails, to completely rematch the original
     goal with an alternative clause and then try to satisfy any
     subgoals in the body of this new clause.  Textually we follow the
     code backwards up the way we came looking for new ways of
     succeeding, possibly dropping down on to another clause and
     following that if necessary.

FAIL
     This arrow represents a failure of the initial goal, which might
     occur if no clause is matched, or if subgoals are never satisfied,
     or if any solution produced is always rejected by later processing.
     Control now passes out of the FAIL port of the descendant box and
     the system continues to backtrack.  Textually we move back to the
     code that called this predicate and keep moving backwards up the
     code looking for choicepoints.

EXCEPTION
     This arrow represents an exception that was raised in the initial
     goal, either by a call to `throw/1' or `raise_exception/1' or by
     an error in a built-in predicate.  *Note ref-ere::.  Control now
     passes out of the EXCEPTION port of the descendant box and the
     system continues to pass the exception to outer levels.  Textually
     we move back to the code that called this predicate and keep
     moving backwards up the code looking for a call to `catch/3' or
     `on_exception/3'.

   In terms of this model, the information we get about the procedure
box is only the control flow through these five ports.  This means that
at this level we are not concerned with identifying the matching clause,
and how any subgoals are satisfied, but rather we only wish to know the
initial goal and the final outcome.  However, it can be seen that
whenever we are trying to satisfy subgoals, what we are actually doing
is passing through the ports of _their_ respective boxes.  If we were
to follow this, we would have complete information about the control
flow inside the procedure box.

   Note that the box we have drawn round the predicate should really be
seen as an "invocation box".  That is, there will be a different box
for each different invocation of the predicate.  Obviously, with
something like a recursive predicate, there will be many different
CALLS and EXITS in the control flow, but these will be for different
invocations.  Since this might get confusing each invocation box is
given a unique integer identifier.

   In addition to the five basic ports discussed above, there are two
more ports for invocations involving a blocked goal:

BLOCK
     This port is passed through when a goal is blocked.

UNBLOCK
     This port is passed through when a previously blocked goal is
     unblocked.


File: sicstus.info,  Node: Basic Debug,  Next: Plain Spypoint,  Prev: Procedure Box,  Up: Debug Intro

5.2 Basic Debugging Predicates
==============================

Development systems provide a range of built-in predicates for control
of the debugging facilities.  The most basic predicates are as follows:

`debug   *development*'
     Switches the debugger on, and ensures that the next time control
     reaches a spypoint, it will be activated. In basic usage this
     means that a message will be produced and you will be prompted for
     a command.  In order for the full range of control flow
     information to be available it is necessary to have the debugger
     on from the start.  When it is off the system does not remember
     invocations that are being executed.  (This is because it is
     expensive and not required for normal running of programs.)  You
     can switch DEBUG MODE on in the middle of execution, either from
     within your program or after a `^C' (see `trace/0' below), but
     information prior to this will be unavailable.  *Note
     mpg-ref-debug::.

`zip   *development*'
     Same as `debug/0', except no debugging information is being
     collected, and so is almost as fast as running with the debugger
     switched off.  *Note mpg-ref-zip::.

`trace   *development*'
     Switches the debugger on, and ensures that the next time control
     enters an invocation box, a message will be produced and you will
     be prompted for a command.  The effect of `trace/0' can also be
     achieved by typing `t' after a `^C' interruption of a program.

     At this point you have a number of options.  *Note Debug
     Commands::.  In particular, you can just type <RET> to creep (or
     single-step) into your program.  If you continue to creep through
     your program you will see every entry and exit to/from every
     invocation box, including compiled code, except for code belonging
     to hidden modules (*note ref-mod::).  You will notice that the
     debugger stops at all ports.  However, if this is not what you
     want, the next predicate gives full control over the ports at
     which you are prompted.  *Note mpg-ref-trace::.

`leash(+MODE)   *development*'
     Leashing Mode is set to MODE.  Leashing Mode determines the ports
     of invocation boxes at which you are to be prompted when you creep
     through your program.  At unleashed ports a tracing message is
     still output, but program execution does not stop to allow user
     interaction.  Note that `leash/1' does not apply to spypoints, the
     leashing mode of these can be set using the advanced debugger
     features; *note Advanced Debugging::.  Block and Unblock ports
     cannot be leashed.  MODE can be a subset of the following,
     specified as a list of the following:

    `call'
          Prompt on Call.

    `exit'
          Prompt on Exit.

    `redo'
          Prompt on Redo.

    `fail'
          Prompt on Fail.

    `exception'
          Prompt on Exception.

     The following shorthands are also allowed:

    `leash(all)'
          Same as `leash([exception,call,exit,redo,fail])'.

    `leash(half)'
          Same as `leash([exception,call,redo])'.

    `leash(loose)'
          Same as `leash([exception,call])'.

    `leash(tight)'
          Same as `leash([exception,call,redo,fail])'.

    `leash(off)'
          Same as `leash([])'.

     The initial representation of LEASHING MODE is
     `[call,exit,redo,fail,exception]' (full leashing).  *Note
     mpg-ref-leash::.

`nodebug   *development*'
`notrace   *development*'
`nozip   *development*'
     Switches the debugger off.  Any spypoints set will be kept but
     will never be activated.

`debugging   *development*'
     Prints information about the current debugging state.  This will
     show:

       1. Whether undefined predicates are being trapped.

       2. What breakpoints have been set (see below).

       3. What mode of leashing is in force (see above).
*Note mpg-ref-debugging::.


File: sicstus.info,  Node: Plain Spypoint,  Next: Debug Format,  Prev: Basic Debug,  Up: Debug Intro

5.3 Plain Spypoints
===================

For programs of any size, it is clearly impractical to creep through
the entire program.  Spypoints make it possible to stop the program
whenever it gets to a particular predicate of interest.  Once there,
one can set further spypoints in order to catch the control flow a bit
further on, or one can start creeping.

   In this section we discuss the simplest form of spypoints, the
"plain spypoints". The more advanced forms, the "conditional" and
"generic spypoints" will be discussed later; *note Advanced Debugging::.

   Setting a plain spypoint on a predicate indicates that you wish to
see all control flow through the various ports of its invocation boxes,
except during skips.  When control passes through any port of an
invocation box with a spypoint set on it, a message is output and the
user is asked to interact.  Note that the current mode of leashing does
not affect plain spypoints: user interaction is requested on _every_
port.

   Spypoints are set and removed by the following built-in predicates.
The first two are also standard operators:

`spy :SPEC   *development*'
     Sets plain spypoints on all the predicates given by the
     generalized predicate spec SPEC.

     Examples:

          | ?- spy [user:p, m:q/2, m:q/3].
          | ?- spy m:[p/1, q/1].

     If you set some spypoints when the debugger is switched off, it
     will be automatically switched on, entering zip mode.  *Note
     mpg-ref-spy::.

`nospy :SPEC   *development*'
     Similar to `spy SPEC' except that all the predicates given by SPEC
     will have all previously set spypoints removed from them
     (including conditional spypoints; *note Creating Breakpoints::).
     *Note mpg-ref-nospy::.

`nospyall   *development*'
     Removes all the spypoints that have been set, including the
     conditional and generic ones.  *Note mpg-ref-nospyall::.

   The commands available when you arrive at a spypoint are described
later.  *Note Debug Commands::.


File: sicstus.info,  Node: Debug Format,  Next: Debug Commands,  Prev: Plain Spypoint,  Up: Debug Intro

5.4 Format of Debugging Messages
================================

We shall now look at the exact format of the message output by the
system at a port.  All trace messages are output to the standard error
stream, using the `print_message/2' predicate; *note ref-msg::.  This
allows you to trace programs while they are performing file I/O.  The
basic format is as follows:

     N S    23     F6 Call: T foo(hello,there,_123) ?

   N is only used at Exit ports and indicates whether the invocation
could backtrack and find alternative solutions.  Unintended
nondeterminacy is a source of inefficiency, and this annotation can
help spot such efficiency bugs.  It is printed as `?', indicating that
`foo/3' could backtrack and find alternative solutions, or ` '
otherwise.

   S is a spypoint indicator.  If there is a plain spypoint on `foo/3',
it is printed as `+'. In case of conditional and generic spypoints it
takes the form `*' and `#', respectively. Finally, it is printed as `
', if there is no spypoint on the predicate being traced.

   The first number is the unique invocation identifier.  It is
increasing regardless of whether or not debugging messages are output
for the invocations (provided that the debugger is switched on).  This
number can be used to cross correlate the trace messages for the various
ports, since it is unique for every invocation.  It will also give an
indication of the number of procedure calls made since the start of the
execution.  The invocation counter starts again for every fresh
execution of a command, and it is also reset when retries (see later)
are performed.

   Just before the second number is an optional "frame marker", printed
as `@' if present.  This marks the location of the current frame, the
meaning of which is explained in the next section.

   The second number is the "current depth"; i.e. the number of direct
ancestors this goal has, for which a procedure box has been built by
the debugger.

   The next word specifies the particular port (Call, Exit, Redo, Fail,
or Exception).

   T is a subterm trace.  This is used in conjunction with the `^'
command (set subterm), described below.  If a subterm has been
selected, T is printed as the sequence of commands used to select the
subterm.  Normally, however, T is printed as ` ', indicating that no
subterm has been selected.

   The goal is then printed so that you can inspect its current
instantiation state.

   The final `?' is the prompt indicating that you should type in one
of the commands allowed (*note Debug Commands::).  If this particular
port is unleashed, you will not get this prompt since you have
specified that you don't wish to interact at this point.

   At Exception ports, the trace message is preceded by a message about
the pending exception, formatted as if it would arrive uncaught at the
top-level.

   Note that calls that are compiled inline are not traced.

   Block and Unblock ports are exceptions to the above debugger message
format.  A message

            S -  -  Block: p(_133)

indicates that the debugger has encountered a blocked goal, i.e. one
which is temporarily suspended due to insufficiently instantiated
arguments (*note ref-sem-sec::).  By default, no interaction takes
place at this point, and the debugger simply proceeds to the next goal
in the execution stream.  The suspended goal will be eligible for
execution once the blocking condition ceases to exist, at which time a
message

            S -  -  Unblock: p(_133)

is printed. Although Block and Unblock ports are unleashed by default
in trace mode, you can make the debugger interact at these ports by
using conditional spypoints.


File: sicstus.info,  Node: Debug Commands,  Next: Advanced Debugging,  Prev: Debug Format,  Up: Debug Intro

5.5 Commands Available during Debugging
=======================================

This section describes the particular commands that are available when
the system prompts you after printing out a debugging message.  All the
commands are one or two letter mnemonics, among which some can be
optionally followed by an argument.  They are read from the standard
input stream with any blanks being completely ignored up to the end of
the line (<RET>).

   While you are typing commands at a given port, the debugger
maintains a notion of _current frame_ of the ancestor stack.  The
"current goal", referred to by many commands, is the goal of the
current frame.  The current frame is initially at the bottom of the
ancestor stack, but can be moved by certain commands.  If the current
frame is above the bottom of the stack, the port indicator, displayed
in front of the current goal, is replaced by the word Ancestor.

   The only command that you really have to remember is `h' (followed
by <RET>).  This provides help in the form of the following list of
available commands.

         RET   creep            c      creep
         l     leap             z      zip
         s     skip             s <i>  skip i
         o     out              o <n>  out n
         q     q-skip           q <i>  q-skip i
         r     retry            r <i>  retry i
         f     fail             f <i>  fail i
         j<p>  jump to port     j<p><i>jump to port i
         d     display          w      write
         p     print            p <n>  print partial
         g     ancestors        g <n>  ancestors n
         t     backtrace        t <n>  backtrace n
         [     frame up         ]      frame down
         [ <i> frame i          ] <i>  frame i
         v     variables        v <i>  variables i
         &     blocked goals    & <n>  nth blocked goal
         n     nodebug          =      debugging
         +     spy this         *      spy conditionally
         -     nospy this       \ <i>  remove brkpoint
         D <i> disable brkpoint E <i>  enable brkpoint
         a     abort            b      break
         @     command          u      unify
         e     raise exception  .      find this
         <     reset printdepth < <n>  set printdepth
         ^     reset subterm    ^ <n>  set subterm
         ?     help             h      help

`c'
`<RET>'
     "creep" causes the debugger to single-step to the very next port
     and print a message.  Then if the port is leashed (*note Basic
     Debug::), the user is prompted for further interaction.
     Otherwise, it continues creeping.  If leashing is off, creep is
     the same as "leap" (see below) except that a complete trace is
     printed on the standard error stream.  

`l'
     "leap" causes the debugger to resume running your program, only
     stopping when a spypoint is reached (or when the program
     terminates).  Leaping can thus be used to follow the execution at
     a higher level than exhaustive tracing.  All you need to do is to
     set spypoints on an evenly spread set of pertinent predicates, and
     then follow the control flow through these by leaping from one to
     the other.  Debugging information is collected while leaping, so
     when a spypoint is reached, it is possible to inspect the ancestor
     goals, or creep into them upon entry to Redo ports.  

`z'
     "zip" is like "leap", except no debugging information is being
     collected while zipping, resulting in significant savings in
     memory and execution time.  

`s'
     "skip" is only valid for Call and Redo ports.  It skips over the
     entire execution of the predicate.  That is, you will not see
     anything until control comes back to this predicate (at either the
     Exit port or the Fail port).  Skip is particularly useful while
     creeping since it guarantees that control will be returned after
     the (possibly complex) execution within the box.  If you skip, no
     message at all will appear until control returns.  This includes
     calls to predicates with spypoints set; they will be masked out
     during the skip.  No debugging information is being collected while
     skipping.

     If you supply an integer argument, this should denote an
     invocation number of an ancestral goal.  The system tries to get
     you to the Exit or Fail port of the invocation box you have
     specified.  

`o'
     "out" is a shorthand for skipping to the Exit or Fail port of the
     immediate ancestor goal.  If you supply an integer argument N, it
     denotes skipping to the Exit or Fail port of the Nth ancestor goal.  

`q'
     "quasi-skip" is like a combination of "zip" and "skip": execution
     stops when either control comes back to this predicate, or a
     spypoint is reached.  No debugging information is being collected
     while quasi-skipping.

     An integer argument can be supplied as for "skip".  

`r'
     "retry" can be used at any port (although at the Call port it has
     no effect).  It transfers control back to the Call port of the
     box.  This allows you to restart an invocation when, for example,
     you find yourself leaving with some weird result.  The state of
     execution is exactly the same as when you originally called,
     (unless you use side-effects in your program; i.e. asserts etc.
     will not be undone).  When a retry is performed the invocation
     counter is reset so that counting will continue from the current
     invocation number regardless of what happened before the retry.
     This is in accord with the fact that you have, in executional
     terms, returned to the state before anything else was called.

     If you supply an integer argument, this should denote an
     invocation number of an ancestral goal.  The system tries to get
     you to the Call port of the box you have specified.  It does this
     by continuously failing until it reaches the right place.
     Unfortunately this process cannot be guaranteed: it may be the
     case that the invocation you are looking for has been cut out of
     the search space by cuts (`!') in your program.  In this case the
     system fails to the latest surviving Call port before the correct
     one.  

`f'
     "fail" can be used at any of the four ports (although at the Fail
     port it has no effect).  It transfers control to the Fail port of
     the box, forcing the invocation to fail prematurely.

     If you supply an integer after the command, this is taken as
     specifying an invocation number and the system tries to get you to
     the Fail port of the invocation box you have specified.  It does
     this by continuously failing until it reaches the right place.
     Unfortunately this process cannot be guaranteed: it may be the
     case that the invocation you are looking for has been cut out of
     the search space by cuts (`!') in your program.  In this case the
     system fails to the latest surviving Fail port before the correct
     one.  

`j<p>'
     "jump to port" transfers control back to the prescribed port <P>.
     Here, <P> is one of: `c', `e', `r', `f', standing for Call, Exit,
     Redo and Fail ports. Takes an optional integer argument, an
     invocation number.

     Jumping to a Call port is the same as retrying it, i.e.  `jc' is
     the same as the `r' debugger command; and similarly `jf' is the
     same as `f'.

     The `je' "jump to Exit port" command transfers control back to the
     Exit port of the box. It can be used at a Redo or an Exit port
     (although at the latter it has no effect). This allows you to
     restart a computation following an Exit port, which you first
     leapt over, but because of its unexpected failure you arrived at
     the Redo port. If you supply an integer argument, this should
     denote an _exact_ invocation number of an exited invocation
     present in the backtrace, and then the system will get you to the
     specified Exit port. The debugger requires here an exact
     invocation number so that it does not jump too far back in the
     execution (if an Exit port is not present in the backtrace, it may
     be be a better choice to jump to the preceding Call port, rather
     than to continue looking for another Exit port).

     The `jr' "jump to Redo port" command transfers control back to the
     Redo port of the box. It can be used at an Exit or a Redo port
     (although at the latter it has no effect). This allows you to
     force the goal in question to try to deliver another solution. If
     you supply an integer argument, this should denote an _exact_
     invocation number of an exited invocation present in the
     backtrace, and then the system will get you to the specified Redo
     port.  

`d'
     "display goal" displays the current goal using `display/1'.  See
     Write (below).  

`p'
     "print goal" displays the current goal using `print/1'.  An
     argument will override the default printdepth, treating 0 as
     infinity.  

`w'
     "write goal" displays the current goal using `writeq/1'.  

`g'
     "print ancestor goals" provides you with a list of ancestors to
     the current goal, i.e. all goals that are hierarchically above the
     current goal in the calling sequence.  You can always be sure of
     jumping to the Call or Fail port of any goal in the ancestor list
     (by using retry etc).  If you supply an integer N, only that
     number of ancestors will be printed.  That is to say, the last N
     ancestors will be printed counting back from the current goal.
     Each entry is displayed just as they would be in a trace message,
     except the current frame is indicated by a `@' in front of the
     invocation number.  

`t'
     "print backtrace" is the same as the above, but also shows any
     goals that have exited nondeterminately and their ancestors.  This
     information shows where there are outstanding choices that the
     program could backtrack to.  If you supply an integer N, only that
     number of goals will be printed.

     Ancestors to the current goal are annotated with the `Call:' port,
     as they have not yet exited, whereas goals that have exited are
     annotated with the `Exit:' port.  You can always be sure of
     jumping to the Exit or Redo port of any goal shown to be exited in
     the backtrace listing.

     The backtrace is a tree rather than a stack: to find the parent of
     a given goal with depth indicator D, look for the closest goal
     above it with depth indicator D-1.  

`[   *since release 4.2*'
     "frame up": moves the frame up one step.  If you supply an
     argument, it should denote an invocation number of an existing
     goal.

`]   *since release 4.2*'
     "frame down": moves the frame down one step.  If you supply an
     argument, it should denote an invocation number of an existing
     goal.

`v   *since release 4.2*'
     "print variable bindings" endeavors to print the variable bindings
     of the clause containing the current goal.  This is available for
     both compiled and interpreted code, if the source code was
     originally loaded with the `source_info' Prolog flag switched on.
     The coverage is usually better for compiled code.  If you supply
     an argument, it should denote an invocation number of an existing
     goal.

     Just like the top-level, the debugger displays variable bindings
     as well as any goals that are blocked on a variable found among
     those bindings, and prompts for the same one-letter commands as
     the top-level does; *note Queries::.  To return to the debugger,
     simply type `RET'.

`&'
     "print blocked goals" prints a list of the goals that are
     currently blocked in the current debugging session together with
     the variable that each such goal is blocked on (*note
     ref-sem-sec::).  The goals are enumerated from 1 and up.  If you
     supply an integer N, only that goal will be printed.  Each entry
     is preceded by the goal number followed by the variable name.  

`n'
     "nodebug" switches the debugger off.  Note that this is the
     correct way to switch debugging off at a trace point.  You cannot
     use the `@' or `b' commands because they always return to the
     debugger.  

`='
     "debugging" outputs information concerning the status of the
     debugging package.  See the built-in predicate `debugging/0'.  

`+'
     "spy this" sets a plain spypoint on the current goal.  

`*'
     "spy this conditionally" sets a conditional spypoint on the
     current goal. Prompts for the CONDITIONS, and calls the
          spy(FUNC, CONDITIONS)
     goal, where FUNC is the predicate spec of the current invocation.
     For `spy/2', *note Breakpoint Predicates::.  

`-'
     "nospy this" removes all spypoints applicable to the current goal.
     Equivalent to `nospy FUNC', where FUNC is the predicate spec of
     the current invocation.  

`\'
     "remove this" removes the spypoint that caused the debugger to
     interact at the current port. With an argument N, it removes the
     breakpoint with identifier N.  Equivalent to
     `remove_breakpoints(BID)', where BID is the current breakpoint
     identifier, or the supplied argument (*note Breakpoint
     Predicates::).  

`D'
     "disable this" disables the spypoint that caused the debugger to
     interact at the current port. With an argument N, it disables the
     breakpoint with identifier N.  Equivalent to
     `disable_breakpoints(BID)', where BID is the current breakpoint
     identifier, or the supplied argument (*note Breakpoint
     Predicates::).  

`E'
     "enable this" enables all specific spypoints for the predicate at
     the current port. With an argument N, it enables the breakpoint
     with identifier N. Equivalent to `enable_breakpoints(BID)', where
     BID is the breakpoint identifiers for the current predicate, or
     the supplied argument (*note Breakpoint Predicates::).  

`.'
     "find this" outputs information about where the predicate being
     called is defined.  

`a'
     "abort" causes an abort of the current execution.  All the
     execution states built so far are destroyed and you are put right
     back at the top-level.  (This is the same as the built-in predicate
     `abort/0'.)  

`b'
     "break" calls the built-in predicate `break/0', thus putting you
     at a recursive top-level with the execution so far sitting
     underneath you.  When you end the break (`^D') you will be
     reprompted at the port at which you broke.  The new execution is
     completely separate from the suspended one; the invocation numbers
     will start again from 1 during the break.  The debugger is
     temporarily switched off as you call the break and will be
     re-switched on when you finish the break and go back to the old
     execution.  However, any changes to the leashing or to spypoints
     will remain in effect.  

`@'
     "command" gives you the ability to call arbitrary Prolog goals.
     It is effectively a one-off "break" (see above).  The initial
     message `| :- ' will be output on the standard error stream, and a
     command is then read from the standard input stream and executed
     as if you were at top-level.  If the term read is of form `PATTERN
     ^ BODY', PATTERN is unified with the current goal and BODY is
     executed.  *Please note*:
       1. If BODY is compound, it should be parenthesized.

       2. If the current goal has a module qualifier, PATTERN should not
          include the module qualifier.

`u'
     "unify" is available at the Call port and gives you the option of
     providing a solution to the goal from the standard input stream
     rather than executing the goal.  This is convenient e.g. for
     providing a "stub" for a predicate that has not yet been written.
     A prompt will be output on the standard error stream, and the
     solution is then read from the standard input stream and unified
     with the goal.  If the term read in is of the form `HEAD :- BODY',
     HEAD will be unified with the current goal, and BODY will be
     executed in its place.  

`e'
     "raise exception" is available at all ports.  A prompt will be
     output on the standard error stream, and an exception term is then
     read from the standard input stream and raised in the program
     being debugged.  

`<'
     This command, without arguments, resets the printdepth to 10.
     With an argument of N, the printdepth is set to N, treating 0 as
     infinity.  This command works by changing the representation of the
     `debugger_print_options' Prolog flag.  

`^'
     While at a particular port, a current "subterm" of the current goal
     is maintained.  It is the current subterm that is displayed,
     printed, or written when prompting for a debugger command.  Used
     in combination with the printdepth, this provides a means for
     navigating in the current goal for focusing on the part of
     interest.  The current subterm is set to the current goal when
     arriving at a new port.  This command, without arguments, resets
     the current subterm to the current goal.  With an argument of N (>
     0), the current subterm is replaced by its N:th subterm.  With an
     argument of 0, the current subterm is replaced by its parent term.
     With multiple arguments separated by whitespace, the arguments are
     applied from left to right.  

`?'
`h'
     "help" displays the table of commands given above.  

   The user can define new debugger commands or modify the behavior of
the above ones using the `user:debugger_command_hook/2' hook predicate,
*note Breakpoint Predicates::.


File: sicstus.info,  Node: Advanced Debugging,  Next: Breakpoint Predicates,  Prev: Debug Commands,  Up: Debug Intro

5.6 Advanced Debugging -- an Introduction
=========================================

This section gives an overview of the advanced debugger features. These
center around the notion of breakpoint. Breakpoints can be classified
as either spypoints (a generalization of the plain spypoint introduced
earlier) or advice-points (e.g. for checking program invariants
independently from tracing). The first five subsections will deal with
spypoints only. Nevertheless we will use the term breakpoint, whenever
a statement is made that applies to both spypoints and advice-points.

   *note Breakpoint Processing:: describes the breakpoint processing
mechanism in full detail.  Reference style details of built-in
predicates dealing with breakpoints are given in *note Breakpoint
Predicates:: and in *note Breakpoint Conditions::.

* Menu:

* Creating Breakpoints:: Creating Breakpoints
* Processing Breakpoints:: Processing Breakpoints
* Breakpoint Tests:: Breakpoint Tests
* Specific and Generic Breakpoints:: Specific and Generic Breakpoints
* Breakpoint Actions:: Breakpoint Actions
* Advice-points:: Advice-points
* Built-in Predicates for Breakpoint Handling:: Built-in Predicates for Breakpoint Handling
* Accessing Past Debugger States:: Accessing Past Debugger States
* Storing User Information  in the Backtrace:: Storing User Information  in the Backtrace
* Hooks Related to Breakpoints:: Hooks Related to Breakpoints
* Programming Breakpoints:: Programming Breakpoints


File: sicstus.info,  Node: Creating Breakpoints,  Next: Processing Breakpoints,  Up: Advanced Debugging

5.6.1 Creating Breakpoints
--------------------------

Breakpoints can be created using the `add_breakpoint/2' built-in
predicate.  Its first argument should contain the description of the
breakpoint, the so called "breakpoint spec". It will return the
"breakpoint identifier" (BID) of the created breakpoint in its second
argument. For example:

     | ?- add_breakpoint(pred(foo/2), BID).
     % Plain spypoint for user:foo/2 added, BID=1
     BID = 1

   Here, we have a simple breakpoint spec, prescribing that the
debugger should stop at all ports of all invocations of the predicate
`foo/2'. Thus the above goal actually creates a _plain spypoint_,
exactly as `?- spy foo/2.' does.

   A slightly more complicated example follows:

     | ?- add_breakpoint([pred(foo/2),line('/myhome/bar.pl',123)], _).
     % Conditional spypoint for user:foo/2 added, BID=1

   This breakpoint will be activated only for those calls of `foo/2'
that occur in line 123 of the Prolog program file `'/myhome/bar.pl''.
Because of the additional condition, this is called a _conditional
spypoint_.

   The breakpoint identifier (BID) returned by `add_breakpoint/2' is an
integer, assigned in increasing order, i.e. more recent breakpoints
receive higher identifier values. When looking for applicable
breakpoints, the debugger tries the breakpoints in descending order of
BIDs, i.e. the most recent applicable breakpoint is used. Breakpoint
identifiers can be used for referring to breakpoints to be deleted,
disabled or enabled (see later).

   Generally, the breakpoint spec is a pair `TESTS-ACTIONS'. Here, the
TESTS part describes the conditions under which the breakpoint should
be activated, while the ACTIONS part contains instructions on what
should be done at activation. The test part is built from tests, while
the action part from actions and tests. Test, actions and composite
constructs built from these are generally referred to as "breakpoint
conditions", or simply conditions.

   The action part can be omitted, and then the breakpoint spec
consists of tests only. For spypoints, the default action part is
`[show(print),command(ask)]'. This instructs the debugger to print the
goal in question and then ask the user what to do next, exactly as
described in *note Debug Format::.  To illustrate other possibilities
let us explain the effect of the `[show(display),command(proceed)]'
action part: this will use `display/1' for presenting the goal (just as
the `d' debugger command does, *note Debug Commands::), and will then
proceed with execution without stopping (i.e. the spypoint is
unleashed).


File: sicstus.info,  Node: Processing Breakpoints,  Next: Breakpoint Tests,  Prev: Creating Breakpoints,  Up: Advanced Debugging

5.6.2 Processing Breakpoints
----------------------------

We first give a somewhat simplified sketch of how the debugger treats
the breakpoints. This description will be refined in the sequel.

   The debugger allows us to prescribe some activities to be performed
at certain points of execution, namely at the ports of procedure boxes.
In principle, the debugger is entered at each port of each procedure
invocation. It then considers the current breakpoints one by one, most
recent first. The first breakpoint for which the evaluation of the test
part succeeds is then activated, and the execution continues according
to its action part. The activated breakpoint "hides" the remaining
(older) ones, i.e. those are not tried here. If none of the current
breakpoints is activated, the debugger behaves according to the actual
debugging mode (trace, debug or zip).

   Both the test and the action part can be simple or composite.
Evaluating a simple test amounts to checking whether it holds in the
current state of execution, e.g. `pred(foo/2)' holds if the debugger is
at a port of predicate `foo/2'.

   Composite conditions can be built from simple ones by forming lists,
or using the `,', `;', `->', and `\+' operators, with the usual meaning
of conjunction, disjunction, if-then-else and negation. A list of
conditions is equivalent to a conjunction of the same conditions. For
example, the condition `[pred(foo/2), \+port(fail)]' will hold for all
ports of `foo/2', except for the Fail port.


File: sicstus.info,  Node: Breakpoint Tests,  Next: Specific and Generic Breakpoints,  Prev: Processing Breakpoints,  Up: Advanced Debugging

5.6.3 Breakpoint Tests
----------------------

This section gives a tour of the most important simple breakpoint
tests. In all examples here the action part will be empty. Note that the
examples are independent, so if you want to try out these you should get
rid of the old breakpoints (e.g. using `?- nospyall.') before you enter
a new one.

   The `goal(...)' test is a generalization of the `pred(...)' test, as
it allows us to check the arguments of the invocation. For example:

     | ?- add_breakpoint(goal(foo(1,_)), _).
     % Conditional spypoint for user:foo/2 added, BID=1

   The `goal(G)' breakpoint test specifies that the breakpoint should
be applied only if the current goal is an instance of `G', i.e. `G' and
the current goal can be unified without substituting any variables in
the latter. This unification is then carried out. The `goal(G)'
condition is thus equivalent to the `subsumes(G,CURRENTGOAL)' test
(`subsumes/2' is defined in `library(terms)', *note lib-terms::).

   In the above example the debugger will stop if `foo/2' is called
with `1' as its first argument, but not if the first argument is, say,
`2', nor if it is a variable.

   You can use non-anonymous variables in the `goal' test, and then put
further constraints on these variables using the `true' condition:

     | ?- add_breakpoint([goal(foo(X,_)),true(X>1)], _).
     % Conditional spypoint for user:foo/2 added, BID=1

   Here the first test, `goal', specifies that we are only interested
in invocations of `foo/2', and names the first argument of the goal as
`X'. The second, the `true/1' test, specifies a further condition
stated as a Prolog goal: `X' is greater than `1' (we assume here that
the argument is numeric).  Thus this breakpoint will be applicable if
and only if the first argument of `foo/2' is _greater_ than `1'.
Generally, an arbitrary Prolog goal can be placed inside the `true'
test: the test will succeed if and only if the goal completes
successfully.

   Any variable instantiations in the test part will be undone before
executing the action part, as the evaluation of the test part is
enclosed in a double negation (`\+ \+ (...)'). This ensures that the
test part has no effect on the variables of the current goal.

   Both the `pred' and the `goal' tests may include a module name. In
fact, the first argument of `add_breakpoint' is module name expanded,
and the (explicit or implicit) module name of this argument is then
inherited by default by the `pred', `goal', and `true' tests. Notice
the module qualification inserted in front of the breakpoint spec of
the last example, as shown in the output of the `debugging/0' built-in
predicate:

     | ?- debugging.
     (...)
     Breakpoints:
           1 *  user:foo/2 if user:[goal(foo(A,B)),true(A>1)]

   As no explicit module qualifications were given in the tests, this
breakpoint spec is transformed to the following form:

     [goal(user:foo(A,B)),true(user:(A>1))]

   For exported predicates, a `pred' or `goal' test will be found
applicable for all invocations of the predicate, irrespective of the
module the call occurs in. When you add the breakpoint you can use the
defining or an importing module name, but this information is not
remembered: the module name is "normalized", i.e. it is changed to the
defining module. The example below shows this: although the spypoint is
placed on `user:append', the message and the breakpoint list both
mention `lists:append'.

     | ?- use_module(library(lists)).
     (...)
     % module lists imported into user
     (...)
     | ?- spy user:append.
     % Plain spypoint for lists:append/3 added, BID=1
     | ?- debugging.
     (...)
     Breakpoints:
           1 +  lists:append/3

   Note that the debugger does not stop inside a library predicate when
doing an exhaustive trace. This is because the library modules are
declared hidden (*note ref-mod::), and no trace is produced for calls
inside hidden modules that invoke predicates defined in hidden modules.
However, a spypoint is always shown in the trace, even if it occurs in a
hidden module:

      +      1      1 Call: append([1,2],[3,4],_531) ? <RET>
      +      2      2 Call: lists:append([2],[3,4],_1182) ? <RET>
      +      3      3 Call: lists:append([],[3,4],_1670) ? <RET>
      +      3      3 Exit: lists:append([],[3,4],[3,4]) ? <RET>
     (...)

   You can narrow a breakpoint to calls from within a particular module
by using the `module' test, e.g.

     | ?- add_breakpoint([pred(append/3),module(user)], _).
     % The debugger will first zip -- showing spypoints (zip)
     % Conditional spypoint for lists:append/3 added, BID=1
     % zip
     | ?- append([1,2], [3,4], L).
      *      1      1 Call: append([1,2],[3,4],_531) ? <RET>
      *      1      1 Exit: append([1,2],[3,4],[1,2,3,4]) ? <RET>
     L = [1,2,3,4]

   With this spypoint, the debugger will only stop at the invocations
of `append/3' from the `user' module.

   Note that calling module information is not kept by the compiler for
the built-in predicates, therefore the `module' test will always unify
its argument with `prolog' in case of compiled calls to built-in
predicates.

   There are two further interesting breakpoint tests related to
invocations: `inv(Inv)' and `depth(Depth)'. These unify their arguments
with the invocation number and the depth, respectively (the two numbers
shown at the beginning of each trace message). Such tests are most
often used in more complex breakpoints, but there may be some simple
cases when they are useful.

   Assume you put a plain spypoint on `foo/2', and start leaping
through your program. After some time, you notice some inconsistency at
an Exit port, but you cannot go back to the Call port for retrying this
invocation, because of side-effects. So you would like to restart the
whole top-level goal and get back to the Call port of the suspicious
goal as fast as possible. Here is what you can do:

     | ?- spy foo/2.
     % Plain spypoint for user:foo/2 added, BID=1
     | ?- debug, foo(23, X).
     % The debugger will first leap -- showing spypoints (debug)
      +      1      1 Call: foo(23,_414) ? l
     (...)
      +     81     17 Call: foo(7,_9151) ? l
      +     86     18 Call: foo(6,_9651) ? l
      +     86     18 Exit: foo(6,8) ? -
     % Plain spypoint for user:foo/2, BID=1, removed (last)
            86     18 Exit: foo(6,8) ? *
     Placing spypoint on user:foo/2 with conditions: inv(86).
     % Conditional spypoint for user:foo/2 added, BID=1
      *     86     18 Exit: foo(6,8) ? a
     % Execution aborted
     % source_info
     | ?- debug, foo(23, X).
     % The debugger will first leap -- showing spypoints (debug)
      *     86     18 Call: foo(6,_2480) ? <RET>

   When you reach the Exit port of the suspicious invocation (number
86), you remove the plain spypoint (via the `-' debugger command), and
add a conditional one using the `*' debugger command. This
automatically includes `pred(foo/2)' among the conditions and displays
the prompt `Placing spypoint ... with conditions:', requesting further
ones.  You enter here the `inv' test with the invocation number in
question, resulting in a breakpoint with the `[pred(foo/2),inv(86)]'
conditions. If you restart the original top-level goal in debug mode,
the debugger immediately positions you at the invocation with the
specified number.

   Note that when the debugger executes a "skip" or a "zip" command, no
procedure boxes are built.  Consequently, the invocation and depth
counters are not incremented.  If "skip" and/or "zip" commands were
used during the first execution, the suspicious invocation gets an
invocation number higher than 86 in the second run. Therefore it is
better to supply the `inv(I),true(I>=86)' condition to the `*' debugger
command, which will bring you to the first call of `foo/2' at, or after
invocation number 86 (which still might not be the suspicious
invocation).

   In the examples, the `inv' test was used both with a numeric and a
variable argument (`inv(86)' and `inv(I)'). This is possible because
the debugger _unifies_ the given feature with the argument of the test.
This holds for most tests, we will mention the exceptions.

   Another similar example: if you suspect that a given predicate goes
into an infinite recursion, and would like the execution to stop when
entering this predicate somewhere inside the recursion, you can do the
following:

     | ?- add_breakpoint([pred(foo/2),depth(_D),true(_D>=100)], _).
     % Conditional spypoint for user:foo/2 added, BID=1
     % zip,source_info
     | ?- debug, foo(200, X).
     % The debugger will first leap -- showing spypoints (debug)
      *    496    100 Call: foo(101,_12156) ?

   The above breakpoint spec will cause the debugger to stop at the
first invocation of `foo/2' at depth 100 or greater. Note again that
debug mode has to be entered for this to work (in zip mode no debugging
information is kept, so the depth does not change).

   We now continue with tests that restrict the breakpoint to an
invocation at a specific place in the code.

   Assume file `/home/bob/myprog.pl' contains the following Prolog
program:

                                                _% /home/bob/myprog.pl_
     p(X, U) :-                               % line 1
             q(X, Y),                         % line 2
             q(Y, Z),                         % line 3
             (   \+ q(Z, _)                   % line 4
             ->  q(Z+1, U)                    % line 5
             ;   q(Z+2, U)                    % line 6
             ).                               % ...

     q(X, Y) :-
             X < 10, !, Y is X+1.             % line 10
     q(X, Y) :-
             Y is X+2.                        % line 12

   If you are interested only in the last invocation of `q/2' within
`p/2', you can use the following breakpoint:

     | ?- add_breakpoint([pred(q/2),line('/home/bob/myprog.pl',6)], _).
     % Conditional spypoint for user:q/2 added, BID=1

   Generally, the test `line(File,Line)' holds if the current
invocation was in line number `Line' of a file whose absolute name is
`File'. This test (as well as the `line/1' and `file/1' tests; see
below) require the presence of source information: the file in question
had to be consulted or compiled with the `source_info' Prolog flag
switched on (i.e. set to `on' or `emacs').  

   If e.g. `q/2' is called only from a single file, the file name need
not be mentioned and a `line/1' test suffices: `line(6)'. On the other
hand, if we are interested in all invocations of a predicate within a
file, we can omit the line number and use the `file(File)' test.

   For Prolog programs that are interpreted (consulted or asserted),
further positioning information can be obtained, even in the absence of
source information. The test `parent_pred(Pred)' unifies the module
name expanded `Pred' with a predicate spec (of form
`MODULE:PREDNAME/ARITY') identifying the predicate in which the current
invocation resides.  The test `parent_pred(Pred,N)' will additionally
unify `N' with the serial number of the clause containing the current
goal.

   For example, assuming the above `myprog.pl' file is consulted, the
breakpoint below will cause the execution to stop when the call of
`is/2' in the second clause of `q/2' is reached:

     | ?- add_breakpoint([pred(is/2),parent_pred(q/2,2)], _).
     % Conditional spypoint for prolog:is/2 added, BID=1
     * Predicate prolog:is/2 compiled inline, breakable only in interpreted code
     % zip,source_info
     | ?- p(20, X).
     in scope of a goal at line 12 in /home/bob/myprog.pl
      *      1      1 Call: _579 is 20+2 ?

   Notice the warning issued by `add_breakpoint/2': there are some
built-in predicates (e.g. arithmetic, `functor/3', `arg/3', etc.), for
which the compiler generates specific inline translation, rather than
the generic predicate invocation code. Therefore compiled calls to such
predicates are not visible to the debugger.

   More exact positioning information can be obtained for interpreted
programs by using the `parent_clause(Cl,Sel,I)' test. This unifies `Cl'
with the clause containing the current invocation, while `Sel' and `I'
both identify the current invocation within the body of this clause.
`Sel' is unified with a "subterm selector", while `I' with the serial
number of the call. This test has the variants `parent_clause/[1,2]',
in which only the `Cl' argument, or the `Cl,Sel' arguments are present.

   As an example, two further alternatives of putting a breakpoint on
the last call of `q/2' within `myprog.pl' (line 6) are shown below,
together with a listing showing the selectors and call serial numbers
for the body of `p/2':

     | ?- add_breakpoint([pred(q/2),parent_clause((p(_,_):-_),[2,2,2])],_).

     | ?- add_breakpoint([pred(q/2),parent_clause((p(_,_):-_),_,5)],_).

     p(X, U) :-                 % line  % call no.  % subterm selector
             q(X, Y),           %  2        1       [1]
             q(Y, Z),           %  3        2       [2,1]
             (   \+ q(Z, _)     %  4        3       [2,2,1,1,1]
             ->  q(Z+1, U)      %  5        4       [2,2,1,2]
             ;   q(Z+2, U)      %  6        5       [2,2,2]
             ).                 %  7

   Here, the first argument of the `parent_clause' test ensures that
the current invocation is in (the only clause of) `p/2'. If `p/2' had
more clauses, we would have to use an additional test, say
`parent_pred(user:p/2,1)', and then the first argument of
`parent_clause' could be an anonymous variable.

   In the examples so far the breakpoint tests referred only to the
goal in question. Therefore, the breakpoint was found applicable at all
ports of the procedure box of the predicate. We can distinguish between
ports using the `port' breakpoint test:

     | ?- add_breakpoint([pred(foo/2),port(call)], _).

   With this breakpoint, the debugger will stop at the Call port of
`foo/2', but not at other ports. Note that the `port(call)' test can be
simplified to `call' -- `add_breakpoint/2' will recognize this as a
port name, and treat it as if it were enclosed in a `port/1' functor.

   Here are two equivalent formulations for a breakpoint that will
cause the debugger to stop only at the Call and Exit ports of `foo/2':

     | ?- add_breakpoint([pred(foo/2),(call;exit)], _).

     | ?- add_breakpoint([pred(foo/2),port(P),true((P=call;P=exit(_)))], _).

   In both cases we have to use disjunction. In the first example we
have a disjunctive breakpoint condition of the two simple tests
`port(call)' and `port(exit)' (with the `port' functor omitted). In the
second case the disjunction is inside the Prolog test within the `true'
test.

   Notice that the two examples refer to the Exit port differently.
When you use `port(P)', where `P' is a variable, then, at an exit port,
`P' will be unified with either `exit(nondet)' or `exit(det)',
depending on the determinacy of the exited predicate. However, for
convenience, the test `port(exit)' will also succeed at Exit ports.  So
in the first example above, `exit' can be replaced by `exit(_)', but
the `exit(_)' in the second cannot be replaced by `exit'.

   Finally, there is a subtle point to note with respect to activating
the debugger at non Call ports. Let us look at the following breakpoint:

     | ?- add_breakpoint([pred(foo/2),fail], _).

   The intention here is to have the debugger stop at only the Fail
port of `foo/2'. This is very useful if `foo/2' is not supposed to
fail, but we suspect that it does. The above breakpoint will behave as
expected when the debugger is leaping, but not while zipping.  This is
because for the debugger to be able to stop at a non Call port, a
procedure box has to be built at the Call port of the given invocation.
However, no debugging information is collected in zip mode by default,
i.e. procedure boxes are not built. Later we will show how to achieve
the required effect, even in zip mode.

