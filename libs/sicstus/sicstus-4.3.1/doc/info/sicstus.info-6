This is info/sicstus.info, produced by makeinfo version 4.13 from
sicstus.texi.

INFO-DIR-SECTION SICStus Prolog
START-INFO-DIR-ENTRY
* SICStus Prolog Manual: (sicstus).			SICStus Prolog User's Manual.
END-INFO-DIR-ENTRY
   Generated 27 November 2014.


File: sicstus.info,  Node: obj-glo,  Next: obj-bas,  Prev: obj-exp,  Up: lib-objects

10.22.7 Glossary
----------------

"abstract class"
     A class that cannot have instances. Abstract classes are helpful
     in designing a class hierarchy, to contain the common parts of
     several concrete classes.

"ancestor"
     One of a class's superclasses, one of its superclasses's
     superclasses, etc. Sometimes, for convenience, ancestor includes
     the class itself, along with its proper ancestors.

"child"
     A synonym for subclass.

"class"
     A class is defined by a description of the information its
     instances contain and the messages they respond to.  Every object
     is an instance of one and only one class.

"concrete class"
     A class that can have instances. Most classes are concrete.

"create method"
     Specifies what actions should be taken when an instance of a class
     is created. A create method frequently provides initial slot
     values or specifies an action to be performed by the new object. A
     create message is sent to each new object by the `create/2'
     predicate. A create message is a kind of send message.

"descendant"
     One of a class's subclasses, one of its subclasses's subclasses,
     etc. Sometimes the word descendant includes the class itself,
     along with its proper descendants.

"destroy method"
     Specifies what actions should be taken when an instance of a class
     is destroyed. A destroy message is sent to an object by the
     `destroy/1' predicate. A destroy message is a kind of send message.

"direct slot access"
     Fetching or storing a slot representation without sending a message to the
     object. This should be used with care!

     SICStus Objects allows direct access to a class's slots only
     within its method definitions, via the `fetch_slot/2' and
     `store_slot/2' predicates.

"get message"
     A message that inquires about some aspect of an object.  Typically
     used to fetch slot values. Get methods are automatically generated
     for public slots. Get messages are written with the `>>' operator.

"inheritance"
     The process by which a class's slots and methods are determined
     from an ancestor.

"initial representation"
     The representation a slot is initialized to when an object is created.
     Every slot has a default initial representation, which depends upon its
     type. You may specify different initial values in a class
     definition.

"instance"
     Another word for object. The word instance draws attention to the
     class of which the object is an instance.

"instance method"
     A method that may be defined differently for each instance of a
     class. The class may have a default method for this message, which
     is overridden by installing an instance method for a particular
     object.

"message"
     A command to an object to perform an operation or to modify
     itself, or an inquiry into some aspect of the object.  In SICStus
     Objects, a message is either a get message, a put message or a
     send message. The syntax for sending a message to an object is

          OBJECT OPERATOR MESSAGE


     where OPERATOR is one of the following:

    `>>'
          get message

    `<<'
          put message

    `<-'
          send message

"method"
     A class's implementation of a particular message. You send
     messages to an object, but you define methods for a class.

"method clause"
     A Prolog clause used to define a method for a class. A method
     clause has one of `<-/2', `<</2' or `>>/2' as the principal
     functor of its head, and it can only appear within the scope of
     its class's definition. A method's definition may contain more
     than one message clause.

"mixin class"
     A class that is intended to be combined (mixed in) with other
     classes, via multiple inheritance, to define new subclasses.

"multiple inheritance"
     When a class names more than one superclass.  Typically, it
     inherits slots and methods from each.  In SICStus Objects, two
     different superclasses should not use the same slot name. And, if
     a message is defined by more than one superclass, the class
     definition must specify which method to inherit.

"object"
     A modifiable data item that holds information and responds to
     messages. Another word for instance.

"parent class"
     A synonym for superclass.

"private slot"
     A private slot is, by default, only accessible within methods of
     the class itself.  Not even the descendants of the class may
     access its private slots, except through the class's methods. Get
     and put methods are not automatically generated for a private
     slot, so it is only accessed via the methods you define. If the
     visibility of a slot is not specified, it is private, rather than
     public or protected.

"protected slot"
     A protected slot is, by default, only accessible within methods of
     the class itself and its descendants. Get and put methods are not
     automatically generated for a protected slot, so it is only
     accessed via the methods you define. If the visibility of a slot
     is not specified, it is private, rather than public or protected.


     SICStus Objects `protected' is similar to `protected' in C++.

"public slot"
     A public slot is accessible via its own get and put methods, which
     are generated for it automatically. If no visibility is specified,
     a slot is private, rather than public or protected.

"put message"
     A message that modifies some aspect of an object.  Typically used
     to store slot values. Put methods are automatically generated for
     public slots. Put messages are written with the `<<' operator.

"send message"
     The most common sort of message. Used for performing an operation
     on an object or for performing an action that depends upon an
     object. Send messages are written with the `<-' operator.

"send super"
     When a method for a class executes a shadowed superclass's method.
     This allows a class to put a "wrapper" around its superclass's
     method, making it unnecessary to duplicate the method just to make
     a small extension to it.

"shadow"
     When a class defines its own method for a message defined by one
     of its ancestors, the new method hides or "shadows" the ancestor's
     method. The new class's descendants will inherit its method for
     that message, rather than its ancestors. That is, a class always
     inherits the "closer" of two methods for a message.

"slot"
     A part of an instance that holds an individual datum.  Like a
     member of a C struct or a field of a Pascal record.

"subclass"
     A class that is a more specific case of a particular class.  This
     is the opposite of superclass. A class does not name its
     subclasses; they are inferred.

"superclass"
     A class that is a more general case of a particular class.  Each
     class lists its superclasses.

"term class"
     A class whose instances are represented as ordinary Prolog terms.
     The functor of these objects need not be the name of the class,
     and the arity need not be one.

"term slot"
     A slot that can hold any Prolog term.

"uninherit"
     Specify that a method from a superclass should not be inherited.
     This is similar to shadowing the superclass's method, but does not
     specify a replacement for it.

"visibility"
     A slot may be defined to be either `public', `protected', or
     `private'.  By default, if no visibility is specified, a slot is
     private.



File: sicstus.info,  Node: lib-odbc,  Next: lib-ordsets,  Prev: lib-objects,  Up: The Prolog Library

10.23 The ODBC Interface Library-`library(odbc)'
================================================

This library is an interface to an ODBC database driver. For an
introduction to ODBC, see
`http://msdn.microsoft.com/en-us/library/ms715408(VS.85).aspx'
("Introduction to ODBC"; Microsoft Web Page).  ODBC 3.x is supported.

* Menu:

* ODBC Overview:: Overview
* ODBC Examples:: Examples
* ODBC Datatypes:: Datatypes
* ODBC Exceptions:: Exceptions
* ODBC Predicates:: Predicates


File: sicstus.info,  Node: ODBC Overview,  Next: ODBC Examples,  Up: lib-odbc

10.23.1 Overview
----------------

ODBC (Open Database Connectivity) is a standard API for using a DBMS
(DataBase Management System). By using ODBC you can access data from a
multitude of DBMSs without having to know the details of each DBMS.

   `library(odbc)' is a layer on top of ODBC. It has predicates for
opening the database, starting and executing a query, and retrieving
the results of a query.  The ODBC client application, i.e. this
library, accesses all ODBC functionality via a service provided by the
operating system, the ODBC Driver Manager (DM).

   Some operating systems (e.g. Mac OS X and MS Windows) usually come
with an ODBC Driver Manager preinstalled. For other, UNIX and
UNIX-like, operating systems, unixODBC (`http://www.unixodbc.org') is
the most common but Mac OS X use iODBC (`http://www.iodbc.org').

   The ODBC Driver Manager does not, in itself, provide any database
functionality. Instead the DM loads a ODBC driver specific to the
particular Database Management System (DBMS) (when
`odbc_db_open/[3,4,5]' is called).

   How to install and configure an ODBC driver is beyond the scope of
this document. Please consult the documentation for the particular DBMS
you intend to use. Some popular DBMSs are MySQL and PostgreSQL which
both provide ODBC drivers for many platforms.


File: sicstus.info,  Node: ODBC Examples,  Next: ODBC Datatypes,  Prev: ODBC Overview,  Up: lib-odbc

10.23.2 Examples
----------------

A few examples will best illustrate how to use `library(odbc)'.

* Menu:

* ODBC Example 1:: Example 1
* ODBC Example 2:: Example 2
* ODBC Example 3:: Example 3
* ODBC Example 4:: Example 4


File: sicstus.info,  Node: ODBC Example 1,  Next: ODBC Example 2,  Up: ODBC Examples

10.23.2.1 Example 1
...................

The first example just verifies that ODBC is working and that some ODBC
drivers have been configured in the ODBC Driver Manager.

     :- use_module(library(odbc)).

     example1 :-
         odbc_env_open(EnvHandle),
         odbc_list_DSN(EnvHandle, DSNs),
         odbc_env_close(EnvHandle),
         format('The known DSNs are: ~q~n', [DSNs]).

   You begin by opening an environment. This is a handle which can be
used for various calls to the ODBC Driver Manager (DM).  You then ask
the DM about the data sources, i.e. databases, it knows about. If this
list is empty you need to install and configure the ODBC drivers
appropriate for the database management system that you intend to use.


File: sicstus.info,  Node: ODBC Example 2,  Next: ODBC Example 3,  Prev: ODBC Example 1,  Up: ODBC Examples

10.23.2.2 Example 2
...................

This example is a simple SQL query using a fixed SQL string.

     :- use_module(library(odbc)).

     example_select :-
         odbc_env_open(EnvHandle),
         odbc_db_open('MyDatabase', EnvHandle, ConnectionHandle),
         odbc_query_open(ConnectionHandle, StatementHandle),
         odbc_query_execute_sql(StatementHandle,
                            'SELECT cookie,soft FROM bakery order by soft',
                            ResultSet),
         show_result(ResultSet),
         odbc_query_close(ResultSet),
         odbc_db_close(ConnectionHandle),
         odbc_env_close(EnvHandle).

     show_result(ResultSet) :-
         odbc_sql_fetch(ResultSet, Row),
         show_result1(Row, ResultSet).

     show_result1([], _ResultSet) :- !.
     show_result1(Row, ResultSet) :-
         format('~w~n', [Row]),
         flush_output,
         odbc_sql_fetch(ResultSet, Row1),
         show_result1(Row1, ResultSet).

   As always, you begin by opening an environment.  You then connect to
the database with `odbc_db_open/3'.  The first argument is the
identifier for the database in the DBMS.  In this scenario, connecting
to the database does not require a username and a password.  The output
from `odbc_db_open/3' is an opaque handle on the database.

   First, `odbc_query_open/2' is used to create an SQL query, which is
straightforward.  Then, `odbc_query_execute_sql/3' is used to execute
the SQL query. By executing an SQL query a _result set_ is created.
Each consecutive call of `odbc_sql_fetch/2' will retrieve one row from
the result set.


File: sicstus.info,  Node: ODBC Example 3,  Next: ODBC Example 4,  Prev: ODBC Example 2,  Up: ODBC Examples

10.23.2.3 Example 3
...................

This example shows the use of parameter binding. The positional markers
(?) in the SQL string are bound to the elements in the list in the
third argument of odbc_query_execute_sql/5. The fourth argument is a
list of datatypes corresponding to the parameters.

     :- use_module(library(odbc)).

     example2 :-
        odbc_env_open('SQL_OV_ODBC3', EnvHandle),
        odbc_db_open('MyDatabase', EnvHandle, ConnectionHandle),
        odbc_query_open(ConnectionHandle, StatementHandle),
        odbc_query_execute_sql(StatementHandle,
                            'INSERT INTO scratch (vehicle, wheels) VALUES (?, ?)',
                            ["railwaycar", 8],
                            ['SQL_VARCHAR', 'SQL_INTEGER'],
                            ResultSet),
        odbc_query_close(ResultSet),
        odbc_db_close(ConnectionHandle),
        odbc_env_close(EnvHandle).


File: sicstus.info,  Node: ODBC Example 4,  Prev: ODBC Example 3,  Up: ODBC Examples

10.23.2.4 Example 4
...................

This example is similar to the second, but this time we ask the
database what the datatypes of the columns of the table are with
odbc_list_data_types/3.

     :- use_module(library(odbc)).

     example3 :-
        odbc_env_open(EnvHandle),
        odbc_db_open('MyDatabase', EnvHandle, ConnectionHandle),
        odbc_query_open(ConnectionHandle, StatementHandle),
        odbc_list_data_types(StatementHandle,
                             scratch(vehicle, wheels),
                             DataTypes),
        odbc_query_execute_sql(StatementHandle,
                            'INSERT INTO scratch (vehicle, wheels) VALUES (?, ?)',
                            ["railwaycar", 8],
                            DataTypes,
                            ResultSet),
        odbc_query_close(ResultSet),
        odbc_db_close(ConnectionHandle),
        odbc_env_close(EnvHandle).


File: sicstus.info,  Node: ODBC Datatypes,  Next: ODBC Exceptions,  Prev: ODBC Examples,  Up: lib-odbc

10.23.3 Datatypes
-----------------

* Menu:

* ODBC Reading:: Reading from the database
* ODBC Writing:: Writing to the database


File: sicstus.info,  Node: ODBC Reading,  Next: ODBC Writing,  Up: ODBC Datatypes

10.23.3.1 Reading from the database
...................................

When reading data from the database the following datatypes are
supported, with conversion to the corresponding prolog datatypes.
`SQL_CHAR', `SQL_VARCHAR' etc.
     A list of character codes.

`SQL_BIT'
     The integer `0' for false, or `1' for true.

`SQL_INTEGER', `SQL_TINYINT', `SQL_SMALLINT', etc.
     An integer.

`SQL_REAL', `SQL_DOUBLE', `SQL_FLOAT'
     A floating point number.

`SQL_DATE'
     A term `date(Year, Month, DayOfMonth)', with one-based   integer
     arguments. E.g. `date(2012,10,22)' means October   22, 2012.

`SQL_TIME'
     A term `time(Hour, Minute, Second)' with one-based integer
     arguments. E.g. `time(22,11,5)' means eleven minutes and   five
     seconds past ten pm.

`SQL_TIMESTAMP'
     A term `timestamp(Year, Month, Day, Hour, Minute, Second,
     Fraction)' where the arguments have the same meaning as for
     `SQL_TIME' and `SQL_TIMESTAMP' and FRACTION   means fractional
     nanoseconds past, as an integer.

the SQL null representation
     The atom `null'.

`SQL_BINARY' and other binary types
`SQL_INTERVAL_HOUR' and other interval types
`SQL_UTCTIME' and `SQL_UTCDATETIME'
     Currently not supported.
   Note that atoms with names that start with an upper case letter,
like `SQL_CHAR' must be quoted in Prolog, e.g. `'SQL_CHAR''.


File: sicstus.info,  Node: ODBC Writing,  Prev: ODBC Reading,  Up: ODBC Datatypes

10.23.3.2 Writing to the database
.................................

When writing data to the database the following SQL datatypes are
supported.

`SQL_CHAR', `SQL_VARCHAR' etc.
     A list of character codes, or a list of atoms.

     For backwards compatibility only, an atom is also accepted, but
     note that the atoms `null' and `[]' have special meaning  (as SQL
     null representation and empty code list, respectively) and more  atoms with
     special meaning may be introduced in the future. For
     compatibility with some ODBC drivers, the integer 0 and 1 are
     allowed, meaning "0" and "1".

`SQL_BIT'
     The integer `0' for false, or `1' for true.

`SQL_INTEGER', `SQL_TINYINT', `SQL_SMALLINT', etc.
     An integer.

`SQL_REAL', `SQL_DOUBLE', `SQL_FLOAT'
     A floating point number or a small integer.

`SQL_DATE'
     A term `date(Year, Month, DayOfMonth)', as above.

`SQL_TIME'
     A term `time(Hour, Minute, Second)', as above.

`SQL_TIMESTAMP'
     A term `timestamp(Year, Month, Day, Hour, Minute, Second,
     Fraction)', as above.

the SQL null representation
     The atom `null'.

`SQL_BINARY' and other binary types
`SQL_INTERVAL_HOUR' and other interval types
`SQL_UTCTIME' and `SQL_UTCDATETIME'
     Currently not supported.
   if a representation is out of range for the corresponding SQL  type, e.g. a
too large integer for `SQL_SMALLINT', the  result is undefined.  Note
that atoms with names that start with an upper case letter,  like
`SQL_CHAR' must be quoted in Prolog, e.g. `'SQL_CHAR''.


File: sicstus.info,  Node: ODBC Exceptions,  Next: ODBC Predicates,  Prev: ODBC Datatypes,  Up: lib-odbc

10.23.4 Exceptions
------------------

When an error in the ODBC layer occurs, predicates in `library(odbc)'
throw `error/2' exceptions. Both arguments of the `error/2' exception
are the same and has the following form `odbc_error(DETAIL, GOAL)',
where `Goal' is some goal where the error occurred, and DETAIL gives
more information about the error. The DETAIL term can have the
following form:

`data_conversion'
     Thrown in case of a error when converting to or from a SICStus data
     type from or to an ODBC data type.

`unsupported_datatype'
     Thrown when an SQL data type is unsupported when converting to or
     from a SICStus data type from or to an ODBC data type.

`unknown_datatype'
     Thrown when an unknown SQL data type is found when converting to or
     from a SICStus data type from or to an ODBC data type.

`type_error'
     Thrown when the Prolog data is of a type incompatible with the SQL
     data type when converting from a SICStus data type to an ODBC data
     type.

`native_code'
     Thrown in case of a error in the native code of `library(odbc)'.

`invalid_handle(handle_type, INVALIDHANDLE, RETURNCODE)'
     Thrown when an invalid handle type is specified.

`invalid_handle('HandleType'-HANDLETYPE, 'Handle'-HANDLE)'
     Thrown when an invalid handle is specified.

`invalid_handle(result_set, RESULTSET)'
     Thrown when a Result Set handle is invalid.

`unknown_connection_option(OPTIONS)'
     Thrown when an unknown option was given when calling
     `odbc_db_open/[3,4,5]'.

`internal_error'
     Thrown when an internal error occurs in `library(odbc)'. Please
     report this to SICStus Support.

`diag(RETURNCODE, RECS)'
     Thrown when an error occurs in the ODBC layer, e.g. a SQL syntax
     error.  RECS is bound to the diagnostic records reported from ODBC.

`out_of_memory'
     Thrown when some operation runs out of memory.
   there may be other DETAILS and new DETAILS may be added in the
future.


File: sicstus.info,  Node: ODBC Predicates,  Prev: ODBC Exceptions,  Up: lib-odbc

10.23.5 Predicates
------------------

`odbc_env_open(-ENVHANDLE)'
     Opens an ODBC environment.  Throws an exception if the environment
     could not be opened.

`odbc_db_open(+DBNAME,+ENVHANDLE,-CONNECTIONHANDLE)'
     Opens a database with the name DBNAME. The database cannot require
     a username and a password.  CONNECTIONHANDLE is an opaque handle
     for accessing the database.

`odbc_db_open(+DBNAME,+ENVHANDLE,+OPTIONS,-CONNECTIONHANDLE)'
     Opens a database with the name DBNAME.  OPTIONS should be a list
     of zero or more of:
    `username(+USERNAME)'
          The username for connecting to the database.  The default is
          `'''.

    `password(+PASSWORD)'
          The password for connection to the database.  The default is
          `'''.

    `login_timeout(+TIMEOUT)'
          The number of seconds to wait for a login request to complete.
          If 0 is used, the login attempt will wait indefinitely.  The
          default is driver-dependent.

    `connection_timeout(+TIMEOUT)'
          The number of seconds to wait for any request on the
          connection to complete.  If the Timeout representation is 0 (the
          default), there is no timeout.

    `raw(+CONNECTIONOPTIONS)'
          CONNECTIONOPTIONS should be a list of atoms. They are passed,
          terminated by `;', as extra options when opening the database.
     CONNECTIONHANDLE is an opaque handle for accessing the database.

`odbc_db_open(+DBNAME,+ENVHANDLE,+OPTIONS,-CONNECTIONHANDLE,-CONNECTIONSTRING)'
     Like `odbc_db_open/4' but also returns the completed connection
     string returned by the ODBC driver.

`odbc_query_open(+CONNECTIONHANDLE, -STATEMENTHANDLE)'
     Creates a new database query. CONNECTIONHANDLE is a handle
     previously allocated with `odbc_db_open/[3,4,5]'.

`odbc_list_DSN(+ENVHANDLE,-DSNS)'
     ENVHANDLE is an opaque database handle.  DSNS is unified with a
     list of all DSNs (Data Source Names).  The list elements are X-Y
     where X is the DSN and Y its description.

`odbc_list_data_types(+STATEMENTHANDLE, +TABLEDESC, -DATATYPES)'
     Makes a list of the datatypes in a table.  STATEMENTHANDLE is a
     handle previously allocated with `odbc_query_open/2'.  TABLEDESC
     is a description of the table and its columns of the form
     `tablename(columnname1, columnname2, ..., columnnameN)', or of the
     form `[tablename, columnname1, columnname2, ..., columnnameN]'
     (the latter form is useful if the table has more than 255 columns).
     DATATYPES is unified with a list of the corresponding datatypes,
     i.e.  on the form `[datatype1, datatype2, ... datatypeN]'.

`odbc_current_table(+ConnectionHandle, ?TableName)   *since release 4.2*'
     Enumerate the _proper_ tables in the database, i.e. tables with
     attribute `'TABLE_TYPE'("TABLE")'.

     CONNECTIONHANDLE is a handle previously allocated with
     `odbc_db_open/[3,4,5]'.  TABLENAME is the name, as an atom, of the
     table.

     Note that `odbc_current_table/2' may exit nondeterminately even if
     all arguments are instantiated when it is called.

`odbc_current_table(+ConnectionHandle, ?TableName, ?Attribute)   *since release 4.2*'
     Enumerate database tables and their attributes.

     CONNECTIONHANDLE is a handle previously allocated with
     `odbc_db_open/[3,4,5]'.  TABLENAME is the name, as an atom, of the
     table.  ATTRIBUTE is an attribute of the table.

     There are two kinds of attributes, _derived_ attributes and _raw_
     attributes.

     The _derived_ attributes are translations of raw attributes and
     other information and are in a format that is directly useful.
     There is currently only one derived attribute,
    `arity(VALUE)'
          The number of columns in the table, as an integer.

          This attribute is always present.
     the set of derived attributes may be extended in the future.

     The raw attributes correspond direcly to the (non-null) values
     returned from the ODBC function `SQLTables()' and are returned as
     is, wrapped in a functor with the same name as the attribute, e.g.
     `'TABLE_CAT'("foo")' would be returned for a table in the catalog
     "foo". Note that the names of the raw attributes are in all
     uppercase so you need to surround them with single quotes to
     prevent their name from being parsed as a variable. Some of the
     raw attributes are,
    `'TABLE_CAT'(VALUE)'
          Catalog name, as a code list. This attribute corresponds to
          the `TABLE_CAT' column, called `TABLE_QUALIFIER' in ODBC 2.0,
          as returned from the ODBC function `SQLTables()'.

    `'TABLE_TYPE'(VALUE)'
          Table type, as a code list. This attribute corresponds to the
          `TABLE_TYPE' column, as returned from the ODBC function
          `SQLTables()'. The standard table types are `"TABLE"',
          `"VIEW"', `"SYSTEM TABLE"', `"GLOBAL TEMPORARY"', `"LOCAL
          TEMPORARY"', `"ALIAS"', and `"SYNONYM"', but there can be
          data-source-specific types as well.

          This attribute is always present.

    `'REMARKS'(VALUE)'
          Table descriptive text, as a code list. This attribute
          corresponds to the `REMARKS' column, as returned from the
          ODBC function `SQLTables()'.

     see the ODBC documentation for `SQLTables()' for the full list of
     raw attributes and their meaning.

     Note that `odbc_current_table/3' may exit nondeterminately even if
     one of more arguments are instantiated when it is called.

`odbc_table_column(+ConnectionHandle, ?TableName, ?ColumnName)   *since release 4.2*'
     Enumerate database table columns.

     CONNECTIONHANDLE is a handle previously allocated with
     `odbc_db_open/[3,4,5]'.  TABLENAME is the name, as an atom, of the
     table.  COLUMNNAME is the name, as an atom, of the table.

`odbc_table_column(+ConnectionHandle, ?TableName, ?ColumnName, ?Attribute)   *since release 4.2*'
     Enumerate database table columns and their attributes.

     CONNECTIONHANDLE is a handle previously allocated with
     `odbc_db_open/[3,4,5]'.  TABLENAME is the name, as an atom, of the
     table.  COLUMNNAME is the name, as an atom, of the table.
     ATTRIBUTE is an attribute of the table.

     There are two kinds of attributes, _derived_ attributes and _raw_
     attributes.

     The _derived_ attributes are translations of raw attributes and
     other information and are in a format that is directly useful.
     There is currently only one derived attribute,
    `nullable(VALUE)'
          `true' if the column is definitely nullable, or `false' if
          the column is definitely not nullable. The representation is derived
          from the raw attributes `NULLABLE' and `IS_NULLABLE', see the
          documentation for `SQLColumns()' for details.

          This attribute is not present if it can not be determined
          whether the column is nullable.
     the set of derived attributes may be extended in the future.

     The raw attributes correspond direcly to the (non-null) values
     returned from the ODBC function `SQLColumns()' and are returned as
     is, wrapped in a functor with the same name as the attribute, e.g.
     `'TABLE_CAT'("foo")' would be returned for a column in a table in
     the catalog "foo". Note that the names of the raw attributes are
     in all uppercase so you need to surround them with single quotes
     to prevent their name from being parsed as a variable. Some of the
     raw attributes are,
    `'REMARKS'(VALUE)'
          Column descriptive text, as a code list. This attribute
          corresponds to the `REMARKS' column, as returned from the
          ODBC function `SQLColumns()'.

    `'ORDINAL_POSITION'(VALUE)'
          The ordinal position of the column in the table, starting at
          1. This attribute corresponds to the `ORDINAL_POSITION'
          column, as returned from the ODBC function `SQLColumns()'.

          This attribute is always present.


     See the ODBC documentation for `SQLColumns()' for the full list of
     raw attributes and their meaning.

     Note that `odbc_table_column/4' may exit nondeterminately even if
     one of more arguments are instantiated when it is called.

`odbc_query_execute_sql(+STATEMENTHANDLE, +SQLSTRING, +PARAMDATA, +PARAMDATATYPES, -RESULTSET)'
     Executes an SQL query.  STATEMENTHANDLE is a handle previously
     allocated with `odbc_query_open/2'.  SQLSTRING is the SQL
     statement to be executed. The statement string may contain
     parameter markers.  PARAMDATA is a list of data to be bound to the
     parameter markers.  PARAMDATATYPES is a list of data types
     corresponding to the PARAMDATA list.  RESULTSET is bound to an
     opaque data structure describing the result of the query.

`odbc_query_execute_sql(+STATEMENTHANDLE, +SQLSTRING, -RESULTSET)'
     STATEMENTHANDLE is a handle previously allocated with
     `odbc_query_open/2'.  SQLSTRING is the SQL statement to be
     executed.  RESULTSET is bound to an opaque data structure
     describing the result of the query.

`odbc_sql_fetch(+RESULTSET, -ROW)'
     Fetch the next row from the result set.  RESULTSET is the result
     set from `odbc_query_execute_sql/[3,5]'.  ROW is unified with a
     non-empty list of data constituting a row in the result set, or
     with `[]' when there are no more rows.  The elements in the ROW
     are in the same order as in the corresponding query.

`odbc_query_close(+QUERY)'
     Closes the query represented by QUERY, which can be either a
     result set, e.g. as returned from `odbc_query_execute_sql/[3,5]',
     or it can be a statement handle, as returned from
     `odbc_query_open/2'.

`odbc_db_close(+CONNECTIONHANDLE)'
     Closes the connection to the database.

`odbc_env_close(+ENVHANDLE)'
     Frees the environment handle.


File: sicstus.info,  Node: lib-ordsets,  Next: lib-pillow,  Prev: lib-odbc,  Up: The Prolog Library

10.24 Ordered Set Operations--`library(ordsets)'
================================================

This library module provides operations on sets represented as ordered
lists with no duplicates.  Thus `{c,r,a,f,t}' would be `[a,c,f,r,t]'.
The ordering is defined by the `@<' family of term comparison
predicates, which is the ordering used by `sort/2' and `setof/3'.

   The benefit of the ordered representation is that the elementary set
operations can be done in time proportional to the sum of the argument
sizes rather than their product.  You should use the operations defined
here in preference to those in `library(sets)' unless there is a
compelling reason why you can't.  Some of the unordered set routines,
such as `member/2', `length/2' and `select/3' can be used unchanged on
ordered sets; feel free so to use them.

   There is no `ordset_to_list/2', as an ordered set is a list already.
Exported predicates:

`is_ordset(+LIST)'
     is true when LIST is a list of terms [T1,T2,...,TN] and the terms
     are strictly increasing: T1 @< T2 @< ... @< TN.  The output of
     `sort/2' always satisfies this test.  Anything which satisfies
     this test can be given to the predicates in this file, regardless
     of where you got it.

`list_to_ord_set(+LIST, -SET)'
     is true when SET is the ordered representation of the set
     represented by the unordered representation List.  The only reason
     for giving it a name at all is that you may not have realised that
     `sort/2' could be used this way.

`ord_add_element(+SET1, +ELEMENT, -SET2)'
     Equivalent to `ord_union(SET1, [ELEMENT], SET2)', but a bit faster.

`ord_del_element(+SET1, +ELEMENT, -SET2)'
     Equivalent to `ord_subtract(SET1, [ELEMENT], SET2)', but a bit
     faster.

`ord_disjoint(+SET1, +SET2)'
     is true when the two ordered sets have no element in common.

`ord_intersect(+SET1, +SET2)'
     is true when the two ordered sets have at least one element in
     common.

`ord_intersection(+SET1, +SET2, -INTERSECTION)'
     is true when INTERSECTION is the ordered representation of SET1
     and SET2, provided that SET1 and SET2 are ordered sets.

`ord_intersection(+SET1, +SET2, ?INTERSECTION, ?DIFFERENCE)'
     is true when INTERSECTION is the intersection of SET1 and SET2,
     and DIFFERENCE is SET2 \ SET1 (like in ord_union/4), provided that
     SET1 and SET2 are ordered sets.

`ord_intersection(+LISTOFSETS, -INTERSECTION)'
     is true when LISTOFSETS is a nonempty proper list of ordered sets
     and INTERSECTION is their intersection.

`ord_member(+ELT, +SET)'
     is true when ELT is a member of SET.  Suggested by Mark Johnson.

`ord_nonmember(+ITEM, +SET)'
     is true when the given ITEM is _not_ an element of the given SET.

`ord_seteq(+SET1, +SET2)'
     is true when the two arguments represent the same set.  Since they
     are assumed to be ordered representations, they must be identical.

`ord_setproduct(+SET1, +SET2, -PRODUCT)'
     If SET1 and SET2 are ordered sets, PRODUCT will be an ordered set
     of X1-X2 pairs.  Note that we cannot solve for SET1 and SET2,
     because there are infinitely many solutions when PRODUCT is empty,
     and may be a large number in other cases.  Could be defined as:

          ord_setproduct(Set1, Set2, Product) :-
          	(   foreach(H1,Set1),
          	    param(Set2),
          	    fromto(Product,P1,P3,[])
          	do  (   foreach(H2,Set2),
          		param(H1),
          		fromto(P1,[H1-H2|P2],P2,P3)
          	    do  true
          	    )
          	).

`ord_subset(+SET1, +SET2)'
     is true when every element of the ordered set SET1 appears in the
     ordered set SET2.

`ord_subtract(+SET1, +SET2, -DIFFERENCE)'
     is true when DIFFERENCE contains all and only the elements of SET1
     which are not also in SET2.

`ord_symdiff(+SET1, +SET2, -DIFFERENCE)'
     is true when DIFFERENCE is the symmetric difference of SET1 and
     SET2.

`ord_disjoint_union(+SET1, +SET2, -UNION)'
     is true when SET1 and SET2 (given to be ordered sets) have no
     element in common, and UNION is their union.  The meaning is the
     same as
              ord_disjoint(Set1, Set2),
              ord_union(Set1, Set2, Union)
     but it is more efficient.

`ord_union(+SET1, +SET2, -UNION)'
     is true when UNION is the union of SET1 and SET2.  Note that when
     something occurs in both sets, we want to retain only one copy.

`ord_union(+OLDSET, +NEWSET, -UNION, -REALLYNEW)'
     is true when UNION is NEWSET U OLDSET and REALLYNEW is NEWSET \
     OLDSET.  This is useful when you have an iterative problem, and
     you're adding some possibly new elements (NEWSET) to a set
     (OLDSET), and as well as getting the updated set (UNION) you would
     like to know which if any of the "new" elements didn't already
     occur in the set (REALLYNEW).

`ord_union(+LISTOFSETS, -UNION)'
     is true when LISTOFSETS is given as a proper list of ordered sets
     and UNION is their union.  Letting K be the length of LISTOFSETS,
     and N the sum of the sizes of its elements, the cost is O(N LG K).

`ordset_order(+XS, +YS, -R)'
     is true when R is `<', `=', or `>' according as XS is a subset of
     YS, equal to YS, or a superset of YS.  XS and YS are ordered sets.


File: sicstus.info,  Node: lib-pillow,  Next: lib-plunit,  Prev: lib-ordsets,  Up: The Prolog Library

10.25 The PiLLoW Web Programming Library--`library(pillow)'
===========================================================

The PiLLoW library ("Programming in Logic Languages on the Web") is a
free Internet/WWW programming library for Logic Programming Systems that
simplifies the process of writing applications for such environment.
The library provides facilities for generating HTML or XML structured
documents by handling them as Prolog terms, producing HTML forms,
writing form handlers, processing HTML templates, accessing and parsing
WWW documents (either HTML or XML), accessing code posted at HTTP
addresses, etc.

   PiLLoW is documented in its own reference manual, located in
`http://www.clip.dia.fi.upm.es/Software/pillow/pillow_doc_html/pillow_doc_toc.html'
(HTML) or `http://www.clip.dia.fi.upm.es/Software/pillow/pillow_doc.ps'
(Postscript). The following points are worth noting wrt. the PiLLoW
reference manual:

   * PiLLoW is automatically installed with the SICStus Prolog
     distribution.  No extra action needs to be taken.

   * PilloW comes as a single library module, `library(pillow)'.

     This subsumes the various `load_package/1' and `use_module/1'
     queries mentioned in the PiLLoW reference manual.

   Further information can be found at the PiLLoW home page,
`http://clip.dia.fi.upm.es/Software/pillow/pillow.html'.


File: sicstus.info,  Node: lib-plunit,  Next: lib-process,  Prev: lib-pillow,  Up: The Prolog Library

10.26 Plunit Interface--`library(plunit)'
=========================================

* Menu:

* PlUnit Introduction:: Introduction
* PlUnit A Unit Test Box:: A Unit Test Box
* PlUnit Running the Test-Suite:: Running the Test-Suite
* PlUnit Tests and Production Systems:: Tests and Production Systems


File: sicstus.info,  Node: PlUnit Introduction,  Next: PlUnit A Unit Test Box,  Up: lib-plunit

10.26.1 Introduction
--------------------

This library module provides a Prolog unit-test framework, initially
developed by Jan Wielemaker for SWI-Prolog.  The code and documentation
was subsequently adapted for SICStus Prolog by SICS.  The module is a
third-party product, and not part of SICStus Prolog proper.

   Automatic testing of software during development is probably the most
important Quality Assurance measure. Tests can validate the final
system, which is nice for your users.  However, most (Prolog) developers
forget that it is not just a burden during development.

   * Tests document how the code is supposed to be used.

   * Tests can validate claims you make on the Prolog
     implementation.  Writing a test makes the claim           explicit.

   * Tests avoid big applications saying "no" after
     modifications.  This saves time during development,           and
     it saves _a lot_ of time if you must return           to the
     application a few years later or you must           modify and
     debug someone else's application.


File: sicstus.info,  Node: PlUnit A Unit Test Box,  Next: PlUnit Running the Test-Suite,  Prev: PlUnit Introduction,  Up: lib-plunit

10.26.2 A Unit Test Box
-----------------------

Tests are written in normal Prolog.  A unit test is a named collection
of individual tests, enclosed within the directives:
     `:- begin_tests(UNIT[,OPTIONS]).'
   
and:
     `:- end_tests(UNIT).'
   
   They can be embedded inside a normal source module, or be placed in a
separate test-file that loads the files to be tested. The individual
tests are defined by rules of the form:
     `test(NAME[,OPTIONS]) :- TEST-BODY.'
   
where NAME is a ground term and OPTIONS is a list describing additional
properties of the test.  Here is a very simple example:

     :- begin_tests(lists).
     :- use_module(library(lists)).

     test(reverse) :-
             reverse([a,b], [b,a]).

     :- end_tests(lists).

   The optional second argument of the unit test declaration as well as
of the individual test-heads defines additional processing options.
The following options are available:

`blocked(REASON)'
     The test is currently disabled.   Tests are flagged as blocked if
     they cannot be run for some reason.  E.g. they crash Prolog, they
     rely on some service that is not available, they take too much
     resources, etc.  Tests that fail but don't crash, etc. should be
     flagged using `fixme(FIXME)'.  REASON should be an atom.

`fixme(REASON)'
     Similar to `blocked(FIXME)', but the test it executed anyway.  A
     summary is printed at the end of the test run.  REASON should be
     an atom.

`condition(GOAL)'
     Precondition for running the test.  If the condition fails, the
     test is skipped.  The condition can be used as an alternative to
     the `setup' option.  The only difference is that failure of a
     condition skips the test and is considered an error when using the
     `setup' option.  GOAL should be a callable.

`nondet'
     Available for individual test rules only.  Unless this keyword
     appears in the option list, nondeterminate success of the
     test-body is considered an error.

`forall(GENERATOR)'
     Available for individual test rules only.  Runs the same test for
     each solution of GENERATOR. Each run invokes the `setup' and
     `cleanup' handlers. This can be used to run the same test with
     different inputs.  If an error occurs, the test is reported as
     `name (forall bindings = VARS)', where VARS indicates the bindings
     of variables in GENERATOR, which should be a callable.

`setup(GOAL)'
     GOAL is run before the test-body.  Typically used together with
     the `cleanup' option to create and destroy the required execution
     environment.  GOAL should be a callable.

`cleanup(GOAL)'
     GOAL is always called after completion of the test-body,
     regardless of whether it fails, succeeds or raises an exception.
     This option or call_cleanup/2 must be used by tests that require
     side-effects that must be reverted after the test completes.  GOAL
     may share variables with a setup option and should be a callable:

     :- use_module(library(file_systems)).

     create_file(Tmp) :-
             open(temp(plunit), write, Out, [if_exists(generate_unique_name)]),
             current_stream(Tmp, write, Out),
             portray_clause(Out, hello(_World)),
             close(Out).

     test(read, [setup(create_file(Tmp)), cleanup(delete_file(Tmp))]) :-
             see(Tmp),
             read(Term),
             seen,
             Term = hello(_).

   The following options specify how to verify the result of the
test-body, and are only available for individual test rules. It is not
meaningful to specify more than one of them:

`true'
`true(TEST)'
     The test-body as well as the goal TEST must succeed.  TEST
     defaults to `true' and should be a callable that typically shares
     variables with the test-body. This is the same as inserting the
     test at the end of the conjunction, but makes the test harness
     print a "wrong answer" message as opposed to a general failure
     message:

          test(badadd, [true(A =:= 4)]) :-
                  A is 1 + 2.

     will yield the error message:

          ! /home/matsc/sicstus4/doc/foo.pl:11:
          !       test badadd: wrong answer (compared using =:=)
          !     Expected: 4
          !     Got:      3

`all(ANSWERTERM CMP INSTANCES)'
     Similar to `true(ANSWERTERM CMP INSTANCES)', but used if you want
     to collect all solutions to a nondeterminate test.  ANSWERTERM
     should share variables with the test-body.  Let ALL be the list of
     instances of ANSWERTERM for each solution.  Then the goal
     `CMP(ALL,INSTANCES)' must succeed.  The tests in the example below
     are equivalent:

          test(all1, all(X == [1,2])) :-
                  (X = 1 ; X = 2).

          test(all2, true(Xs == [1,2])) :-
                  findall(X, (X = 1 ; X = 2), Xs).

`set(ANSWERTERM CMP INSTANCES)'
     Similar to `all(ANSWERTERM CMP INSTANCES)', but sorts the
     ANSWERTERM instances before the comparison.  The tests in the
     example below are equivalent:

          test(set1, set(X == [1,2])) :-
                  (X = 2 ; X = 1 ; X = 1).

          test(set2, true(Ys == [1,2])) :-
                  findall(X, (X = 2 ; X = 1 ; X = 1), Xs),
                  sort(Xs, Ys).

`fail'
     The test-body must fail.

`exception(EXPECTED)'
`throws(EXPECTED)'
     The test-body must raise an exception RAISED that is checked wrt.
     EXPECTED using `terms:subsumeschk(EXPECTED, RAISED)'.  I.e. the
     raised exception must be more specific than the specified EXPECTED.

`error(ISO)'
`error(ISO,INFO)'
     A shorthand for `exception(error(ISO,INFO))'.  INFO defaults to an
     anonymous variable.

10.26.3 Writing the Test-Body
-----------------------------

* Menu:

* PlUnit Determinate Tests:: Determinate Tests
* PlUnit Nondeterminate Tests:: Nondeterminate Tests
* PlUnit Tests Expected to Fail:: Tests Expected to Fail
* PlUnit Tests Expected to Raise Exceptions:: Tests Expected to Raise Exceptions

   The test-body is ordinary Prolog code. Without any options, the
test-body must be designed to succeed _determinately_. Any other result
is considered a failure. One of the options `fail', `true', `exception'
or `error' can be used to specify a different expected result. In this
subsection we illustrate typical test-scenarios by testing built-in and
library predicates.


File: sicstus.info,  Node: PlUnit Determinate Tests,  Next: PlUnit Nondeterminate Tests,  Up: PlUnit A Unit Test Box

10.26.3.1 Determinate Tests
...........................

Determinate tests are tests that must succeed exactly once, leaving no
choicepoints behind. The test-body supplies proper values for the input
arguments and verifies the output arguments. Verification can use
test-options or be explicit in the test-body.  The tests in the example
below are equivalent.

     test(add1) :-
             A is 1 + 2,
             A =:= 3.

     test(add2, [true(A =:= 3)]) :-
             A is 1 + 2.

   The test engine verifies that the test-body does not leave a
choicepoint.  We illustrate this using the test below:

     test(member1) :-
             member(b, [a,b,c]).

   Although this test succeeds, `member/2' leaves a choicepoint behind,
which is reported by the test harness.  To make the test silent, use
one of the alternatives below.

     test(member2) :-
             memberchk(b, [a,b,c]).

     test(member3) :-
             member(b, [a,b,c]), !.

     test(member4, [nondet]) :-
             member(b, [a,b,c]).


File: sicstus.info,  Node: PlUnit Nondeterminate Tests,  Next: PlUnit Tests Expected to Fail,  Prev: PlUnit Determinate Tests,  Up: PlUnit A Unit Test Box

10.26.3.2 Nondeterminate Tests
..............................

Nondeterminate tests succeed zero or more times.  Their results can be
tested using `findall/3' followed by a representation-check.  The following are
equivalent tests:

     test(member5) :-
             findall(X, member(X, [a,b,c]), Xs),
             Xs == [a,b,c].

     test(member6, true(Xs == [a,b,c])) :-
             findall(X, member(X, [a,b,c]), Xs).


File: sicstus.info,  Node: PlUnit Tests Expected to Fail,  Next: PlUnit Tests Expected to Raise Exceptions,  Prev: PlUnit Nondeterminate Tests,  Up: PlUnit A Unit Test Box

10.26.3.3 Tests Expected to Fail
................................

Tests that are expected to fail may be specified using the option
`fail' or by negating the test-body using `\+'.

     test(is_set) :-
             \+ is_set([a,a]).

     test(is_set, [fail]) :-
             is_set([a,a]).


File: sicstus.info,  Node: PlUnit Tests Expected to Raise Exceptions,  Prev: PlUnit Tests Expected to Fail,  Up: PlUnit A Unit Test Box

10.26.3.4 Tests Expected to Raise Exceptions
............................................

Tests that are expected to raise exceptions may be specified using the
option `exception(EXPECTED)' or one of its equivalents, or by wrapping
the test in `on_exception/3' or `catch/3'.  The following tests are
equivalent:

     :- use_module(library(terms)).
     test(div01) :-
          on_exception(Excp, A is 1/0, true),
          subsumeschk(error(evaluation_error(zero_divisor),_), Excp).

     test(div02, [error(evaluation_error(zero_divisor))]) :-
          A is 1/0.

     test(div03, [error(evaluation_error(zero_divisor),_)]) :-
          A is 1/0.

     test(div04, [exception(error(evaluation_error(zero_divisor),_))]) :-
          A is 1/0.

     test(div05, [throws(error(evaluation_error(zero_divisor),_))]) :-
          A is 1/0.


File: sicstus.info,  Node: PlUnit Running the Test-Suite,  Next: PlUnit Tests and Production Systems,  Prev: PlUnit A Unit Test Box,  Up: lib-plunit

10.26.4 Running the Test-Suite
------------------------------

At any time, the tests can be executed by loading the program and
running `run_tests/[0,1,2]':

`run_tests'
     Run all individual tests of all test-units.

`run_tests(SPEC)'
`run_tests(SPEC,OPTIONS)'
     Run only the specified tests.  The options `quiet' and `verbose'
     (the default) are available; see below.  SPEC should be one of:

        * a term UNIT where UNIT is the name of a test-unit, denotes
          all individual tests of the test-unit UNIT, or

        * a term UNIT:TEST where UNIT is the name of a test-unit and
          TEST is one of its individual tests, denotes the given test
          only, or

        * a term UNIT:LIST where UNIT is the name of a test-unit and
          LIST is a list of its individual tests, denotes the given
          list of tests, or

        * finally, a list of terms of one of the above forms.

   Running single tests is particularly useful for tracing a test, e.g.:

     | ?- trace, run_tests(lists:member).

   `run_tests/[0,1,2]' prints a report during execution.  The `quiet'
options suppresses informational messages; in its absence, messages are
printed in full as follows.

   First, each test-unit report begins with a header:

     `% PL-Unit: UNIT'

   Then comes a message (success or failure) for all specified tests not
marked as `blocked' or `fixme'.  Success messages are informational;
others are error or warning messages. Any errors encountered while
executing options are also reported.  To close the test-unit, a footer
is printed:

     `% done'

   After all test-units, a summary report is printed, stating:

   * how many tests passed resp. failed

   * which tests were blocked

   * details for each test marked as `fixme'


File: sicstus.info,  Node: PlUnit Tests and Production Systems,  Prev: PlUnit Running the Test-Suite,  Up: lib-plunit

10.26.5 Tests and Production Systems
------------------------------------

Most applications don't want the test-suite to end up in the final
application.  There are several ways to achieve this.  One way is to
place all tests in separate files and not to load the tests when
creating the production environment.  Another way is to wrap each unit
test box in a pair of `:- if(...)', `:- endif' directives.  For
example, the test could be whether the `plunit' module has been loaded:

     :- if(current_module(plunit)).
     :- begin_tests(UNIT[,OPTIONS]).
     ...
     :- end_tests(UNIT).
     :- endif.

   Alternatively, you can reserve a system property e.g.
`enable_unit_tests' to control whether unit tests should be enabled.
The property is enabled if you run SICStus Prolog as:

     % sicstus -Denable_unit_tests=true

   Then your Prolog source file could have the structure:

     :- use_module(library(system), [environ/2]).

     ...

     :- if(environ(enable_unit_tests, true)).
     :- use_module(library(plunit)).
     :- begin_tests(UNIT[,OPTIONS])
     ...
     :- end_tests(UNIT)
     :- endif.


File: sicstus.info,  Node: lib-process,  Next: lib-prologbeans,  Prev: lib-plunit,  Up: The Prolog Library

10.27 Process Utilities--`library(process)'
===========================================

This package contains utilities for process creation.

   A process is represented by a "process reference", a ground compound
term. Both SICStus and the operating system maintain a state for each
such process reference and they must therefore be released, either
explicitly with `process_release/1' or implicitly by
`process_wait/[2,3]'. Process references are created with
`process_create/[2,3]' if explicitly requested with the `process/1'
option. Process references are required in order to obtain the exit
status of a process after `process_create/[2,3]' has returned.

   Many of the predicates can accept a numeric operating system process
id ("PID") but since process ids are subject to re-use by the OS this
is less reliable and does not work if the process has already exited.

10.27.1 Examples
----------------

The following illustrates some common tasks.  The process library is
portable and works on all supported platforms, including UNIX, Linux
and Windows.  However, the examples are by necessity platform dependent.
Unless otherwise noted, the examples will work on UNIX and similar
systems only.

   (If you are looking for something like the old SICStus 3
`system:system/1' and `system:popen/3', *Note unsafe_system::.)

  1. Run the `date' command in the standard shell `sh'.  The output of
     the command is sent to the terminal:
          | ?- process_create(path(sh),
               ['-c', date]).

  2. Run the `date' command in the standard shell `sh'.  Wait for the
     command to terminate before returning to Prolog.  Fail if the
     process gets an error.  The output of the command is sent to the
     terminal:
          | ?- process_create(path(sh),
               ['-c', date], [wait(exit(0))]).
     Using `wait/1' option in this way is a convenient way to ensure
     that the command has finished before Prolog continues.

  3. Run the `date' command in the standard shell `sh'.  The output of
     the command is received by Prolog:
          | ?- process_create(path(sh),
               ['-c', date], [stdout(pipe(S))]),
               read_line(S,L), close(S), atom_codes(Date,L).
          ...,
          Date = 'Fri Jan 24 12:59:26 CET 2014' ?

  4. Pipe the output of the `date' command to a file:
          | ?- process_create(path(sh),
               ['-c', [date, '>', file('/tmp/foo.txt')]]).

  5. Count the number of words in an atom, using the `wc' command:
          | ?- process_create(path(wc), ['-w'],
               [stdin(pipe(In)), stdout(pipe(Out))]),
               write(In, 'a b c\n'), close(In),
               read_line(Out, L), close(Out), number_codes(N, L).
          ...
          N = 3
     It may be preferable to let the input or output go via a file.
     This avoids deadlock in case the stream buffers fill up.

  6. Count the number of unique words in a file, piping the output of
     the `uniq' command to the `wc' command:
          | ?- process_create(path(sh),
               ['-c', ['uniq ', file('/tmp/foo.txt'), ' | wc -w']],
               [stdout(pipe(Out))]),
               read_line(Out, L), close(Out), number_codes(N, L).
          ...
          N = 6
     Note that quoting is a problem (and potential security issue), so
     *never* pass untrusted data, like file names, to the shell using
     `-c' (*note Quoting and Security::).

  7. Run the `make' command with the `-n' (dry run) option, discarding
     output, fail if it does not succeed:
          | ?- process_create(path(make), ['-n'],
               [stdout(null), wait(Exit)]),
               Exit = exit(0).
     By using the `wait/1' option, `process_create/3' will not return
     until the subprocess has exited and its exit status is available.

  8. Run `ls' on a home directory in a subshell using the user's
     preferred shell:
          | ?- process_create('$SHELL', ['-c', [ls, ' ', file('~/') ]]).

  9. Run a command with output piped from a file and input provided by
     Prolog.  This is similar to `popen('cat > ./myscript.sh',write,S)'
     in SICStus 3.  This example also shows one way to create a shell
     script which is useful when more advanced shell interaction is
     needed.  (The created script outputs the most common line in its
     input.  It is used in the next example.)
          | ?- process_create(path(sh),
               ['-c',
               'cat > ./myscript.sh && chmod a+x ./myscript.sh'],
               [stdin(pipe(S))]),
               write(S, '#! /bin/sh\n'),
               write(S, 'sort | uniq -c | sort -nr | head -n 1\n'),
               close(S).
     Please read *note Quoting and Security:: for problems with this
     approach.

 10. Run a shell script with input piped from a file and output read by
     Prolog.  This is similar to `popen('./myscript.sh <
     ./somefile.txt',read,S)' in SICStus 3.
          | ?- open('somefile.txt',write,OF),
               write(OF,'hello\nworld\nhello\nhello\n'),close(OF),
               process_create(path(sh),
               ['-c', './myscript.sh < ./somefile.txt'],
               read_line(S, L), atom_codes(Line, L), close(S).
          ...,
          Line = '   3 hello' ?
     Please read *note Quoting and Security:: for problems with this
     approach.

 11. Run a goal in a SICStus subprocess (UNIX and Windows):
          | ?- process_create(application(sicstus),
               ['-f', '--noinfo', '--nologo',
               '--goal', 'read(X), call(X), halt.'],
               [stdin(pipe(In)), stdout(pipe(Out))]),
               format(In,'~q .~n', [(length([h,e,l,l,o], Len),
                                     format('~q .~n', [Len]))]),
               close(In), read(Out,Answer), close(Out).
          ...,
          Answer = 5

 12. Run `notepad.exe' on a file `C:/foo.txt' under Windows:
          | ?- process_create('$SYSTEMROOT/notepad.exe',
               [file('C:/foo.txt')]).

 13. Open a command shell in a separate window under Windows:
          | ?- process_create('$COMSPEC',[],[window(true)]).

10.27.1.1 Microsoft Windows Shell
.................................

On Windows, it is not possible to pass multiple parameters to a
subprocess.  When a subprocess is started, it receives exactly one
argument and a quoting convention must be used to encode the parameters
as the single argument actually passed to the process.

   Unfortunately, there is no such universal quoting convention, every
program can interpret its (single) argument in any way it sees fit.

   Most programs use a convention established by the Microsoft C
library.  This is the convention used by `process_create/[2,3]' and it
usually works well.

   However, the command processor on Windows (`cmd.exe') does not use
the common convention and, except for very simple cases, passing
arguments to `cmd.exe' will not work reliably.

   *Please note*: Passing arguments to `cmd.exe' suffers from the same
security vulnerabilities as those described in *note Quoting and
Security::, below.

   If you want to run commands using `cmd.exe', it is best to create a
batch (`.bat') file with your commands and then tell `cmd.exe' to run
the batch file.

   The following example illustrates how to create a Windows batch file
that pipes some output to a file (`COMSPEC' is an environment variable
containing the path to `cmd.exe'):
     | ?- BatFileName='test.bat',
          open(BatFileName, write, S),
          write(S, 'date /T > "result.txt"\n'), close(S),
          process_create('$COMSPEC', ['/Q', '/C', file(BatFileName)],
          [wait(exit(0))]),
          open('result.txt', read, R),
          read_line(R,L),close(R),atom_codes(Date,L).
     ...,
     Date = '2014-01-27 ',
     ... ?

   More recent versions of Windows come with a redesigned command line
processor, `PowerShell', which solves the problems associated with the
traditional `cmd.exe' command line processor.  In particular, it has a
very general way to encode command line arguments, using `base-64'
encoding.  Currently, there is no direct support for PowerShell in this
library, but the following example shows how to get the current week
day both using a plain text command and with a base-64-encoded command

     | ?- Command = '(get-date).DayOfWeek',
          process_create(path(powershell),
          ['-Command', Command],
          [stdout(pipe(S))]),
          read_line(S,L),atom_codes(Day,L).
     ...,
     Day = 'Monday',
     ... ?

     | ?- EncodedCommand =
            'KABnAGUAdAAtAGQAYQB0AGUAKQAuAEQAYQB5AE8AZgBXAGUAZQBrAA==',
          process_create(path(powershell),
          ['-encodedCommand', EncodedCommand],
          [stdout(pipe(S))]),
          read_line(S,L),atom_codes(Day,L).
     ...,
     Day = 'Monday',
     ... ?
where the ENCODEDCOMMAND representation was created by encoding the string
`'(get-date).DayOfWeek'' using Base 64. See the PowerShell
documentation for details.

10.27.2 Quoting and Security
----------------------------

It easy to get undesired, and possibly harmful, effects if arbitrary
data is passed without proper quoting to a shell.  For instance,
accepting arbitrary file names and passing them as part of a command
line to a subshell can cause the shell to execute arbitrary, possibly
malicious, code.

   The following, vulnerable, predicates suffer from this problem.
They are similar to predicates that existed in SICStus 3, and their
fragility is one of the reasons process interaction was redesigned in
SICStus 4.
     % DO NOT USE. This code is vulnerable.
     % Similar to system:system/1 in SICStus 3.
     unsafe_system(Cmd) :-
        % pass Cmd to shell, wait for exit, fail on error.
        process_create(path(sh), ['-c', Cmd], [wait(exit(0))]).

     % DO NOT USE. This code is vulnerable.
     % Similar to system:popen/3 in SICStus 3.
     unsafe_popen(Cmd, Direction, Pipe) :-
        % pass Cmd to shell, do not wait for exit,
        % connect to stdin or stdout of subprocess.
        ( Direction == read ->
          process_create(path(sh), ['-c', Cmd], [stdout(pipe(Pipe))])
        ; Direction == write ->
          process_create(path(sh), ['-c', Cmd], [stdin(pipe(Pipe))])
        ).

   Now consider the task of passing the contents of some file FILE to a
command `mycommand'.  You may think the following is a good idea (it is
not!):

     % DO NOT USE. This code is vulnerable.
     unsafe_command(File, S) :-
        atom_concat('./mycommand < ', File, Cmd),
        unsafe_popen(Cmd, read, S).

   That works as expected if the the `File' argument is a plain file
with no characters that has special meaning to the shell, e.g.
     File = './somefile.txt',
     unsafe_command(File, S), read_line(S,L),close(S).

   However, assume that the file name was obtained from some untrusted
source and consider the following example:
     File = '$(say bohoo)',
     unsafe_command(File, S), read_line(S,L),close(S).
depending on the system this can have a quite scary effect, and
illustrates how shell meta characters in the constructed command line
can lead to potentially dangerous results.

   The safest way to interact with the shell is to create shell scripts
and pass arguments to the scripts as separate arguments to the shell.
E.g.
     % A safer version
     safer_command(File, S) :-
        % pass the file as the first argument to mycommand.
        process_create(path(sh),
                       ['-c', file('./mycommand'), file(File)],
                       [stdout(pipe(S))]).
Exported predicates:

`process_create(+FILE, +ARGS)'
`process_create(+FILE, +ARGS, :OPTIONS)'
     Start a new process running the program identified by FILE and the
     arguments specified in ARGS. The standard streams of the new
     process can be redirected to prolog streams. The exit status of
     the process can be obtained with `process_wait/[2,3]'.

     FILE, is expanded as if by `absolute_file_name/2' (with arguments
     `access(execute)' and `file_type(executable)') and is used to
     locate the file to execute.

     The predefined file search path `path/1' (*note ref-fdi::) is
     especially useful here since it makes it easy to look up the names
     of an executable in the directories mentioned by the `PATH'
     environment variable. To run the Windows command shell `cmd' you
     would simply specify `path('cmd.exe')' (or `path(cmd)'), to start
     the UNIX Bash shell you would specify `path(bash)'.

     ARGS is a list of argument specifications. Each argument
     specification is either a simple argument specification, see
     below, or a non-empty list of simple argument specifications. The
     expanded representation of each element of ARGS is concatenated to produce
     a single argument to the new process. A "simple argument
     specification" can be one of:

    an atom
          The atom name is used as the expanded representation. Some operating
          systems only support 7-bit ASCII characters here. Even when
          some larger subset of Unicode is used it may not work
          correctly with all programs.

    `file(FILE)'
          FILE, an atom, is treated as a file name and subject to an
          operating system specific transformation to ensure file name
          syntax and character set is appropriate for the new process.
          This is especially important under Windows where it ensures
          that the full Windows Unicode character set can be used.

          *Please note*: The FILE part of `file(FILE)' is not subject
          to syntactic rewriting, the argument specification `file/1'
          only adjusts for differences in file name syntax and character
          encoding between SICStus and the operating system. You must
          explicitly call `absolute_file_name/[2,3]' if you want to
          expand file search paths etc.

     OPTIONS is a list of options:

    `stdin(SPEC)'
    `stdout(SPEC)'
    `stderr(SPEC)'
          Each SPEC specifies how the corresponding standard stream of
          the new process should be created. SPEC can be one of:
         `std'
               The new process shares the (OS level) standard stream
               with the Prolog process. This is the default.  Note
               that, especially under Windows, the Prolog process may
               not have any OS level standard streams, or the OS
               streams may not be connected to a console or terminal.
               In such a case you need to use `pipe/1' spec, see below,
               and explicitly read (write) data from (to) the process.

         `null'
               The stream is redirected to a null stream, i.e. a stream
               that discards written data and that is always at end of
               file when read.

         `pipe(STREAM)'
               A new Prolog (text) stream is created and connected to
               the corresponding stream of the new process. It is
               currently not possible to request binary streams or to
               specify a character set different from the OS default.
               This stream must be closed using `close/[1,2]', it is not
               closed automatically when the new process exits.

    `wait(-EXITSTATUS)   *since release 4.3*'
          The call will not return until the sub-process has terminated.
          EXITSTATUS will be bound to the exit status of the process,
          as described for `process_wait/2'.

    `process(PROC)'
          PROC will be bound to a process reference that can be used in
          calls to `process_wait/[2,3]' etc.. This process reference
          must be released, either explicitly with `process_release/1'
          or implicitly by `process_wait/[2,3]'.  It is often easier to
          use the `wait/1' option if you just want to wait for the
          process to terminate.

    `detached(BOOL)'
          BOOL is either `true' or `false'. Specifies whether the new
          process should be "detached", i.e. whether it should be
          notified of terminal events such as `^C' interrupts. By
          default a new process is created detached if none of the
          standard streams are specified, explicitly or implicitly, as
          `std'.

    `cwd(CWD)'
          CWD is expanded as if by `absolute_file_name/2' and is used
          as the working directory for the new process.

          By default, the working directory is the same as the Prolog
          working directory.

    `window(BOOL)'
          BOOL is either `true' or `false' (the default). Specifies
          whether the process should open in its own window.

          Specifying `window(true)' may give unexpected results if the
          standard stream options `stdin/1', `stdout/1' and `stderr/1'
          are specified with anything but their default representation `std'.

          Currently only implemented on Windows.

    `environment(ENV)   *since release 4.1*'
          ENV is a list of `VAR=VALUE' for extra environment variables
          to pass to the sub-process in addition to the default process
          environment.  VAR should be an atom.  VALUE should be an
          argument specification, as described above. The VALUE is
          typically an atom but, especially on the Windows platform, it
          may be necessary to wrap file names in `file/1' to ensure
          file paths are converted to the native format.  *Note System
          Properties and Environment Variables: (sicstus)System
          Properties and Environment Variables, for more information.


`process_wait(+PROCESS, -EXITSTATUS)'
`process_wait(+PROCESS, -EXITSTATUS, +OPTIONS)'
     Wait for a process to exit and obtain the exit status.

     PROCESS is either a process reference obtained from
     `process_create/3' or an OS process identifier. Specifying a
     process identifier is not reliable. The process identifier may
     have been re-used by the operating system. Under Windows, it is not
     possible to obtain the exit status using a process identifier if
     the process has already exited.

     EXITSTATUS is one of:
    `exit(EXITCODE)'
          The process has exited with exit code EXITCODE. By convention
          processes use exit code zero to signify success and a
          (positive) non-zero representation to specify failure.

    `killed(SIGNALNUMBER)'
          UNIX only, the process was killed by signal `SignalNumber' (a
          positive integer).

    `timeout'
          The `timeout/1' option was specified and the process did not
          exit within the specified interval. In this case the process
          reference is not released, even if the `release/1' option is
          specified.
     OPTIONS is a list of options:
    `timeout(SECONDS)'
          Specify a maximum time, in seconds, to wait for the process to
          terminate. SECONDS should be an integer or floating point
          number or the atom `infinite' (the default) to specify
          infinite wait. If the specified timeout interval passes
          before the process exits, `process_wait/3' exits with
          EXITSTATUS set to `timeout' and the process reference is not
          released.

          Currently the UNIX implementation supports only timeout values
          0 (zero) and `infinite'.

    `release(BOOL)'
          BOOL is either `true' (the default) or `false'. Specifies
          whether the process reference should be released when
          `process_wait/3' exits successfully.

`process_id(-PID)'
     Obtain the process identifier of the current (i.e. Prolog) process.

`process_id(+PROCESS, -PID)'
     Obtain the process identifier of the process reference PROCESS.

`is_process(+THING)'
     Returns true if THING is a process reference that has not been
     released.

`process_release(+PROCESS)'
     Release a process reference PROCESS that has previously been
     obtained from `process_create/3'. This ensures that Prolog and the
     operating system can reclaim any resources associated with the
     process reference.

     Usually you would not call this. Either do not request the process
     reference when calling `process_create/3' or let
     `process_wait/[2,3]' reclaim the process reference when the
     process terminates.

`process_kill(+PROCESS)'
`process_kill(+PROCESS, +SIGNALSPEC)'
     Send a signal to the process designated by PROCESS. The signal can
     either be a non-negative integer or a signal name as an (all
     uppercase) atom.

     The following signal names are accepted under UNIX if the platform
     defines them: `SIGABRT', `SIGALRM', `SIGBUS', `SIGCHLD',
     `SIGCONT', `SIGFPE', `SIGHUP', `SIGILL', `SIGINT', `SIGKILL' (the
     default), `SIGPIPE', `SIGPOLL', `SIGPROF', `SIGQUIT', `SIGSEGV',
     `SIGSTOP', `SIGSYS', `SIGTERM', `SIGTRAP', `SIGTSTP', `SIGTTIN',
     `SIGTTOU', `SIGURG', `SIGUSR1', `SIGUSR2', `SIGVTALRM', `SIGXCPU'
     and `SIGXFSZ'. However, many of these do not make sense to send as
     signals.

     Under Windows, which does not have the signal concept, the signal
     name `SIGKILL' (the default) is treated specially and terminates
     the process with `TerminateProcess(Process, -1)'.  *Please note*:
     Using `process_kill/[2,3]' on Windows is not recommended. Also, on
     Windows, the call may throw an error if the process has already
     exited.



File: sicstus.info,  Node: lib-prologbeans,  Next: lib-queues,  Prev: lib-process,  Up: The Prolog Library

10.28 PrologBeans Interface--`library(prologbeans)'
===================================================

* Menu:

* PB Intro:: Introduction
* PB Features:: Features
* PB First Example:: A First Example
* PB Prolog Server Interface:: Prolog Server Interface
* PB Java Client Interface:: Java Client Interface
* PB Java Examples:: Java Examples
* PB .NET Client Interface:: .NET Client Interface
* PB .NET Examples:: .NET Examples


File: sicstus.info,  Node: PB Intro,  Next: PB Features,  Up: lib-prologbeans

10.28.1 Introduction
--------------------

PrologBeans is a package for integrating Prolog with applications
written in other languages. Currently Java and .NET are supported.
PrologBeans is based on running Prolog as a separate server process,
and the other part of the application as a client process.  This makes
PrologBeans automatically distributable since the server and the client
can run on different computers anywhere on the Internet.

   PrologBeans is designed to be used when client applications need to
send queries to a Prolog server (and less intended for showing a GUI
from a Prolog program). One typical application would be to connect a
Java or .NET based web application to a Prolog server (see examples
later).

 [image src="images/prologbeansarch.png" text="" ] _PrologBeans
setup where the Prolog application serves several users accessing both
via a web application server and a .NET GUI._

   The PrologBeans package consists of two parts. The Prolog server is a
library module, `library(prologbeans)'. The client is a class library,
`prologbeans.jar' for Java and `prologbeans.dll' for .NET (MS Windows
only).


File: sicstus.info,  Node: PB Features,  Next: PB First Example,  Prev: PB Intro,  Up: lib-prologbeans

10.28.2 Features
----------------

The current version of PrologBeans is designed to be used mainly as a
connection from the client (Java or .NET) to Prolog.  Current features
are:

   * Socket based communication [Java and .NET]

   * Allows the client application and Prolog server to run on
     different machines [Java and .NET]

   * Multiple client applications can connect to same Prolog server
     [Java and .NET]

   * Client applications can make use of several Prolog servers [Java
     and .NET]

   * Allows Java Applets to access Prolog server [Java]

   * Platform independent (e.g. any platform where Prolog and Java or
     .NET exist) [Java and .NET]

   * Simplifies the use of Prolog in Java application servers (Tomcat,
     etc) [Java]

   * Prohibits unwanted use of Prolog server by host control (only
     specified hosts can access the Prolog server) [Java and .NET]

   * Supports Java servlet sessions [Java] 

   * Supports JNDI lookup (Java Naming and Directory Interface) [Java] 

   * Supports .NET server pages (ASPX). [.NET] 


File: sicstus.info,  Node: PB First Example,  Next: PB Prolog Server Interface,  Prev: PB Features,  Up: lib-prologbeans

10.28.3 A First Example
-----------------------

This section provides an example to illustrate how PrologBeans can be
used. This application has a simple Java GUI where the user can enter
expressions that will be evaluated by an expression evaluation server.

     import java.awt.*;
     import java.awt.event.*;
     import javax.swing.*;
     import se.sics.prologbeans.*;

     public class EvaluateGUI implements ActionListener {

       private JTextArea text = new JTextArea(20, 40);
       private JTextField input = new JTextField(36);
       private JButton evaluate = new JButton("Evaluate");
       private PrologSession session = new PrologSession();

       public EvaluateGUI() throws java.io.IOException
         {
         if ((Integer.getInteger("se.sics.prologbeans.debug", 0)).intValue() != 0) {
     	  session.setTimeout(0);
           }
         JFrame frame = new JFrame("Prolog Evaluator");
         Container panel = frame.getContentPane();
         panel.add(new JScrollPane(text), BorderLayout.CENTER);
         JPanel inputPanel = new JPanel(new BorderLayout());
         inputPanel.add(input, BorderLayout.CENTER);
         inputPanel.add(evaluate, BorderLayout.EAST);
         panel.add(inputPanel, BorderLayout. SOUTH);
         text.setEditable(false);
         evaluate.addActionListener(this);
         input.addActionListener(this);

         frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
         frame.pack();
         frame.setVisible(true);

         session.connect();
       }

       public void actionPerformed(ActionEvent event) {
         try {
           Bindings bindings = new Bindings().bind("E",
                               input.getText() + '.');
           QueryAnswer answer =
             session.executeQuery("evaluate(E,R)", bindings);
           PBTerm result = answer.getValue("R");
           if (result != null) {
             text.append(input.getText() + " = " + result + '\n');
             input.setText("");
           } else {
             text.append("Error: " + answer.getError() + '\n');
           }
         } catch (Exception e) {
           text.append("Error when querying Prolog Server: " +
                       e.getMessage() + '\n');
           e.printStackTrace();
         }
       }

       public static void main(String[] args) throws java.io.IOException
       {
         new EvaluateGUI();
       }
     }

   The Java code above first sets up the GUI with a text area for
showing results, a text field for entering expressions, and a button for
requesting an evaluation (the constructor `EvaluateGUI()'). It will
also add itself as `ActionListener' on both the text field and the
button. The method `actionPerformed(ActionEvent event)' will be called
whenever the user has pressed <RET> or clicked on the button.
`actionPerformed' first binds the variable E to the representation of the text
field, and then sends the query to the Prolog server with
`session.executeQuery("evaluate(E,R)", bindings);'. If everything goes
well, the Prolog server will return an answer (bound to R), which will
be appended to the text area.

     :- module(evaluate,[main/0,my_predicate/2]).
     :- use_module(library(prologbeans)).
     :- use_module(library(codesio), [read_from_codes/2]).

     %% Register acceptable queries and start the server (using default port)
     main:-
         register_query(evaluate(C,P), my_predicate(C,P)),
         start.

     %% We have received a code-list
     %% which needs to be converted into an expression
     my_predicate(Chars, P) :-
         read_from_codes(Chars, X),
         P is X.

   The Prolog code above first defines the module and imports the needed
modules. Then, in the `main/0' predicate, it configures the server to
answer queries on the form `evaluate(C,P)' and starts the server. The
last few lines defines the predicate `my_predicate(Chars, P)', which is
the predicate that performs the evaluation. Note that, here, the
expression to evaluate is represented as a code-list and must be
converted into a term before evaluation.

   In general, arbitrary Prolog terms can be passed to the client via
this mechanism, including terms containing unbound variables.  However,
any unbound variables with attributes or blocked goals attached to them
will be replaced by plain, brand new variables. This is analogous to
the way attributed variables are handled in terms that are written,
copied, asserted, gathered as solutions to `findall/3' and friends, or
raised as exceptions. If the attributes must be passed to the client,
the Prolog code can obtain them by using `copy_term/3' (*note
ref-lte-cpt::).

   *Please note*: the environment variable `SP_PATH' as used here is
meant to be a shorthand (*note CPL Notes::), and does not need to be
set explicitly.

   To start the example, first start the Prolog server by going to the
`%SP_PATH%\library\prologbeans\examples\evaluate' (Windows), or
`$SP_PATH/library/prologbeans/examples/evaluate' (UNIX/Linux) directory
and type:

     % sicstus -l EVALUATE.PL --goal "main."

   To start the GUI type (from the same directory as above):

     > java -classpath "%SP_PATH%\bin\prologbeans.jar;." EvaluateGUI (Windows), or
     % java -classpath "$SP_PATH/bin/prologbeans.jar:." EvaluateGUI (UNIX)


File: sicstus.info,  Node: PB Prolog Server Interface,  Next: PB Java Client Interface,  Prev: PB First Example,  Up: lib-prologbeans

10.28.4 Prolog Server Interface
-------------------------------

The Prolog interface is based on the idea of a Prolog server that
provides its service by answering queries from external applications
(typically Java applications). The Prolog interface in PrologBeans is
defined in `library(prologbeans)', which implements the Prolog server
and exports the following predicates:

`start'
`start(+OPTIONS)'
     starts the Prolog server using the options specified.  *Please
     note*: `start/[0,1]' will not return until a server shutdown
     occurs.  OPTIONS should be a list of zero or more of:

    `port(?VAL)'
          an integer denoting the port number of the Prolog server. The
          default port, if no port option is present, is 8066. In the
          case of the default port being used, the Socket Reuse Adress
          bit will be set in the underlying sockets layer. If `VAL' is
          a variable, some unused port will be selected by the OS, the
          actual port number can be obtained with
          `get_server_property/1', typically from a `server_started'
          event listener.

    `accepted_hosts(+VAL)'
          a list of atoms denoting the hosts (in form of IP-addresses)
          that are accepted by the Prolog server (default:
          `['127.0.0.1']').

    `session_timeout(+VAL)'
          an integer denoting the duration of a session in seconds. The
          session will be removed if it has been inactive more than
          this timeout when the session garbage collect starts. If the
          session timeout is set to zero there will be no garbage
          collect on sessions (default: `0').

    `session_gc_timeout(+VAL)'
          an integer denoting the minimum time in seconds between two
          consecutive session garbage collections. If the timeout is
          set to zero there will be no garbage collect on sessions
          (default: `0').

     For example:

          :- start([port(7500),
                    accepted_hosts(['127.0.0.1','99.8.7.6'])]).

`shutdown'
`shutdown(+Mode)'
     shuts down the server and closes the sockets and the streams after
     processing all available input. There are three modes:
    `now'
          as soon as possible (default).

    `no_sessions'
          after all sessions have ended (all sessions have either been
          explicitly removed by request of the client application, or
          they have been garbage collected). *Please note*: there can
          still be connections to the Prolog server even when all
          sessions have ended.

    `no_connections'
          after all connections to the Prolog server are closed.
          *Please note*: there can still be user sessions left when all
          connections have been closed.


`register_query(+QUERY, :PREDICATETOCALL)'
`register_query(+QUERY, :PREDICATETOCALL, +SESSIONVAR)'
     registers a query and the corresponding goal. Before the
     registration, any previously registered query matching QUERY will
     be removed (as if by `unregister_query(QUERY)').  The goal
     PREDICATETOCALL will be called when a query matching QUERY is
     received.

     Typically, QUERY and PREDICATETOCALL share variables that are
     instantiated by the call, and the instantiated QUERY is passed
     back to the client. In general, variable bindings can be arbitrary
     Prolog terms, including terms containing unbound variables.
     However, any unbound variables with attributes or blocked goals
     attached to them will be replaced by plain, brand new variables.
     This is analogous to the way attributed variables are handled in
     terms that are written, copied, asserted, gathered as solutions to
     `findall/3' and friends, or raised as exceptions. If the
     attributes must be passed to the client, the Prolog code can
     obtain them by using `copy_term/3' (*note ref-lte-cpt::).

     The goal is called determinately, i.e. it is never backtracked
     into.  If it fails, the term `no' is passed to the client instead
     of the instantiated QUERY.  If it raises an exception E, the term
     `error(E)' is passed to the client instead of the instantiated
     QUERY.

     Before calling the query, the variable SESSIONVAR, if given, is
     bound to the id of the current session. Session ids are typically
     generated in web applications that track users and mark all
     consecutive web-accesses with the same session id.

`unregister_query(+QUERY)'
     unregisters all queries matching QUERY.  

`session_get(+SESSIONID, +PARAMETERNAME, +DEFAULTVALUE, -VALUE)'
     returns the representation of a given parameter in a given session. If no
     representation exists, it will return the default representation.  Arguments:
    SESSIONID
          is the id of the session for which values have been stored

    PARAMETERNAME
          an atom, is the name of the parameter to retrieve

    DEFAULTVALUE
          is the representation that will be used if no representation is stored

    VALUE
          is the stored representation or the default representation if nothing was stored

`session_put(+SESSIONID, +PARAMETERNAME, +VALUE)'
     stores the representation of the given parameter. *Please note*: any
     pre-existing representation for this parameter will be overwritten. Note
     that `session_put/3' will not be undone when backtracking (the
     current implementation is based on `assert').  Arguments:

    SESSIONID
          is the id of the session for the values to store

    PARAMETERNAME
          an atom, is the name of the parameter to store

    VALUE
          the representation to be stored

`register_event_listener(+EVENT, :PREDICATETOCALL)'
`register_event_listener(+EVENT, :PREDICATETOCALL, -ID)'
     Registers `PREDICATETOCALL' to be called (as if by
     `once(PREDICATETOCALL)') when the event matching `EVENT' occurs
     (event matching is on principal functor only). If the goal fails or
     raises an exception a warning is written to `user_error' but the
     failure or exception is otherwise ignored. Arguments:

    EVENT
          is the event template; see below.

    PREDICATETOCALL
          an arbitrary goal.

    ID
          becomes bound to a (ground) term that can be used with
          `unregister_event_listener/1' to remove this event listener.

     The predefined events are as follows:

    `session_started(+SESSIONID)'
          called before the first call to a query for this session

    `session_ended(+SESSIONID)'
          called before the session is about to be garbage collected
          (removed)

    `server_started'
          called when the server is about to start (enter its main loop)

    `server_shutdown'
          called  when the server is about to shut down

     Attempt to register an event listener for other events than the
     predefined events will throw an exception.

     More than one listeners can be defined for the same event. They
     will be called in some unspecified order when the event occurs.

`unregister_event_listener(+ID)'
     Unregister a previously registered event listener. The ID is the
     representation returned by the corresponding call to
     `register_event_listener/3'. It is an error to attempt to
     unregister an event listener more than once.



File: sicstus.info,  Node: PB Java Client Interface,  Next: PB Java Examples,  Prev: PB Prolog Server Interface,  Up: lib-prologbeans

10.28.5 Java Client Interface
-----------------------------

The Java interface is centered around the class `PrologSession', which
represents a connection (or session) to a Prolog server.
`PrologSession' contains static methods for looking up named
`PrologSession' instances using JNDI (Java Naming and Directory
Interface) as well as methods for querying the Prolog server.  Other
important classes are: `QueryAnswer', which contains the answer for a
query sent to the Prolog server; `PBTerm', which represents a Prolog
term; and `Bindings', which supports stuffing of variable values used
in queries.

   General information about Java, Servlets and JNDI is available at the
Java Technology site: `http://java.sun.com/'

   A brief description of the provided Java classes are presented
below. More information about the Java APIs is available in the JavaDoc
files on the page `http://sicstus.sics.se/documentation.html'.

`PrologSession'
     The `PrologSession' object is the connection to the Prolog server.
     The constructor `PrologSession()' creates a `PrologSession' with
     the default settings (`host = localhost, port = 8066'.

`QueryAnswer'
     The `QueryAnswer' contains the answer (new bindings) for a query
     (or the error that occurred during the query process).

`PBTerm'
     The `PBTerm' object is for representing parsed Prolog terms.

`Bindings'
     `Bindings' is used for binding variables to values in a query sent
     to the Prolog. The values will be automatically stuffed before
     they are sent to the Prolog server.



File: sicstus.info,  Node: PB Java Examples,  Next: PB .NET Client Interface,  Prev: PB Java Client Interface,  Up: lib-prologbeans

10.28.6 Java Examples
---------------------

* Menu:

* PB Ex Embedding:: Embedding Prolog in Java Applications
* PB Ex Servers:: Application Servers
* PB Ex Tomcat:: Configuring Tomcat for PrologBeans

   The PrologBeans examples for Java can be found in the directory
corresponding to the file search path `pbexamples', defined as if by a
clause:

     user:file_search_path(pbexamples, library('prologbeans/examples')).


File: sicstus.info,  Node: PB Ex Embedding,  Next: PB Ex Servers,  Up: PB Java Examples

10.28.6.1 Embedding Prolog in Java Applications
...............................................

If you have an advanced Prolog application that needs a GUI you can
write a stand-alone Java application that handles the GUI and set up
the Prolog server to call the right predicates in the Prolog
application.

   An example of how to do this can be found under the
`pbexamples(evaluate)' directory (see the example code in *note PB
First Example::).

   Another example of this is `pbexamples(pbtest)', which illustrates
several advanced features like:
   * registering several queries

   * listening to server events (`server_started')

   * shutting down the Prolog server from Java

   * starting up the Prolog server from Java

   * using dynamic (OS assigned) ports for the Java/Prolog communication

   The example is run by executing the Java program `PBTest':
     > java -classpath "%SP_PATH%\bin\prologbeans.jar;." PBTest (Windows), or
     % java -classpath "$SP_PATH/bin/prologbeans.jar:." PBTest (UNIX)


File: sicstus.info,  Node: PB Ex Servers,  Next: PB Ex Tomcat,  Prev: PB Ex Embedding,  Up: PB Java Examples

10.28.6.2 Application Servers
.............................

If you want to get your Prolog application to be accessible from an
intranet or the Internet you can use this package to embed the Prolog
programs into a Java application server such as Tomcat, WebSphere, etc.

   An example of how to do this is provided in `pbexamples(sessionsum)'.
This example uses sessions to keep track of users so that the
application can hold a state for a user session (as in the example
below, remember the sum of all expressions evaluated in the session).

     <%@ page import = "se.sics.prologbeans.*" %>
     <html>
     <head><title>Sum Calculator</title></head>
     <body bgcolor="white">
     <font size=4>Prolog Sum Calculator, enter expression to evaluate:
     <form><input type=text name=query></form>
     <%
        PrologSession pSession =
        PrologSession.getPrologSession("prolog/PrologSession", session);
        pSession.connect();

        String evQuery = request.getParameter("query");
        String output = "";
        if (evQuery != null) {
          Bindings bindings = new Bindings().bind("E",evQuery + '.');
          QueryAnswer answer =
             pSession.executeQuery("sum(E,Sum,Average,Count)", bindings);
          PBTerm average = answer.getValue("Average");
          if (average != null) {
             PBTerm sum = answer.getValue("Sum");
             PBTerm count = answer.getValue("Count");

             output = "<h4>Average =" + average + ", Sum = "
             + sum + " Count = " + count + "</h4>";
          } else {
             output = "<h4>Error: " + answer.getError() + "</h4>";
          }
       }
     %>
     <%= output  %><br></font>
     <p><hr>Powered by SICStus Prolog
     </body></html>

   The example shows the code of a JSP (Java Server Page). It makes use
of the method `PrologSession.getPrologSession(String jndiName,
HTTPSession session)', which uses JNDI to look up a registered
`PrologSession', which is connected to the Prolog server. The variable
SESSION is in a JSP bound to the current `HTTPSession', and the
variable REQUEST is bound to the current `HTTPRequest'.  Since the
`HTTPSession' object `session' is specified all queries to the Prolog
server will contain a session id. The rest of the example shows how to
send a query and output the answer.

   Example usage of sessions (from the `sessionsum' example) is shown
below, and is from `pbexamples('sessionsum/sessionsum.pl')':

     :- module(sessionsum,[main/0,sum/5]).
     :- use_module(library(prologbeans)).
     :- use_module(library(codesio), [read_from_codes/2]).

     %% Register the acceptable queries (session based)
     main:-
         register_query(sum(C,Sum,Average,Count),
                        sum(C,Session,Sum,Average,Count),
                        Session),
         start.

     %% The sum predicate which gets the information from a session database,
     %% makes some updates and then stores it back in to the session store
     %% (and returns the information back to the application server)
     sum(ExprChars, Session, Sum, Average, Count) :-
         session_get(Session, sum, 0, OldSum),
         session_get(Session, count, 0, OldCount),
         read_from_codes(ExprChars, Expr),
         Val is Expr,
         Sum is OldSum + Val,
         Count is OldCount + 1,
         Average is Sum / Count,
         session_put(Session, sum, Sum),
         session_put(Session, count, Count).

   In this example a query `sum/4' is registered to call `sum/5' where
one of the variables, SESSION will be bound to the session id
associated to the query. The `sum/5' predicate uses the `session_get/4'
predicate to access stored information about the particular session,
and then it performs the evaluation of the expression. Finally, it
updates and stores the values for this session.


File: sicstus.info,  Node: PB Ex Tomcat,  Prev: PB Ex Servers,  Up: PB Java Examples

10.28.6.3 Configuring Tomcat for PrologBeans
............................................

This section will briefly describe how to set up a Tomcat server so
that is it possible to test the example JSPs. Some knowledge about how
to run Tomcat and how to set up your own web application is required.
Detailed information about Tomcat is available at
`http://jakarta.apache.org/tomcat/'.

   Assuming that the environment variable CATALINA_HOME is set to the
installation directory of Tomcat, do the following:

  1. Create the directory `$CATALINA_HOME/webapps/PB_example'

  2. Copy the file `pbexamples('sessionsum/sessionsum.jsp')' to
     `$CATALINA_HOME/webapps/PB_example/sessionsum.jsp'

  3. Create the directory
     `$CATALINA_HOME/webapps/PB_example/WEB-INF/lib'

  4. Copy the file `$SP_PATH/bin/prologbeans.jar' to
     `$CATALINA_HOME/webapps/PB_example/WEB-INF/lib/prologbeans.jar'

  5. Create the directory `$CATALINA_HOME/webapps/PB_example/META-INF'

  6. Create the file
     `$CATALINA_HOME/webapps/PB_example/META-INF/context.xml' with the
     following content:
          <Context docBase="PB_example">
             <Resource name="prolog/PrologSession" auth="Container"
                       type="se.sics.prologbeans.PrologSession"
          	     factory="org.apache.naming.factory.BeanFactory" />

          </Context>

  7. Create the file
     `$CATALINA_HOME/webapps/PB_example/WEB-INF/web.xml' with the
     following content:
          <?xml version="1.0" encoding="ISO-8859-1"?>
          <!DOCTYPE web-app
               PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
              "http://java.sun.com/dtd/web-app_2_3.dtd">
          <web-app>

              <resource-env-ref>
                <description>
                  Object factory for PrologSession instances.
                </description>
                <resource-env-ref-name>
                  prolog/PrologSession
                </resource-env-ref-name>
                <resource-env-ref-type>
                  se.sics.prologbeans.PrologSession
                </resource-env-ref-type>
              </resource-env-ref>

          </web-app>

  8. Start SICStus, load `sessionsum.pl' and run main.

  9. Start the Tomcat server.

 10. In a web browser, enter
     `http://localhost:8080/PB_example/sessionsum.jsp'



File: sicstus.info,  Node: PB .NET Client Interface,  Next: PB .NET Examples,  Prev: PB Java Examples,  Up: lib-prologbeans

10.28.7 .NET Client Interface
-----------------------------

The class `PrologSession' in the .NET interface represents a connection
to a Prolog server. `PrologSession' contains methods for establishing a
connection and querying the Prolog server. Other important classes are:
`QueryAnswer', which contains the answer for a query sent to the Prolog
server; `PBTerm', which represents a Prolog term; and `Bindings', which
supports stuffing of variable values used in queries.

   The `PrologSession' object is the connection to the Prolog server.
The constructor `PrologSession()' creates a `PrologSession' with the
default settings (`host = localhost, port = 8066'.

   Detailed documentation on the .NET APIs of PrologBeans is available
in the PrologBeans.NET documentation files on the page
`http://sicstus.sics.se/documentation.html' or locally at
`%SP_PATH%/doc/html/prologbeans.NET' (where `SP_PATH' is the path to
your SICStus Prolog installation directory).

   *Please note*: The current version of the PB .NET Client interface
is implemented using J#, a .NET language closely resembling Java. This
allows us to use the same source code for the .NET code as for Java. J#
is now obsolete and does not work well with the latest version of the
.NET framework (.NET 4). We plan to include a new version of the PB
.NET Client, written in C#, in a future version of SICStus Prolog.


File: sicstus.info,  Node: PB .NET Examples,  Prev: PB .NET Client Interface,  Up: lib-prologbeans

10.28.8 .NET Examples
---------------------

* Menu:

* PB C# Examples:: C# Examples
* PB VB Example:: Visual Basic Example

   The PrologBeans examples for .NET can be found in the directory
corresponding to the file search path `pbnetexamples', defined as if by
a clause:

     user:file_search_path(pbnetexamples, library('prologbeans.NET/examples')).


File: sicstus.info,  Node: PB C# Examples,  Next: PB VB Example,  Up: PB .NET Examples

10.28.8.1 C# Examples
.....................

_.NET Embedding._ If you have an advanced Prolog application that needs
a GUI you can write a stand-alone .NET application that handles the GUI
and set up the Prolog server to call the right predicates in the Prolog
application.

   An example of how to do this can be found under the
`pbnetexamples('evaluate.NET')' directory. This example is the C#
version of the example shown in *note PB First Example::).

   To start the example, first start the Prolog server by going to the
`pbnetexamples('evaluate.NET')' directory and type:

     > sicstus -l EVALUATE.PL --goal "main."

   To start the GUI type (from the same directory as above):

     > run.bat

   Another example of this is `pbnetexamples('pbtest.NET')', which
illustrates several advanced features like:

   * registering several queries

   * listening to server events (`server_started')

   * shutting down the Prolog server from .NET

   * starting up the Prolog server from .NET

   * using dynamic (OS assigned) ports for the .NET/Prolog communication

   The example is run by executing the C# program `PBTest':

     > PBTest

   _ASPX Servers Pages._ If you want to get your Prolog application to
be accessible from an intranet or the Internet you can use this package
to embed the Prolog programs into a .NET ASP page which can be served
by e.g. Internet Information Services.

   An example of how to do this is provided in
`pbnetexamples('prologasp.NET/eval.aspx')'. Consult your IIS
documentation for how to configure it for an ASPX page.  *The ASPX
example has a number of security vulnerabilites and is for illustrative
purposes only. Consult with an expert. *


File: sicstus.info,  Node: PB VB Example,  Prev: PB C# Examples,  Up: PB .NET Examples

10.28.8.2 Visual Basic Example
..............................

A Visual Basic .NET example can be found in
`pbnetexamples('vb_examples.NET/calculator')'. It is a simple
calculator similar to the first C# `EvaluateGUI' example in *note PB
First Example::. This example is in the form of a Visual Studio project.

   To run the example:

  1. Open the project files in Visual Studio .NET

  2. Add a reference in Visual Studio .NET to the installed
     `prologbeans.dll'

  3. Start sicstus with the following command:
          sicstus -l %SP_PATH%/library/prologbeans/examples/evaluate/evaluate --goal "main."

  4. Build and run the example in Visual Studio .NET


File: sicstus.info,  Node: lib-queues,  Next: lib-random,  Prev: lib-prologbeans,  Up: The Prolog Library

10.29 Queue Operations --`library(queues)'
==========================================

This module provides an implementation of queues, where you can
   * create an empty queue

   * add an element at either end of a queue

   * add a list of elements at either end of a queue

   * remove an element from the front of a queue

   * remove a list of elements from the front of a queue

   * determine the length of a queue

   * enumerate the elements of a queue

   * recognise a queue

   * print a queue nicely
   The representation was invented by Mark Johnson of the Center for
the Study of Language and Information.  All operations are fast.

   Exported predicates:

`empty_queue(?QUEUE)'
     is true when QUEUE represents an empty queue.  It can be used to
     test whether an existing queue is empty or to make a new empty
     queue.

`singleton_queue(?X, ?QUEUE)'
     is true when QUEUE is a queue with just one element X.

`portray_queue(+QUEUE)'
     writes a queue out in a pretty form, as QUEUE[ELEMENTS].  This form
     cannot be read back in, it is just supposed to be readable.  While
     it is meant to be called only when `is_queue(QUEUE)' has been
     established, as by `user:portray(Q) :- is_queue(Q), !,
     portray_queue(Q)'.  it is also meant to work however it is called.

`is_queue(+QUEUE)'
     is true when QUEUE is a queue.  The elements of QUEUE do not have
     to be instantiated, and the BACK of the QUEUE may or may not be.
     It can only be used to recognise queues, not to generate them.  To
     generate queues, use `queue_length(QUEUE, _)'.

`queue_head(+QUEUE, -HEAD)'
     is true when HEAD is the first element of the given QUEUE.  It does
     not remove HEAD from QUEUE; HEAD is still there afterwards.  It can
     only be used to find HEAD, it cannot be used to make a QUEUE.

`queue_tail(?QUEUE, ?TAIL)'
     is true when QUEUE and TAIL are both queues and TAIL contains all
     the elements of QUEUE except the first.  Note that QUEUE and TAIL
     share structure, so that you can add elements at the back of only
     one of them.  It can solve for either argument given the other.

`queue_cons(?HEAD, ?TAIL, ?QUEUE)'
     is true when HEAD is the head of QUEUE and TAIL is the tail of
     QUEUE, that is, when TAIL and QUEUE are both queues, and the
     elements of the QUEUE are HEAD followed by the elements of TAIL in
     order.  It can be used in either direction, so
              queue_cons(+Head, +Q0, -Q)      adds Head to Q0 giving Q
              queue_cons(-Head, -Q, +Q0)      removes Head from Q0 giving Q

`queue_last(?LAST, ?QUEUE)'
     is true when LAST is the last element currently in QUEUE.  It does
     not remove LAST from QUEUE; it is still there.  This can be used to
     generate a non-empty QUEUE.  The cost is O(|QUEUE|).

`queue_last(+FORE, +LAST, -QUEUE)'
     is true when FORE and QUEUE are both lists and the elements of
     QUEUE are the elements of FORE in order followed by LAST.  This is
     the operation which adds an element at the end of FORE giving
     QUEUE;  it is not reversible, unlike `queue_cons/3', and it
     side-effects FORE, again unlike `queue_cons/3'.

`append_queue(?LIST, ?QUEUE0, ?QUEUE)'
     is true when QUEUE is obtained by appending the elements of LIST
     in order at the front of QUEUE0, e.g.  `append_queue([a,b,c],
     Queue[d,e], Queue[a,b,c,d,e])'.  Use
              append_queue([+X1,...,+Xn], +Q0, -Q) to add X1,...,Xn to Q0 giving Q
              append_queue([-X1,...,-Xn], -Q, +Q0) to take X1...Xn from Q0 giving Q
     The cost is O(N) and the operation is pure.

`queue_append(+QUEUE0, +LIST, -QUEUE)'
     is true when QUEUE is obtained by appending the elements of LIST
     in order at the rear end of QUEUE0, e.g.
     `append_queue(Queue[a,b,c], [d,e], Queue[a,b,c,d,e])'.  This is
     like `queue_last/3'; it side-effects QUEUE0.

`list_queue(?LIST, ?QUEUE)'
     is true when QUEUE is a queue and LIST is a list and both have the
     same elements in the same order.  `list_queue/2' and `queue_list/2'
     are the same except for argument order.

`queue_list(?QUEUE, ?LIST)'
     is true when QUEUE is a queue and LIST is a list and both have the
     same elements in the same order.  `queue_list/2' and `list_queue/2'
     are the same except for argument order.

`queue_length(?QUEUE, ?LENGTH)'
     is true when QUEUE is a queue having LENGTH elements.  It may be
     used to determine the LENGTH of a QUEUE or to make a QUEUE of
     given LENGTH.

`queue_member(?ELEMENT, +QUEUE)'
     is true when ELEMENT is an element of QUEUE.  It could be made to
     generate queues, but that would be rather inefficient.  It bears
     the name `queue_member/2' because it is prepared to enumerate
     ELEMENTS.

`queue_memberchk(+ELEMENT, +QUEUE)'
     is true when the given ELEMENT is an element of QUEUE.  Once it
     finds a member of QUEUE which unifies with ELEMENT, it commits to
     it.  Use it to check a ground ELEMENT.

`map_queue(:PRED, +QUEUE[X1,...,XN])'
     succeeds when PRED(XI) succeeds for each element XI of the QUEUE.

`map_queue(:PRED, +QUEUE[X1,...,XN], ?QUEUE[Y1,...,YN])'
     succeeds when PRED(XI,YI) succeeds for each corresponding pair of
     elements XI, YI of the two queues.

`map_queue_list(:PRED, ?QUEUE[X1,...,XN], ?[Y1,...,YN])'
     succeeds when PRED(XI, YI) is true for each corresponding pair
     XI,YI of elements of the QUEUE and the LIST.  It may be used to
     generate either of the sequences from the other.

`map_list_queue(:PRED, ?[X1,...,XN], ?QUEUE[Y1,...,YN])'
     succeeds when PRED(XI, YI) is true for each corresponding pair
     XI,YI of elements of the LIST and the QUEUE.  It may be used to
     generate either of the sequences from the other.

`some_queue(:PRED, +QUEUE[X1,...,XN])'
     succeeds when PRED(XI) succeeds for some XI in the QUEUE.  It will
     try all ways of proving PRED(XI) for each XI, and will try each XI
     in the QUEUE.  `somechk_queue/2' is to `some_queue/2' as
     `memberchk/2' is to `member/2'; you are more likely to want
     `somechk_queue/2'.  This acts on backtracking like `member/2';
     QUEUE should be proper.

`some_queue(:PRED, +QUEUE[X1,...,XN], ?QUEUE[Y1,...,YN])'
     is true when PRED(XI, YI) is true for some I.

`somechk_queue(:PRED, +QUEUE[X1,...,XN])'
     is true when PRED(XI) is true for some I, and it commits to the
     first solution it finds (like `memberchk/2').

`somechk_queue(:PRED, +QUEUE[X1,...,XN], ?QUEUE[Y1,...,YN])'
     is true when PRED(XI, YI) is true for some I, and it commits to
     the first solution it finds (like `memberchk/2').


File: sicstus.info,  Node: lib-random,  Next: lib-rem,  Prev: lib-queues,  Up: The Prolog Library

10.30 Random Number Generator--`library(random)'
================================================

This library module provides a random number generator using algorithm
AS 183 from the Journal of Applied Statistics as the basic algorithm.

   The state of the random number generator corresponds to a term
`random(X,Y,Z,B)' where X is an integer in the range [1,30268], Y is an
integer in the range [1,30306], Z is an integer in the range [1,30322],
and B is a nonzero integer.

   Exported predicates:

`getrand(-RANDOMSTATE)'
     returns the random number generator's current state

`setrand(+RANDOMSTATE)'
     sets the random number generator's state to RANDOMSTATE.
     RANDOMSTATE can either be a random state previously obtained with
     `getrand/1', or an arbitrary integer. The latter is useful when
     you want to initialize the random state to a fresh representation.  If
     RANDOMSTATE is not an integer or a valid random state, it raises
     an error.

`maybe'
     succeeds determinately with probability 1/2, fails with
     probability 1/2.  We use a separate "random bit" generator for
     this test to avoid doing much arithmetic.

`maybe(+PROBABILITY)'
     succeeds determinately with probability Probability, fails with
     probability 1-PROBABILITY.  Arguments =< 0 always fail, >= 1
     always succeed.

`maybe(+P, +N)'
     succeeds determinately with probability P/N, where 0 =< P =< N and
     P and N are integers.  If this condition is not met, it fails.  It
     is equivalent to `random(0, N, X), X < P', but is somewhat faster.

`random(-UNIFORM)'
     unifies UNIFORM with a new random number in [0.0,1.0)

`random(+L, +U, -R)'
     unifies R with a random integer in [L,U) when L and U are integers
     (note that U will _never_ be generated), or to a random floating
     number in [L,U) otherwise.

`random_member(-ELEM, +LIST)'
     unifies ELEM with a random element of LIST, which must be proper.
     Takes O(N) time (average and best case).

`random_select(?ELEM, ?LIST, ?REST)'
     unifies ELEM with a random element of LIST and REST with all the
     other elements of LIST (in order).  Either LIST or REST should be
     proper, and LIST should/will have one more element than REST.
     Takes O(N) time (average and best case).

`random_subseq(+LIST, -SBSQ, -CMPL)'
     unifies SBSQ with a random sub-sequence of LIST, and CMPL with its
     complement.  After this, `subseq(List, Sbsq, Cmpl)' will be true.
     Each of the 2**|LIST| solutions is equally likely.  Like its
     name-sake `subseq/3', if you supply SBSQ and CMPL it will
     interleave them to find LIST.  Takes O(N) time.  LIST should be
     proper.

`random_permutation(?LIST, ?PERM)'
     unifies PERM with a random permutation of LIST.  Either LIST or
     PERM should be proper, and they should/will have the same length.
     Each of the N! permutations is equally likely, where `length(List,
     N)'.  This takes O(N LG N) time and is bidirectional.

`random_perm2(A,B, X,Y)'
     unifies X,Y = A,B or X,Y = B,A, making the choice at random, each
     choice being equally likely.  It is equivalent to
     `random_permutation([A,B], [X,Y])'.

`random_numlist(+P, +L, +U, -LIST)'
     where P is a probability (0..1) and L=<U are integers unifies LIST
     with a random subsequence of the integers L..U, each integer being
     included with probability P.


File: sicstus.info,  Node: lib-rem,  Next: lib-samsort,  Prev: lib-random,  Up: The Prolog Library

10.31 Rem's Algorithm--`library(rem)'
=====================================

This library module maintains equivalence classes using Rem's algorithm.
Exported predicates:

`rem_create(+SIZE, -REM)'
     creates an equivalence representation function REM which maps each
     of the nodes 1..SIZE to itself.

`rem_head(?NODE, +REM, -HEAD)'
     is true when HEAD is the representative of the equivalence class
     that NODE belongs to in the given REM.

`rem_equivalent(?NODE1, ?NODE2, +REM)'
     is true when NODE1 and NODE2 belong to the same equivalence class
     in the given REM.

`rem_add_link(?NODE1, ?NODE2, +OLDREM, -NEWREM)'
     is true when adding the equivalence NODE1===NODE2 to the partition
     represented by OLDREM yields a partition which is represented by
     NEWREM.  If NODE1 or NODE2 is uninstantiated, it will backtrack
     over all the nodes.  It's not clear how useful this is.


File: sicstus.info,  Node: lib-samsort,  Next: lib-sets,  Prev: lib-rem,  Up: The Prolog Library

10.32 Generic Sorting--`library(samsort)'
=========================================

This library module provides generic sorting.  Exported predicates:

`samsort(+RAWLIST, -SORTED)'
     is given a proper list RAWLIST and unifies SORTED with a list
     having exactly the same elements as RAWLIST but in ascending order
     according to the standard order on terms.

`merge(+LIST1, +LIST2, -MERGED)'
     is true when MERGED is the stable merge of the two given lists.
     If the two lists are not ordered, the merge doesn't mean a great
     deal.  Merging is perfectly well defined when the inputs contain
     duplicates, and all copies of an element are preserved in the
     output, e.g. merge("122357", "34568", "12233455678").

`samsort(:ORDER, +RAWLIST, -SORTEDLIST)'
     is given a proper list RAWLIST and a binary predicate ORDER (note
     that it may be an N-ARY predicate with the first N-2 arguments
     already filled in) and unifies SORTEDLIST with a sorted version of
     RAWLIST.  This is only supposed to work when Orderis transitive.

`merge(:ORDER, +LIST1, +LIST2, -MERGED)'
     is like `merge/3' except that it takes an ORDER predicate as its
     first arguments, like all the generalised ordering routines.

`samkeysort(+RAWLIST, -SORTED)'
     is given a proper list RAWLIST of KEY-VALUE pairs, and unifies
     SORTED with a list having exactly the same elements as RAWLIST but
     in ascending order according to the standard order on the keys.
     `samkeysort/2' is stable in the sense that the relative position of
     elements with the same key is maintained.

`keymerge(+LIST1, +LIST2, -MERGED)'
     is like `merge/3' except that it compares only the keys of its
     input lists.  Note that it will not work properly when MERGED is
     already instantiated.


File: sicstus.info,  Node: lib-sets,  Next: lib-sockets,  Prev: lib-samsort,  Up: The Prolog Library

10.33 Unordered Set Operations--`library(sets)'
===============================================

This library module provides operations on sets represented as
unordered lists with no repeated elements.  The ordered representation
used in `library(ordsets)' is much more efficient, but these routines
were designed before sort/2 entered the language.  Exported predicates:

`add_element(+ELEMENT, +SET1, -SET2)'
     is true when SET1 and SET2 are sets represented as unordered lists,
     and SET2 = SET1 U {ELEMENT}.  It may only be used to calculate SET2
     given ELEMENT and SET1.

`del_element(+ELEMENT, +SET1, -SET2)'
     is true when SET1 and SET2 are sets represented as unordered lists,
     and SET2 = SET1 \ {ELEMENT}.  It may only be used to calculate SET2
     given ELEMENT and SET1.  If SET1 does not contain ELEMENT, SET2
     will be identical to SET1 (the old version made a new copy of
     SET1).  If SET1 is not an unordered set, but contains more than
     one copy of ELEMENT, only the first will be removed.  If you want
     to delete all copies of a given element, use `lists:delete/3'.
     For a version which fails if ELEMENT is not in SET1, use
     `selectchk/3'.

`disjoint(+SET1, +SET2)'
     is true when the two given sets have no elements in common.  It is
     the opposite of `intersect/2'.  If either of the arguments is
     improper, `disjoint/2' will fail.

`is_set(+LIST)'
     is true when LIST is a proper list that contains no repeated
     elements.

`pairfrom(?SET, ?ELEMENT1, ?ELEMENT2, ?RESIDUE)'
     is true when SET is a list, ELEMENT1 occurs in list, ELEMENT2
     occurs in list after ELEMENT1, and RESIDUE is everything in SET
     bar the two ELEMENTS.  The point of this thing is to select pairs
     of elements from a set without selecting the same pair twice in
     different orders.

`intersect(+SET1, +SET2)'
     is true when the two sets have a member in common.  It assumes
     that both sets are known, and that you don't care which element it
     is that they share.

`subset(+SET1, +SET2)'
     is true when each member of SET1 occurs in SET2.  It can only be
     used to test two given sets; it cannot be used to generate subsets.
     There is no predicate for generating subsets as such, but the
     predicates `subseq/3', `subseq0/2', `subseq1/2' in
     `library(lists)' may do what you want (they preserve the order of
     elements within a list).  Could be defined as:

          subset(Set1, Set2) :-
          	(   foreach(X,Set1),
          	    param(Set2)
          	do  memberchk(X,Set2)
          	).

`set_order(+XS, +YS, -R)'
     is true when R is `<', `=', or `>' according as XS is a subset of
     YS, equivalent to YS, or a superset of YS.

`seteq(+SET1, +SET2)'
     is true when each Set is a subset of the other.

`list_to_set(+LIST, -SET)'
     is true when LIST and SET are lists, and SET has the same elements
     as LIST in the same order, except that it contains no duplicates.
     The two are thus equal considered as sets.

`power_set(+SET, -POWERSET)'
     is true when SET is a list and POWERSET is a list of lists which
     represents the power set of the set that Set represents.

`intersection(+SET1, +SET2, -INTERSECTION)'
     is true when all three arguments are lists representing sets, and
     INTERSECTION contains every element of SET1 which is also an
     element of SET2, the order of elements in INTERSECTION being the
     same as in SET1.  That is, INTERSECTION represents the
     intersection of the sets represented by SET1 and SET2.  Could be
     defined as:

          intersection(Set1, Set2, Intersection) :-
          	(   foreach(X,Set1),
          	    fromto(Intersection,S0,S,[]),
          	    param(Set2)
          	do  (member(X, Set2) -> S0 = [X|S] ; S0 = S)
          	).

`intersection(+LISTOFSETS, -INTERSECTION)'
     is true when INTERSECTION is the intersection of all the sets in
     LISTOFSETS.  The order of elements in INTERSECTION is taken from
     the first set in LISTOFSETS.  This has been turned inside out to
     minimise the storage turnover.  Could be defined as:

          intersection([Set1|Sets], Intersection) :-
          	(   foreach(X,Set1),
          	    fromto(Intersection,S0,S,[]),
          	    param(Sets)
          	do  (   (   foreach(Set,Sets),
          		    param(X)
          		do  memberchk(X, Set)
          		) -> S0 = [X|S]
          	    ;   S0 = S
          	    )
          	).

`subtract(+SET1, +SET2, -DIFFERENCE)'
     is like `intersect/3', but this time it is the elements of SET1
     which _are_ in SET2 that are deleted.  Note that duplicated
     ELEMENTS of SET1 which are not in SET2 are retained in DIFFERENCE.
     Could be defined as:

          subtract(Set1, Set2, Difference) :-
          	(   foreach(X,Set1),
          	    fromto(Difference,S0,S,[]),
          	    param(Set2)
          	do  (member(X, Set2) -> S0 = S ; S0 = [X|S])
          	).

`symdiff(+SET1, +SET2, -DIFFERENCE)'
     is true when DIFFERENCE is the symmetric difference of SET1 and
     SET2, that is, if each element of DIFFERENCE occurs in one of SET1
     and SET2 but not both.  The construction method is such that the
     answer will have no duplicates even if the SETS do.

`setproduct(+SET1, +SET2, -CARTESIANPRODUCT)'
     is true when SET1 is a set (list) and SET2 is a set (list) and
     CARTESIANPRODUCT is a set of ELT1-ELT2 pairs, with a pair for for
     each element ELT1 of SET1 and ELT2 of SET2.  Could be defined as:

          setproduct(Set1, Set2, Product) :-
          	(   foreach(H1,Set1),
          	    param(Set2),
          	    fromto(Product,P1,P3,[])
          	do  (   foreach(H2,Set2),
          		param(H1),
          		fromto(P1,[H1-H2|P2],P2,P3)
          	    do  true
          	    )
          	).

`disjoint_union(+SET1, +SET2, -UNION)'
     is true when `disjoint(Set1, Set2)' and `union(Set1, Set2, Union)',
     that is, SET1 and SET2 have no element in command and UNION is
     their union.  Could be defined as:

          disjoint_union(Set1, Set2, Union) :-
          	(   foreach(X,Set1),
          	    fromto(Union,[X|S],S,Set2),
          	    param(Set2)
          	do  nonmember(X, Set2)
          	).

`union(+SET1, +SET2, -UNION)'
     is true when `subtract(Set1,Set2,Diff)' and
     `append(Diff,Set2,Union)', that is, when UNION is the elements of
     SET1 that do not occur in SET2, followed by all the elements of
     SET2.  Could be defined as:

          union(Set1, Set2, Union) :-
          	(   foreach(X,Set1),
          	    fromto(Union,S0,S,Set2),
          	    param(Set2)
          	do  (member(X, Set2) -> S0 = S ; S0 = [X|S])
          	).

`union(+SET1, +SET2, -UNION, -DIFFERENCE)'
     is true when `union(Set1, Set2, Union)' and `subtract(Set1, Set2,
     Difference)'.  Could be defined as:

          union(Set1, Set2, Union, Difference) :-
          	(   foreach(X,Set1),
          	    fromto(Union,S0,S,Set2),
          	    fromto(Difference,T0,T,[]),
          	    param(Set2)
          	do  (   member(X, Set2) -> S0 = S, T0 = T
          	    ;   S0 = [X|S], T0 = [X|T]
          	    )
          	).

`union(+LISTOFSETS, -UNION)'
     is true when UNION is the union of all the sets in LISTOFSETS.  It
     has been arranged with storage turnover in mind.  Could be defined
     as:

          union(Sets, Union) :-
          	(   foreach(Set,Sets),
          	    param(Answer)
          	do  (   foreach(X,Set),
          		param(Answer)
          	    do  memberchk(X, Answer)
          	    )
          	),
          	append(Answer, [], Answer),	% cauterise it
          	!,
          	Union = Answer.


File: sicstus.info,  Node: lib-sockets,  Next: lib-structs,  Prev: lib-sets,  Up: The Prolog Library

10.34 Socket I/O--`library(sockets)'
====================================

This library package defines a number of predicates for communicating
over sockets.

   To create a (bi-directional) stream connected to a remote server,
use `socket_client_open/3'.

   To open a port for remote clients to connect to, use
`socket_server_open/[2,3]' and to open a stream to a connecting client,
use `socket_server_accept/4'.

   To be able to multiplex input and output from several streams (not
necesessarily socket streams) and incoming connections, use
`socket_select/7'.

   When opening a client or server socket a "socket address" needs to
be specified. The address specifies the address family and
family-specific information. The following formats are supported for
socket addresses:
`inet(NODENAME,SERVNAME)'
`NODENAME:SERVNAME'
`SERVNAME'
     This specifies the address for and ordinary internet socket
     (`AF_INET' or `AF_INET6').  NODENAME is the internet address of
     the remote host, as an atom, something like `'www.sics.se'' or
     `'193.10.64.51''. The empty nodename `''' (the default), has
     special meaning, see the documentation for `socket_client_open/3'
     and `socket_server_open/[2,3]'.  SERVNAME is either a port number
     as an atom of decimal digits or as an integer, e.g. `'80'', or
     `80'; alternatively some "well known port names" can be used, e.g.
     `'http''. The set of well known port names is OS specific,
     portable code should use integer port numbers.  SERVNAME can also
     be a variable when opening a server socket with
     `socket_server_open/[2,3]'. In this case a available port is
     assigned automatically and Servname is bound to it.

`unix(PATH)   *since release 4.0.3*'
     A Unix domain (`AF_UNIX') socket is opened at the specified file
     system location. This is only supported on Unix-like platforms.
     PATH is a file-name and is passed to `absolute_file_name/2'. There
     may be platform-specific restrictions on the length of the
     resulting pathname and the file system containing it.

   All streams below can be read from as well as written to.  All I/O
predicates operating on streams can be used, for example `get_code/2',
`get_byte/2', `read/2', `write/2', `format/3', `current_stream/3', etc.
The predicates that create streams take options similar to `open/4',
e.g. to specify whether the stream is binary (the default) or text.

`socket_client_open(+ADDR, -STREAM, +OPTIONS)'
     Creates a stream STREAM connected to address ADDR.  See above for
     the allowed address formats. If the nodename is empty (`''') then
     a connection is made to the local machine.

     The stream is created using options from OPTIONS. Supported
     options include:
    `type(binary)'
          Create a binary stream (the default).

    `type(text)'
          Create a text stream. The default encoding is Latin 1.

    `eof_action(ACTION)'
          end of file action, as for `open/4'.

    `encoding(ENCODING)   *since release 4.1*'
          As for open/4. Implies `type(text)'.

    `eol(EOL)   *since release 4.1*'
          As for open/4. Implies `type(text)'.

     To create a binary stream to some web server `www.sics.se', you
     would do e.g.
          | ?- socket_client_open('www.sics.se':80, Stream, [type(binary)]).

     or, to make a text (Latin 1) stream to a `daytime' service in Hong
     Kong you could do:

          | ?- socket_client_open('stdtime.gov.hk':daytime, S, [type(text)]),
               read_line(S, L),
               format('~s', [L]).

     See the source code for `library('linda/client')' for a simple
     client.

`socket_server_open(?ADDR, -SERVERSOCKET, +OPTIONS)   *since release 4.0.3*'
     Create a server socket SERVERSOCKET that listens on address ADDR.
     See above for the allowed address formats. If the nodename is
     empty (`''') then any remote client machine is allowed to connect
     unless the option `loopback(true)' is also specified.  ADDR can
     specify an internet address where the port is a variable in which
     case a free port number is used and PORT is bound to it. The
     common case is that Addr is a numeric port number or a variable
     that becomes bound to a free port number.

     The created server socket should be closed with
     `socket_server_close/1' eventually. Incoming connection can be
     accepted with `socket_server_accept/4' and waited for with
     `socket_select/7'.  See the source code for
     `library('linda/server')' for a simple server that uses this
     predicate.

     OPTIONS is a list of options, currently
    `reuseaddr(Bool)   *since release 4.0.3*'
          BOOL is either `true' or `false' (the default). If `true'
          then allow reuse of local addresses. For internet sockets
          this corresponds to the `SO_REUSEADDR' socket option. For
          unix domain sockets this means that the file will be deleted,
          if present, before opening.

    `numeric_nodename(Bool)   *since release 4.0.3*'
          BOOL is either `true' or `false' (the default). If `true'
          then the nodename of an internet address will be treated as a
          numerical address and no name lookup will be performed.

    `numeric_servname(Bool)   *since release 4.0.3*'
          BOOL is either `true' or `false' (the default). If `true'
          then the servname of an internet address will be treated as a
          numerical port number and no lookup of well known port names
          will be performed.

    `loopback(Bool)   *since release 4.0.3*'
          BOOL is either `true' or `false' (the default). If `true'
          then the nodename will be ignored and the socket will only
          listen to connection from the loopback device, i.e. the local
          machine.

`socket_server_open(?PORT, -SERVERSOCKET)'
     The same as `socket_server_open(PORT, SERVERSOCKET, [])'.

`socket_server_accept(+SERVERSOCKET, -CLIENT, -STREAM, +STREAMOPTIONS)'
     The first connection to socket SERVERSOCKET is extracted, blocking
     if necessary.  The stream STREAM is created on this connection
     using STREAMOPTIONS as for `socket_client_open/3'. CLIENT will be
     unified with an atom containing the numerical Internet host
     address of the connecting client.  Note that the stream will be
     `type(binary)' unless `type(text)' is specified either explicitly
     or implicitly with `encoding/1' or other text-only options.

`socket_server_close(+SERVERSOCKET)'
     Close the server socket SERVERSOCKET and stop listening on its
     port.

`socket_select(+SERVERSOCKETS,-SREADY, +READSTREAMS,-RREADY, +WRITESTREAMS,-WREADY, +TIMEOUT)'
     Check for server sockets with incoming connections (i.e. ready for
     `socket_server_accept/4'), streams on READSTREAMS ready for input,
     and streams on WRITESTREAMS ready for output. The streams can be
     any kind of streams, they need not be socket streams. The ready
     server sockets are returned (in the same order) in SREADY, the
     ready input streams in RREADY, and the ready output streams in
     WREADY.

     An input (output) stream is ready for input (output) when an
     "item" can be read (written) without blocking. An item is a
     character for text streams and a byte for binary streams.  Note
     that a stream is considered ready for I/O if the corresponding I/O
     operation will raise an error (such as if the stream is past end
     of stream).

     Each entry in the input lists SERVERSOCKETS, READSTREAMS, and
     WRITESTREAMS can be either a server socket or stream respectively
     or a term `TERM-ENTRY' where ENTRY is the server socket or stream
     and TERM is some arbitrary term used for book-keeping. If an entry
     is associated with a term in this way then so will the
     corresponding ready entry.

     If TIMEOUT is instantiated to `off', the predicate waits until
     something is available.  If TIMEOUT is a nonzero number (integer
     or floating point), then the predicate waits at most that number
     of seconds before returning. For backward compatibility, if
     TIMEOUT is S:U the predicate waits at most S seconds and U
     microseconds. If there is a timeout, all ready lists are unified
     with `[]'.

     See the source code for `library('linda/server')' for a simple
     server that uses this predicate.

`current_host(?HOSTNAME)'
     HOSTNAME is unified with the fully qualified name of the machine
     that the process is executing on. The call will also succeed if
     HOSTNAME is instantiated to the unqualified name of the machine in
     lower case. *Please note:* this predicate will fail if there are
     errors, e.g. if no domain has been configured.


File: sicstus.info,  Node: lib-structs,  Next: lib-system,  Prev: lib-sockets,  Up: The Prolog Library

10.35 The Structs Package--`library(structs)'
=============================================

* Menu:

* str-fty::                             Foreign Types
* str-cft::                             Checking Foreign Term Types
* str-cdf::                             Creating and Destroying Foreign Terms
* str-afd::                             Accessing and Modifying Foreign Term Contents
* str-cas::                             Casting
* str-nul::                             Null Foreign Terms
* str-ifc::                             Interfacing with Foreign Code
* str-etr::                             Examining Type Definitions at Runtime
* str-tip::                             Tips
* str-exa::                             Example

   The `structs' package allows Prolog to hold pointers to C data
structures, and to access and store into fields in those data
structures.  Currently, the only representation for a pointer supported
by SICStus Prolog is an integer, so it isn't possible to guarantee that
Prolog can't confuse a pointer with an ordinary Prolog term.  What this
package does is to represent such a pointer as a term with the type of
the structure or array as its functor and the integer that is the
address of the actual data as its only argument.  We will refer such
terms as "foreign terms".  

   The package consists of two modules, `str_decl' and `structs'. The
`str_decl' module is used at compile time to translate the
structs-related constructs.  Any file that defines or accesses structs
should include the command:

     :- load_files(library(str_decl),
                   [when(compile_time), if(changed)]).

   The `structs' module provides runtime support for structs.  A file
that accesses structs should include the command:

     :- use_module(library(structs)).

   You will probably include both in most files that define and access
structs.

   *Please note:* A file that loads `library(str_decl)' currently cannot
recursively load another file that loads `library(str_decl)', because
that would confuse the internal database being used by the package.

     *Important caveats:*

     You should not count on future versions of the structs package to
     continue to represent foreign terms as compound Prolog terms.  In
     particular, you should never explicitly take apart a foreign term
     using unification or `functor/3' and `arg/3'.  You may use the
     predicate `foreign_type/2' to find the type of a foreign term, and
     `cast/3' (casting a foreign term to address) to get the address
     part of a foreign term.  You may also use `cast/3' to cast an
     address back to a foreign term.  You should use
     `null_foreign_term/2' to check if a foreign term is null, or to
     create a null foreign term of some type.

     It should never be necessary to explicitly take apart foreign
     terms.


File: sicstus.info,  Node: str-fty,  Next: str-cft,  Up: lib-structs

10.35.1 Foreign Types
---------------------

* Menu:

* str-fty-dty::                         Declaring Types

   There are two sorts of objects that Prolog may want to handle:
"atomic" and "compound".  "Atomic" objects include numbers and atoms,
and "compound" objects include data structures and arrays.  To be more
precise about it, an atomic type is defined by one of the following:

`integer'
     signed integer, large enough to hold a pointer.

`integer_64   *since release 4.3*'
     64 bit signed integer.

`integer_32'
     32 bit signed integer.

`integer_16'
     16 bit signed integer.

`integer_8'
     8 bit signed integer.

`unsigned'
     unsigned integer, large enough to hold a pointer.

`unsigned_64   *since release 4.3*'
     64 bit unsigned integer.

`unsigned_32'
     32 bit unsigned integer.

`unsigned_16'
     16 bit unsigned integer.

`unsigned_8'
     8 bit unsigned integer.

`float'
     64 bit floating-point number.

`float_32'
     32 bit floating-point number.

`atom'
     32 bit Prolog atom number.  Unique for different atoms, but not
     consistent across Prolog sessions.  The atom is made non garbage
     collectable. *Note Atoms in C::.

`string'
     A pointer to an encoded string.  Represented as an atom in Prolog.
     *Please note*: This string must not be overwritten, as it
     constitutes the print name of an atom.  Also, the atom and string
     are made non garbage collectable. *Note Atoms in C::.

`address'
     An untyped pointer.  Like `pointer(_)', but `library(structs)'
     does no type checking for you. Represented as a Prolog integer.

`opaque'
     Unknown type.  Cannot be represented in Prolog.  A pointer to an
     opaque object may be manipulated.

   Compound types are defined by one of the following:

`pointer(TYPE)'
     a pointer to a thing of type TYPE.

`array(NUM,TYPE)'
     A chunk of memory holding NUM (an integer) things of type TYPE.

`array(TYPE)'
     A chunk of memory holding some number of things of type TYPE.
     This type does not allow bounds checking, so it should be used
     with great care.  It is also not possible to use this sort of
     array as an element in an array, or in a struct or union.

`struct(FIELDS)'
     A compound structure.  FIELDS is a list of FIELD_name:TYPE pairs.
     Each FIELD_name is an atom, and each TYPE is any valid type.

`union(MEMBERS)'
     A union as in C.  MEMBERS is a list of MEMBER_name:TYPE pairs.
     Each MEMBER_name is an atom, and each TYPE is any valid type.  The
     space allocated for one of these is the maximum of the spaces
     needed for each member.  It is not permitted to store into a union
     (you must get a member of the union to store into, as in C).

   C programmers will recognize that the kinds of data supported by
this package were designed for the C language.  They should also work
for other languages, but programmers must determine the proper type
declarations in those languages.  The table above makes clear the
storage requirements and interpretation of each type.

   Note that there is one important difference between the `structs'
package and C:  the `structs' package permits declarations of pointers
to arrays.  A pointer to an array is distinguished from a pointer to a
single element.  For example
     pointer(array(integer_8))

is probably a more appropriate declaration of a C string type than
     pointer(integer_8)

which is the orthodox way to declare a string in C.


File: sicstus.info,  Node: str-fty-dty,  Up: str-fty

10.35.1.1 Declaring Types
.........................

Programmers may declare new named data structures with the following
procedure:
     :- foreign_type
         Type_name = Type,
         ...,
         Type_name = Type.

where TYPE_NAME is an atom, and TYPE defines either an atomic or
compound type, or is a previously-defined type name.

   In Prolog, atomic types are represented by the natural atomic term
(integer, float, or atom).  Compound structures are represented by
terms whose functor is the name of the type, and whose only argument is
the address of the data.  So a term `foo(123456)' represents the thing
of type `foo' that exists at machine address 123456.  And a term
`integer(123456)' represents the integer that lives in memeory at
address 123456, _not_ the number 123456.

   For types that are not named, a type name is generated using the
names of associated types and the dollar sign character (`$'), and
possibly a number.  Therefore, users should not use `$' in their type
names.


File: sicstus.info,  Node: str-cft,  Next: str-cdf,  Prev: str-fty,  Up: lib-structs

10.35.2 Checking Foreign Term Types
-----------------------------------

The type of a foreign term may determined by the goal
     foreign_type(+FOREIGN_TERM, -TYPE_NAME)

   Note that `foreign_type/2' will fail if FOREIGN_TERM is not a
foreign term.


File: sicstus.info,  Node: str-cdf,  Next: str-afd,  Prev: str-cft,  Up: lib-structs

10.35.3 Creating and Destroying Foreign Terms
---------------------------------------------

Prolog can create or destroy foreign terms using
     new(+TYPE, -DATUM),
     new(+TYPE, +SIZE, -DATUM) and
     dispose(+DATUM)

where TYPE is an atom specifying what type of foreign term is to be
allocated, and DATUM is the foreign term.  TYPE should be an atomic
type or a previously-defined type name.  The DATUM returned by
`new/[2,3]' is initialized to all zeroes.  `dispose/1' is a dangerous
operation, since once the memory is disposed, it may be used for
something else later.  If DATUM is later accessed, the results will be
unpredictable.  `new/3' is only used to allocate arrays whose size is
not known beforehand, as defined by `array(TYPE)', rather than
`array(NUM,TYPE)'.


File: sicstus.info,  Node: str-afd,  Next: str-cas,  Prev: str-cdf,  Up: lib-structs

10.35.4 Accessing and Modifying Foreign Term Contents
-----------------------------------------------------

Prolog can get or modify the contents of a foreign term with the
procedures
     get_contents(+DATUM, ?PART, ?VALUE)
     put_contents(+DATUM, +PART, +VALUE).

   It can also get a pointer to a field or element of a foreign term
with the procedure
     get_address(+DATUM, ?PART, ?VALUE).

   For all three of these, DATUM must be a foreign term, and PART
specifies what part of DATUM VALUE is.  If DATUM is an array, PART
should be an integer index into the array, where 0 is the first
element.  For a pointer, PART should be the atom `contents' and VALUE
will be what the pointer points to.  For a struct, PART should be a
field name, and VALUE will be the contents of that field.  In the case
of `get_contents/3' and `get_address/3', if PART is unbound,
`get_contents/3' will backtrack through all the valid parts of DATUM,
binding both PART and VALUE.  A C programmer might think of the
following pairs as corresponding to each other:
     Prolog: get_contents(Foo, Bar, Baz)
          C: Baz = Foo->Bar

     Prolog: put_contents(Foo, Bar, Baz)
          C: Foo->Bar = Baz

     Prolog: get_address(Foo, Bar, Baz)
          C: Baz = &Foo->Bar.

   The hitch is that only atomic and pointer types can be got and put
by `get_contents/3' and `put_contents/3'.  This is because Prolog can
only hold pointers to C structures, not the structures themselves.
This isn't quite as bad as it might seem, though, since usually
structures contain pointers to other structures, anyway.  When a
structure directly contains another structure, Prolog can get a pointer
to it with `get_address/3'.


File: sicstus.info,  Node: str-cas,  Next: str-nul,  Prev: str-afd,  Up: lib-structs

10.35.5 Casting
---------------

Prolog can "cast" one type of foreign term to another.  This means that
the foreign term is treated just as if it where the other type.  This is
done with the following procedure:
     cast(+FOREIGN0, +NEW_TYPE, -FOREIGN)

where FOREIGN is the foreign term that is the same data as FOREIGN0,
only is of foreign type NEW_TYPE.  FOREIGN0 is not affected.  This is
much like casting in C.

   Casting a foreign term to `address' will get you the raw address of a
foreign term.  This is not often necessary, but it is occasionally
useful in order to obtain an indexable representation to use in the first
argument of a dynamic predicate you are maintaining.  An `address' may
also be casted to a proper foreign type.

   This predicate should be used with great care, as it is quite easy to
get into trouble with this.


File: sicstus.info,  Node: str-nul,  Next: str-ifc,  Prev: str-cas,  Up: lib-structs

10.35.6 Null Foreign Terms
--------------------------

"NULL" foreign terms may be handled.  The predicate
     null_foreign_term(+TERM, -TYPE)
     null_foreign_term(-TERM, +TYPE)

holds when TERM is a foreign term of TYPE, but is NULL (the address is
0).  At least one of TERM and TYPE must be bound.  This can be used to
generate NULL foreign terms, or to check a foreign term to determine
whether or not it is NULL.


File: sicstus.info,  Node: str-ifc,  Next: str-etr,  Prev: str-nul,  Up: lib-structs

10.35.7 Interfacing with Foreign Code
-------------------------------------

Foreign terms may be passed between Prolog and other languages through
the foreign interface.

   To use this, all foreign types to be passed between Prolog and
another language must be declared with `foreign_type/2' before the
`foreign/[2,3]' clauses specifying the foreign functions.

   The `structs' package extends the foreign type specifications
recognized by the foreign interface.  In addition to the types already
recognized by the foreign interface, any atomic type recognized by the
`structs' package is understood, as well as a pointer to any named
`structs' type.

   For example, if you have a function

     char nth_char(string, n)
         char *string;
         int n;
         {
             return string[n];
         }

   You might use it from Prolog as follows:
     :- foreign_type cstring = array(integer_8).

     foreign(nth_char, c, nth_char(+pointer(cstring), +integer, [-integer_8])).

   This allows the predicate `nth_char/3' to be called from Prolog to
determine the nth character of a C string.

   Note that all existing foreign interface type specifications are
unaffected, in particular `address/[0,1]' continue to pass addresses to
and from Prolog as plain integers.

   If you use the foreign resource linker, `splfr', on a Prolog file
that uses the `structs' package, you must pass it the `--structs'
option.  This will make `splfr' understand foreign type specifications
and translate them into C declarations in the generated header file
(*note The Foreign Resource Linker::).


File: sicstus.info,  Node: str-etr,  Next: str-tip,  Prev: str-ifc,  Up: lib-structs

10.35.8 Examining Type Definitions at Runtime
---------------------------------------------

The above described procedures should be sufficient for most needs.
This module does, however, provide a few procedures to allow
programmers to access type definitions.  These may be a convenience for
debugging, or in writing tools to manipulate type definitions.

   The following procedures allow programmers to find the definition of
a given type:
     type_definition(?TYPE, ?DEFINITION)
     type_definition(?TYPE, ?DEFINITION, ?SIZE)

where TYPE is an atom naming a type, DEFINITION is the definition of
that type, and SIZE is the number of bytes occupied by a foreign term of
this type.  SIZE will be the atom `unknown' if the size of an object of
that type is not known.  Such types may not be used as fields in
structs or unions, or in arrays.  However, pointers to them may be
created.  If TYPE is not bound at call time, these procedures will
backtrack through all current type definitions.

   A definition looks much like the definition given when the type was
defined with `type/1', except that it has been simplified.  Firstly,
intermediate type names have been elided.  For example, if `foo' is
defined as `foo=integer', and `bar' as `bar=foo', `type_definition(bar,
integer)' would hold.  Also, in the definition of a compound type,
types of parts are always defined by type names, rather than complex
specifications.  So if the type of a field in a struct was defined as
`pointer(fred)', it will show up in the definition as `'$fred''.  Of
course, `type_definition('$fred', pointer(fred))' would hold, also.

   The following predicates allow the programmer to determine whether
or not a given type is atomic:
     atomic_type(?TYPE)

     atomic_type(?TYPE, ?PRIMITIVE_TYPE)

     atomic_type(?TYPE, ?PRIMITIVE_TYPE, ?SIZE)

where TYPE is an atomic type.  See *note str-fty:: for the definition
of an atomic type.  PRIMITIVE_TYPE is the primitive type that TYPE is
defined in terms of.  SIZE is the number of bytes occupied by an object
of type TYPE, or the atom `unknown', as above.  If TYPE is unbound at
call time, these predicates will backtrack through all the currently
defined atomic types.


File: sicstus.info,  Node: str-tip,  Next: str-exa,  Prev: str-etr,  Up: lib-structs

10.35.9 Tips
------------

  1. Most important tip: don't subvert the `structs' type system by
     looking inside foreign terms to get the address, or use
     `functor/3' to get the type.  This has two negative effects:
     firstly, if the `structs' package should change its representation
     of foreign terms, your code will not work.  But more importantly,
     you are more likely to get type mismatches, and likely to get
     unwrapped terms or even doubly wrapped terms where you expect
     wrapped ones.

  2. Remember that a foreign term `fred(123456)' is not of type `fred',
     but a pointer to `fred'.  Looked at another way, what resides in
     memory at address 123456 is of type `fred'.

  3. The wrapper put on a foreign term signifies the type of that
     foreign term.  If you declare a type to be `pointer(opaque)'
     because you want to view that pointer to be opaque, when you get
     something of this type, it will be printed as `opaque(456123)'.
     This is not very informative.  It is better to declare
          fred = opaque,
          thing = struct([...,
                      part:pointer(fred),
                      ...
                  ]).

     so that when you get the contents of the `part' member of a
     `thing', it is wrapped as `fred(456123)'.


File: sicstus.info,  Node: str-exa,  Prev: str-tip,  Up: lib-structs

10.35.10 Example
----------------

The following example shows how to use `library(structs)' in a simple
package for handling integer arrays.  We define a module `minivec' with
exported predicates for creating and disposing arrays, accessing its
elements, and computing their sum.  The summing operation is
implemented in C and the rest in Prolog.  Arrays are created using the
`array(TYPE)' foreign type.

   Note that the type declaration `int32' does not have to be given in
the C source code, as it appears in the automatically generated header
file `minivec_glue.h'.  Note also how the foreign type specification
`+pointer(int_array)' corresponds to the C type declaration `int32 *'.

                                                         _% minivec.pl_
     :- module(minivec, [
             new_array/2,
             get_array/3,
             put_array/3,
             dispose_array/1,
             sum_array/2
             ]).

     :- load_files(library(str_decl), [when(compile_time)]).
     :- use_module(library(structs)).

     :- foreign_type
             int32           = integer_32,
             int_array       = array(int32).

     foreign(c_sum_array, c_sum_array(+integer,
                                      +pointer(int_array),
                                      [-integer])).

     foreign_resource(minivec, [c_sum_array]).

     :- load_foreign_resource(minivec).

     new_array(Size, array(Size,Mem)) :-
             new(int_array, Size, Mem).

     get_array(Index, array(_,Mem), Value) :-
             get_contents(Mem, Index, Value).

     put_array(Index, array(_,Mem), Value) :-
             put_contents(Mem, Index, Value).

     dispose_array(array(_,Mem)) :-
             dispose(Mem).

     sum_array(array(Size,Mem), Sum) :-
             c_sum_array(Size, Mem, Sum).

                                                      _/* minivec.c */_
     #include "minivec_glue.h"

     SP_integer c_sum_array(SP_integer cnt, int32 *mem)
     {
       int i;
       SP_integer sum = 0;

       for (i=0; i<cnt; i++)
         sum += mem[i];
       return sum;
     }

                                                            _# session_
     % splfr --struct minivec.pl minivec.c
     % sicstus -l minivec
     % compiling /home/matsc/sicstus4/Suite/minivec.pl...
     % [...]
     % compiled /home/matsc/sicstus4/Suite/minivec.pl in module minivec, 30 msec 68388 bytes
     SICStus 4.3.1 ...
     Licensed to SICS
     | ?- new_array(4, A),
          put_array(0,A,1),
          put_array(1,A,10),
          put_array(2,A,100),
          put_array(3,A,1000),
          sum_array(A,S),
          dispose_array(A).
     A = array(4,int_array(1264224)),
     S = 1111

   A fragment from the generated header file:

                                                 _/* minivec_glue.h */_
     #include <sicstus/sicstus.h>
     #include <stdlib.h>
     typedef int int32;
     typedef int32 *(int_array)/* really an unknown-size array */;
     extern SP_integer c_sum_array( SP_integer, int32 *);


File: sicstus.info,  Node: lib-system,  Next: lib-tcltk,  Prev: lib-structs,  Up: The Prolog Library

10.36 Operating System Utilities--`library(system)'
===================================================

This package contains utilities for invoking services from the operating
system that does not fit elsewhere.

   Exported predicates:

`now(-WHEN)'
     Unifies the current date and time as a UNIX timestamp with WHEN.

`datime(-DATIME)'
     Unifies DATIME with the current date and time as a `datime/6'
     record of the form `datime(YEAR,MONTH,DAY,HOUR,MIN,SEC)'.  All
     fields are integers.

`datime(+WHEN,-DATIME)'

`datime(-WHEN,+DATIME)'
     Convert a time stamp, as obtained by `now/1', to a `datime/6'
     record. Can be used in both directions.

`sleep(+SECONDS)'
     Puts the SICStus Prolog process asleep for SECOND seconds, where
     SECONDS should be a non-negative number.

`environ(?VAR, ?VALUE)'
     VAR is the name of a system property or an environment variable,
     and VALUE is its representation.  Both are atoms.  Can be used to enumerate
     all current system properties and environment variables.

     The same as `environ(VAR, VALUE, merged)'.

`environ(?VAR, ?VALUE, +SOURCE)   *since release 4.1*'
     VAR is the name of an environment variable or system property, and
     VALUE is its representation.  Both are atoms.  Can be used to enumerate all
     current environment variables and system properties.

     SOURCE is one of `properties', in which case only system
     properties are enumerated; `environment', in which case only
     environment variables are enumerated; and `merged', in which case
     both environment variables and system properties are enumerated.
     When SOURCE is `merged' and an environment variable and a system
     property have equivalent names, the representation of the system property
     is returned.

     On UNIX-like platforms, two names are equivalent if and only if
     they are identical.  On Windows-like platforms, a case insensitive
     comparison is used.

     *Note System Properties and Environment Variables::, for more
     information.



File: sicstus.info,  Node: lib-tcltk,  Next: lib-terms,  Prev: lib-system,  Up: The Prolog Library

10.37 Tcl/Tk Interface--`library(tcltk)'
========================================

* Menu:

* Introduction (Tcl):: Introduction
* Tcl:: Tcl
* Tk:: Tk
* The Tcl/Tk Prolog Library:: The Tcl/Tk Prolog Library
* Putting It All Together:: Putting It All Together
* Quick Reference:: Quick Reference
* Resources:: Resources


File: sicstus.info,  Node: Introduction (Tcl),  Next: Tcl,  Up: lib-tcltk

10.37.1 Introduction
--------------------

This is a basic tutorial for those SICStus Prolog users who would like
to add Tcl/Tk user interfaces to their Prolog applications.  The
tutorial assumes no prior knowledge of Tcl/Tk but, of course, does
assume the reader is proficient in Prolog.

   Aware that the reader may not have heard of Tcl/Tk, we will start by
answering three questions: what is Tcl/Tk? what is it good for? what
relationship does it have to Prolog?

* Menu:

* What Is Tcl/Tk?:: What Is Tcl/Tk?
* What Is Tcl/Tk Good For?:: What Is Tcl/Tk Good For?
* What Is Tcl/Tks Relationship to SICStus Prolog?:: What Is Tcl/Tks Relationship to SICStus Prolog?
* A Quick Example of Tcl/Tk in Action:: A Quick Example of Tcl/Tk in Action
* Outline of This Tutorial:: Outline of This Tutorial


File: sicstus.info,  Node: What Is Tcl/Tk?,  Next: What Is Tcl/Tk Good For?,  Up: Introduction (Tcl)

10.37.1.1 What Is Tcl/Tk?
.........................

Tcl/Tk, as its title suggests, is actually two software packages: Tcl
and Tk.  Tcl, pronounced _tickle_, stands for _tool command language_
and is a scripting language that provides a programming environment and
programming facilities such as variables, loops, and procedures. It is
designed to be easily extensible.

   Tk, pronounced _tee-kay_, is just such an extension to Tcl, which is
a "toolkit" for windowing systems. In other words, Tk adds facilities to
Tcl for creating and manipulating user interfaces based on windows and
widgets within those windows.


File: sicstus.info,  Node: What Is Tcl/Tk Good For?,  Next: What Is Tcl/Tks Relationship to SICStus Prolog?,  Prev: What Is Tcl/Tk?,  Up: Introduction (Tcl)

10.37.1.2 What Is Tcl/Tk Good For?
..................................

In combination the Tcl and Tk packages (we will call the combination
simply Tcl/Tk) are useful for creating graphical user interfaces (GUIs)
to applications. The GUI is described in terms of instances of Tk
widgets, created through calls in Tcl, and Tcl scripts that form the
glue that binds together the GUI and the application.  (If you are a
little lost at this point, all will be clear in a moment with  a simple
example.)

   There are lots of systems out there for adding GUIs to applications
so why choose Tcl/Tk? Tcl/Tk has several advantages that make it
attractive for this kind of work.  Firstly, it is good for rapid
prototyping of GUIs. Tcl is an interpreted scripting language. The
scripts can be modified and executed quickly, with no compilation
phase, so speeding up the development loop.

   Secondly, it is easier to use a system based on a scripting language,
such as Tcl/Tk, than many of the conventional packages available.  For
example, getting to grips with the X windows suite of C libraries is not
an easy task. Tcl/Tk can produce the same thing using simple scripting
with much less to learn.  The penalty for this is that programs written
in an interpreted scripting language will execute more slowly than
those written using compiled C library calls, but for many interfaces
that don't need great speed Tcl/Tk is fast enough and its ease of use
more than outweighs the loss of speed.  In any case, Tcl/Tk can easily
handle hundreds of events per mouse movement without the user noticing.

   Thirdly, Tcl/Tk is good for making cross-platform GUIs.  The Tk
toolkit has been ported to native look-and-feel widgets on Mac, PC
(Windows), and UNIX (X windows) platforms. You can write your scripts
once and they will execute on any of these platforms.

   Lastly, the software is distributed under a free software license
and so is available in both binary and source formats free of charge.


File: sicstus.info,  Node: What Is Tcl/Tks Relationship to SICStus Prolog?,  Next: A Quick Example of Tcl/Tk in Action,  Prev: What Is Tcl/Tk Good For?,  Up: Introduction (Tcl)

10.37.1.3 What Is Tcl/Tks Relationship to SICStus Prolog?
.........................................................

SICStus Prolog comes with a Prolog library for interfacing to Tcl/Tk.
The purpose of the library is to enable Prolog application developers to
add GUIs to their applications rapidly and easily.


File: sicstus.info,  Node: A Quick Example of Tcl/Tk in Action,  Next: Outline of This Tutorial,  Prev: What Is Tcl/Tks Relationship to SICStus Prolog?,  Up: Introduction (Tcl)

10.37.1.4 A Quick Example of Tcl/Tk in Action
.............................................

As a taster, we will show you two simple examples programs that use
SICStus Prolog with the Tcl/Tk extensions: the ubiquitous "hello world"
example; and a very simple telephone book look up example.

   You are not expected to understand how these examples work at this
stage.  They are something for you to quickly type in to see how easy it
is to add GUIs to Prolog programs through Tcl/Tk.  After reading
through the rest of this tutorial you will fully understand these
examples and be able to write your own GUIs.

   Here is the "Hello World" program; also in
`library('tcltk/examples/ex1.pl')':

     :- use_module(library(tcltk)).

     go :-
         tk_new([name('Example 1')], Interp),
         tcl_eval(Interp, 'button .fred -text "hello world"
                           -command { puts "hello world"}', _),
         tcl_eval(Interp, 'pack .fred', _),
         tk_main_loop.


 [image src="images/tcltkex1.png" text="" ]                   SICStus+Tcl/Tk hello world program.

To run it just start up SICStus (under Windows use `sicstus', not
`spwin'), load the program, and evaluate the Prolog goal `go'. The
first line of the `go' clause calls `tk_new/2', which creates a Tcl/Tk
interpreter and returns a handle `Interp' through which Prolog will
interact with the interpreter.  Next a call to `tcl_eval/3' is made,
which creates a button displaying the `hello world' text. Next a call
is made to `tcl_eval/3' that causes the button to be displayed in the
main application window. Finally, a call is make to `tk_main_loop/0'
that passes control to Tcl/Tk, making sure that window events are
serviced.

   See how simple it is with just a three line Prolog program to create
an application window and display a button in it.  Click on the button
and see what it does.

   The reason you should use `sicstus' under Windows instead of `spwin'
is that the latter does not have the C standard streams
(`stdin',`stdout',`stderr') and the Tcl command `puts' will give an
error if there is no `stdout'.

   The previous example showed us how to create a button and display
some text in it. It was basically pure Tcl/Tk generated from within
Prolog but did not have any interaction with Prolog.  The following
example demonstrates a simple callback mechanism. A name is typed into
a text entry box, a button is pressed, which looks up the telephone
number corresponding to the name in a Prolog database, and the telephone
number is then displayed.

   Here is the code; also in `library('tcltk/examples/ex2.pl')':

     :- use_module(library(tcltk)).

     telephone(fred, '123-456').
     telephone(wilbert, '222-2222').
     telephone(taxi, '200-0000').
     telephone(mary, '00-36-1-666-6666').

     go :-
          tk_new([name('Example 2')], T),
          tcl_eval(T, 'entry .name -textvariable name',_),
          tcl_eval(T, 'button .search -text search -command {
                           prolog telephone($name,X);
                           set result $prolog_variables(X) }', _),
          tcl_eval(T, 'label .result -relief raised -textvariable result', _),
          tcl_eval(T, 'pack .name .search .result -side top -fill x', _),
          tk_main_loop.


 [image src="images/tcltkex2.png" text="" ]                 SICStus+Tcl/Tk telephone number lookup

Again, to run the example, start up SICStus Prolog, load the code, and
run the goal `go'.

   You will notice that three widgets will appear in a window: one is
for entering the name of the person or thing that you want to find the
telephone number for, the button is for initiating the search, and the
text box at the bottom is for displaying the result.

   Type `fred' into the entry box, hit the search button and you should
see the phone number displayed. You can then try the same thing but
with `wilbert', `taxi' or `mary' typed into the text entry box.

   What is happening is that when the button is pressed, the representation in
the entry box is retrieved, then the `telephone/2' predicate is called
in Prolog with the entry box representation as first argument, then the second
argument of telephone is retrieved (by this time bound to the number)
and is displayed below the button.

   This is a very crude example of what can be done with the Tcl/Tk
module in Prolog. For example, this program does not handle cases where
there is no corresponding phone number or where there is more than one
corresponding phone number.  The example is just supposed to wet your
appetite, but all these problems can be handled by Prolog + Tcl/Tk,
although with a more sophisticated program. You will learn how to do
this in the subsequent chapters.


File: sicstus.info,  Node: Outline of This Tutorial,  Prev: A Quick Example of Tcl/Tk in Action,  Up: Introduction (Tcl)

10.37.1.5 Outline of This Tutorial
..................................

Now we have motivated using Tcl/Tk as a means of creating GUIs for
Prolog programs, this document goes into the details of using Tcl/Tk as
a means of building GUIs for SICStus Prolog applications.

   Firstly, Tcl is introduced and its syntax and core commands
described.  Then the Tk extensions to Tcl are introduced. We show how
with Tcl and Tk together the user can build sophisticated GUIs easily
and quickly.  At the end of this Tcl/Tk part of the tutorial an example
of a pure Tcl/Tk program will be presented together with some tips on
how to design and code Tcl/Tk GUIs.

   The second phase of this document describes the SICStus Prolog
`tcltk' library. It provides extensions to Prolog that allow Prolog
applications to interact with Tcl/Tk: Prolog can make calls to Tcl/Tk
code and vice versa.

   Having reached this point in the tutorial the user will know how to
write a Tcl/Tk GUI interface and how to get a Prolog program to
interact with it, but arranging which process (the Prolog process or the
Tcl/Tk process) is the dominant partner is non-trivial and so is
described in a separate chapter on event handling. This will help the
user choose the most appropriate method of cooperation between Tcl/Tk
and Prolog to suit their particular application.

   This section, the Tcl/Tk+Prolog section, will be rounded off with
the presentation of some example applications that make use of Tcl/Tk
and Prolog.

   Then there is a short discussion section on how to use other Tcl
extension packages with Tcl/Tk and Prolog. Many such extension packages
have been written and when added to Prolog enhanced with Tcl/Tk can
offer further functionality to a Prolog application.

   The appendices provide a full listing with description of the
predicates available in the `tcltk' SICStus Prolog library, and the
extensions made to Tcl/Tk for interacting with Prolog.

   Lastly, a section on resources gives pointers to where the reader can
find more information on Tcl/Tk.


File: sicstus.info,  Node: Tcl,  Next: Tk,  Prev: Introduction (Tcl),  Up: lib-tcltk

10.37.2 Tcl
-----------

Tcl is an interpreted scripting language. In this chapter, first the
syntax of Tcl is described and then the core commands are described.
It is not intended to give a comprehensive description of the Tcl
language here but an overview of the core commands, enough to get the
user motivated to start writing their own scripts.

   For pointers to more information on Tcl; *note Resources::.

* Menu:

* Syntax (Tcl):: Syntax
* Variables (Tcl):: Variables
* Commands:: Commands
* What We Have Left Out (Tcl):: What We Have Left Out


File: sicstus.info,  Node: Syntax (Tcl),  Next: Variables (Tcl),  Up: Tcl

10.37.2.1 Syntax
................

A Tcl script consists of a series of strings separated from each other
by a newline character. Each string contains a command or series of
semi-colon separated commands.  A command is a series of words separated
by spaces. The first word in a command is the name of the command and
subsequent words are its arguments.

   An example is:

     set a 1
     set b 2

which is a Tcl script of two commands: the first command sets the representation
of variable `a' to `1', and the second command sets the representation of
variable `b' to `2'.

   An example of two commands on the same line separated by a semi-colon
is:

     set a 1; set b 2

which is equivalent to the previous example but written entirely on one
line.

   A command is executed in two phases.  In the first phase, the
command is broken down into its constituent words and various textual
substitutions are performed on those words.  In the second phase, the
procedure to call is identified from the first word in the command, and
the procedure is called with the remaining words as arguments.

   There are special syntactic characters that control how the first
phase, the substitution phase, is carried out. The three major
substitution types are variable substitution, command substitution, and
backslash substitution.

   _Variable substitution_ happens when a `$' prefixed word is found in
a command.  There are three types of variable substitution:

   - `$NAME'
        - where NAME is a scalar variable. NAME is simply substituted
          in the word for its representation. NAME can contain only letters,
          digits, or underscores.

   - `$NAME(INDEX)'
        - where NAME is the name of an array variable and INDEX is the
          index into it. This is substituted by the representation of the array
          element.  NAME must contain only letters, digits, or
          underscores.  INDEX has variable, command, and backslash
          substitution performed on it too.

   - `${NAME}'
        - where NAME can have any characters in it except closing curly
          bracket.  This is more or less the same as `$NAME'
          substitution except it is used to get around the restrictions
          in the characters that can form NAME.

   An example of variable substitution is:

     set a 1
     set b $a

which sets the representation of variable `a' to `1', and then sets the representation of
variable `b' to the representation of variable `a'.

   _Command substitution_ happens when a word contains an open square
bracket, `['. The string between the open bracket and matching closing
bracket are treated as a Tcl script. The script is evaluated and its
result is substituted in place of the original command substitution
word.

   A simple example of command substitution is:

     set a 1
     set b [set a]

which does the same as the previous example but using command
substitution.  The result of a `set a' command is to return the representation
of `a', which is then passed as an argument to `set b' and so variable
`b' acquires the representation of variable `a'.

   _Backslash substitution_ is performed whenever the interpreter comes
across a backslash.  The backslash is an escape character and when it is
encountered is causes the interpreter to handle the next characters
specially.  Commonly escaped characters are `\a' for audible bell, `\b'
for backspace, `\f' for form feed, `\n' for newline, `\r' for carriage
return, `\t' for horizontal tab, and `\v' for vertical tab.
Double-backslash, `\\', is substituted with a single backslash.  Other
special backslash substitutions have the following forms:

   * `\ooo'
        - the digits `ooo' give the octal representation of the escaped character

   * `\xHH'
        - the `x' denotes that the following hexadecimal digits are the
          representation of the escaped character

   Any other character that is backslash escaped is simply substituted
by the character itself. For example, `\W' is replaced by `W'.

   A further syntactic construction is used to _delay substitution_.
When the beginning of a word starts with a curly bracket, `{', it does
not do any of the above substitutions between the opening curly bracket
and its matching closing curly bracket.  The word ends with the
matching closing curly bracket.  This construct is used to make the
bodies of procedures in which substitutions happen when the procedure is
called, not when it is constructed.  Or it is used anywhere when the
programmer does not want the normal substitutions to happen. For
example:

     puts {I have $20}

will print the string `I have $20' and will not try variable
substitution on the `$20' part.

   A word delineated by curly brackets is replaced with the characters
within the brackets without performing the usual substitutions.

   A word can begin with a _double-quote_ and end with the matching
closing double-quote. Substitutions as detailed above are done on the
characters between the quotes, and the result is then substituted for
the original word. Typically double-quotes are used to group sequences
of characters that contain spaces into a single command word.

   For example:

     set name "Fred the Great"
     puts "Hello my name is $name"

outputs `Hello my name is Fred the Great'. The first command sets the
representation of variable `name' to the following double-quoted string `"Fred
the Great"'. The the next command prints its argument, a single
argument because it is a word delineated by double-quotes, that has had
variable substitution performed on it.

   Here is the same example but using curly brackets instead of
double-quotes:

     set name {Fred the Great}
     puts {Hello my name is $name}

gives the output `Hello my name is $name' because substitutions are
suppressed by the curly bracket notation.

   And again the same example but without either curly brackets or
double-quotes:

     set name Fred the Great
     puts Hello my name is $name

simply fails because both `set' and `puts' expect a single argument but
without the word grouping effects of double-quotes or curly brackets
they find that they have more than one argument and throw an exception.

   Being a simple scripting language, Tcl does not have any real idea of
data types. The interpreter simply manipulates strings.  The Tcl
interpreter is not concerned with whether those strings contain
representations of numbers or names or lists.  It is up to the commands
themselves to interpret the strings that are passed to them as
arguments in any manner those choose.


File: sicstus.info,  Node: Variables (Tcl),  Next: Commands,  Prev: Syntax (Tcl),  Up: Tcl

10.37.2.2 Variables
...................

This has been dealt with implicitly above.  A variable has a name and a
representation.  A name can be any string whatsoever, as can its representation.

   For example,

     set "Old King Cole" "merry soul"

sets the representation of the variable named `Old King Cole' to the representation
`merry soul'. Variable names can also be numbers:

     set 123 "one two three"

sets the variable with name `123' to the representation `one two three'.  In
general, it is better to use the usual conventions -- start with a
letter then follow with a combination of letters, digits, and
underscores -- when giving variables names to avoid confusion.

   Array variables are also available in Tcl. These are denoted by an
array name followed by an array index enclosed in round brackets.  As
an example:

     set fred(one) 1
     set fred(two) 2

will set the variable `fred(one)' to the representation `1' and `fred(two)' to
the representation `2'.

   Tcl arrays are associative arrays in that both the array name and the
array index can be arbitrary strings. This also makes multidimensional
arrays possible if the index contains a comma:

     set fred(one,two) 12

   It is cheating in that the array is not stored as a multidimensional
array with a pair of indices, but as a linear array with a single index
that happens to contain a comma.


File: sicstus.info,  Node: Commands,  Next: What We Have Left Out (Tcl),  Prev: Variables (Tcl),  Up: Tcl

10.37.2.3 Commands
..................

Now that the Tcl syntax and variables have been been dealt with, we
will now look at some of the commands that are available.

   Each command when executed returns a representation. The return representation will be
described along with the command.

   A quick word about the _notation_ used to describe Tcl commands.  In
general, a description of a command is the name of the command followed
by its arguments separated by spaces.  An example is:

     set VARNAME ?VALUE?

which is a description of the Tcl set command, which takes a variable
name VARNAME and an optional argument, a VALUE.

   Optional arguments are enclosed in question mark, ?, pairs, as in
the example.

   A series of three dots ... represents repeated arguments. An example
is a description of the `unset' command:

     unset VARNAME ?VARNAME VARNAME ...?

which shows that the `unset' command has at least one compulsory
argument VARNAME but has any number of subsequent optional arguments.

   The most used _command over variables_ is the `set' command.  It has
the form

     set VARNAME ?VALUE?

   The representation of VALUE is determined, the variable VARNAME is set to it,
and the representation is returned. If there is no VALUE argument, the representation of
the variable is simply returned. It is thus used to set and/or get the
representation of a variable.

   The `unset' command is used to remove variables completely from the
system:

     unset VARNAME ?VARNAME VARNAME ...?

which given a series of variable names deletes them.  The empty string
is always returned.

   There is a special command for incrementing the representation of a variable:

     incr VARNAME ?INCREMENT?

which, given the name of a variable thats representation is an integer string,
increments it by the amount INCREMENT. If the INCREMENT part is left
out, it defaults to `1'. The return representation is the new representation of the
variable.

   _Expressions_ are constructed from operands and operators and can
then be evaluated.  The most general expression evaluator in Tcl is the
`expr' command:

     expr ARG ?ARG ARG ... ARG?

which evaluates its arguments as an expression and returns the representation of
the evaluation.

   A simple example expression is

     expr 2 * 2

which when executed returns the representation `4'.

   There are different classes of operators: arithmetic, relational,
logical, bitwise, and choice.  Here are some example expressions
involving various operators:

arithmetic     `$x * 2'
relational     `$x > 2'
logical        `($x == $y) || ($x == $z)'
bitwise        `8 & 2'
choice         `($a == 1) ? $x : $y'

   Basically the operators follow the syntax and meaning of their ANSI
C counterparts.

   Expressions to the `expr' command can be contained in curly brackets
in which case the usual substitutions are not done before the `expr'
command is evaluated, but the command does its own round of
substitutions. So evaluating a script such as:

     set a 1
     expr { ($a==1) : "yes" ? "no" }

will evaluate to `yes'.

   Tcl also has a whole host of math functions that can be used in
expressions.  Their evaluation is again the same as that for their ANSI
C counterparts.  For example:

     expr { 2*log($x) }

will return 2 times the natural log of the representation of variable `x'.

   Tcl has a notion of _lists_, but as with everything it is implemented
through strings. A list is a string that contains words.

   A simple list is just a space separated series of strings:

     set a {one two three four five}

will set the variable `a' to the list containing the five strings
shown. The empty list is denoted by an open and close curly bracket
pair with nothing in between: `{}'.

   For the Prolog programmer, there is much confusion between a Prolog
implementation of lists and the Tcl implementation of lists.  In Prolog
we have a definite notion of the printed representation of a list: a
list is a sequence of terms enclosed in square brackets (we ignore dot
notation for now); a nested list is just another term.

   In Tcl, however, a list is really just a string that conforms to a
certain syntax: a string of space separated words.  But in Tcl there is
more than one way of generating such a string.  For example,

     set fred {a b c d}

sets `fred' to

     "a b c d"

as does

     set fred "a b c d"

because `{a b c d}' evaluates to the string `a b c d', which has the
correct syntax for a list.  But what about nested lists?  Those are
represented in the final list-string as being contained in curly
brackets.  For example:

     set fred {a b c {1 2 3} e f}

results in `fred' having the representation

     "a b c {1 2 3} e f"

   The outer curly brackets from the `set' command have disappeared,
which causes confusion. The curly brackets within a list denote a nested
list, but there are no curly brackets at the top-level of the list.  (We
can't help thinking that life would have been easier if the creators of
Tcl would have chosen a consistent representation for lists, as Prolog
and LISP do.)

   So remember: a list is really a string with a certain syntax, space
separated items or words; a nested list is surrounded by curly brackets.

   There are a dozen commands that operate on lists.

     concat ?LIST LIST ...?

   This makes a list out of a series of lists by concatenating its
argument lists together. The return result is the list resulting from
the concatenation.

     lindex LIST INDEX

returns the INDEX-th element of the LIST.  The first element of a list
has an index of 0.

     linsert LIST INDEX VALUE ?VALUE ...?

returns a new list in which the VALUE arguments have been inserted in
turn before the INDEX-th element of LIST.

     list ?VALUE VALUE ...?

returns a list where each element is one of the VALUE arguments.

     llength LIST

returns the number of elements in list LIST.

     lrange LIST FIRST LAST

returns a slice of a list consisting of the elements of the list LIST
from index FIRST until index LAST.

     lreplace LIST FIRST LAST ?VALUE ... VALUE?

returns a copy of list LIST but with the elements between indices FIRST
and LAST replaced with a list formed from the VALUE arguments.

     lsearch ?-exact? ?-glob? ?-regexp? LIST PATTERN

returns the index of the first element in the list that matches the
given pattern. The type of matching done depends on which of the switch
is present `-exact', `-glob', `-regexp', is present. Default is `-glob'.

     lsort ?-ascii? ?-integer? ?-real? ?-command COMMAND? ?-increasing? ?-decreasing{? LIST

returns a list, which is the original list LIST sorted by the chosen
technique. If none of the switches supplies the intended sorting
technique, the user can provide one through the `-command COMMAND'
switch.

   There are also two useful commands for converting between lists and
strings:

     join LIST ?JOINSTRING?

which concatenates the elements of the list together, with the separator
JOINSTRING between them, and returns the resulting string.  This can be
used to construct filenames; for example:

     set a {{} usr local bin}
     set filename [join $a /]

results in the variable `filename' having the representation `/usr/local/bin'.

   The reverse of the `join' command is the `split' command:

     split STRING ?SPLITCHARS?

which takes the string STRING and splits it into string on SPLITCHARS
boundaries and returns a list with the strings as elements.  An example
is splitting a filename into its constituent parts:

     set a [split /usr/local/src /]

gives `a' the representation `{{} usr local src}', a list.

   Tcl has the four usual classes of _control flow_ found in most other
programming languages:

     if...elseif...else, while, for, foreach, switch, and eval.

   We go through each in turn.

   The general form of an `if' command is the following:

     if TEST1 BODY1 ?ELSEIF TEST2 BODY2 ELSEIF ...? ?ELSE BODYN?

which when evaluated, evaluates expression TEST1, which if true causes
BODY1 to be evaluated, but if false, causes TEST2 to be evaluated, and
so on.  If there is a final `else' clause, its BODYN part is evaluated
if all of the preceding tests failed.  The return result of an `if'
statement is the result of the last BODY command evaluated, or the
empty list if none of the bodies are evaluated.

   Conditional looping is done through the `while' command:

     while TEST BODY

which evaluates expression TEST, which if true then evaluates BODY.  It
continues to do that until TEST evaluates to 0, and returns the empty
string.

   A simple example is:

     set a 10
     while {$a > 0} { puts $a; incr a -1 }

which initializes variable `a' with representation ten and then loops printing
out the representation of `a' and decrementing it until its representation is 0, when the
loop terminates.

   The `for' loop has the following form:

     for INIT TEST REINIT BODY

which initializes the loop by executing INIT, then each time around the
loop the expression TEST is evaluated, which if true causes BODY to be
executed and then executes REINIT. The loop spins around until TEST
evaluates to 0.  The return result of a `for' loop is the empty string.

   An example of a `for' loop:

     for {set a 10} ($a>0) {incr a -1} {puts $a}

which initializes the variable `a' with representation `10', then goes around
the loop printing the representation of `a' and decrementing it as long as its
representation is greater than `0'.  Once it reaches `0' the loop terminates.

   The `foreach' command has the following form:

     foreach VARNAME LIST BODY

where VARNAME is the name of a variable, LIST is an instance of a list,
and BODY is a series of commands to evaluate.  A `foreach' then
iterates over the elements of a list, setting the variable VARNAME to
the current element, and executes BODY.  The result of a `foreach' loop
is always the empty string.

   An example of a `foreach' loop:

     foreach friend {joe mary john wilbert} {puts "I like $friend"}

will produce the output:

     I like joe
     I like mary
     I like john
     I like wilbert

   There are also a couple of commands for controlling the flow of
loops: `continue' and `break'.

   `continue' stops the current evaluation of the body of a loop and
goes on to the next one.

   `break' terminates the loop altogether.

   Tcl has a general switch statement, which has two forms:

     switch ?OPTIONS? STRING PATTERN BODY ?PATTERN BODY ... ?
     switch ?OPTIONS? STRING { PATTERN BODY ?PATTERN BODY ...? }

   When executed, the switch command matches its STRING argument
against each of the PATTERN arguments, and the BODY of the first
matching pattern is evaluated.  The matching algorithm depends on the
options chosen, which can be one of

`-exact'      use exact matching
`-glob'       use glob-style matching
`-regexp'     use regular expression matchinig

   An example is:

     set a rob
     switch -glob $a {
         a*z { puts "A to Z"}
         r*b { puts "rob or rab"}
     }

which will produce the output:

     rob or rab

   There are two forms of the `switch' command. The second form has the
command arguments surrounded in curly brackets. This is primarily so
that multi-line switch commands can be formed, but it also means that
the arguments in brackets are not evaluated (curly brackets suppress
evaluation), whereas in the first type of switch statement the
arguments are first evaluated before the switch is evaluated.  These
effects should be borne in mind when choosing which kind of switch
statement to use.

   The final form of control statement is `eval':

     eval ARG ?ARG ...?

which takes one or more arguments, concatenates them into a string, and
executes the string as a command. The return result is the normal
return result of the execution of the string as a command.

   An example is

     set a b
     set b 0
     eval set $a 10

which results in the variable `b' being set to `10'.  In this case, the
return result of the `eval' is `10', the result of executing the string
`"set b 10"' as a command.

   Tcl has several _commands over strings_. There are commands for
searching for patterns in strings, formatting and parsing strings (much
the same as `printf' and `scanf' in the C language), and general string
manipulation commands.

   Firstly we will deal with formatting and parsing of strings.  The
commands for this are `format' and `scan' respectively.

     format FORMATSTRING ?VALUE VALUE ...?

which works in a similar to C's `printf'; given a format string with
placeholders for values and a series of values, return the appropriate
string.

   Here is an example of printing out a table for base 10 logarithms
for the numbers 1 to 10:

     for {set n 1} {$n <= 10} {incr n} {
         puts [format "log10(%d) = %.4f" $n [expr log10($n)]]
     }

which produces the output

     ln(1) = 0.0000
     ln(2) = 0.3010
     ln(3) = 0.4771
     ln(4) = 0.6021
     ln(5) = 0.6990
     ln(6) = 0.7782
     ln(7) = 0.8451
     ln(8) = 0.9031
     ln(9) = 0.9542
     ln(10) = 1.0000

   The reverse function of `format' is `scan':

     scan STRING FORMATSTRING VARNAME ?VARNAME ...?

which parses the string according to the format string and assigns the
appropriate values to the variables.  it returns the number of fields
successfully parsed.

   An example,

     scan "qty 10, unit cost 1.5, total 15.0" \
          "qty %d, unit cost %f, total %f"    \
          quantity cost_per_unit total

would assign the representation 10 to the variable `quantity', 1.5 to the
variable `cost_per_unit' and the representation 15.0 to the variable `total'.

   There are commands for performing two kinds of pattern matching on
strings: one for matching using regular expressions, and one for
matching using UNIX-style wildcard pattern matching (globbing).

   The command for regular expressions matching is as follows:

     regexp ?-indices? ?-nocase? EXP STRING ?MATCHVAR? ?SUBVAR SUBVAR ...?

where EXP is the regular expression and STRING is the string on which
the matching is performed. The regexp command returns 1 if the
expression matches the string, 0 otherwise.  The optional `-nocase'
switch does matching without regard to the case of letters in the
string.  The optional MATCHVAR and SUBVAR variables, if present, are
set to the values of string matches. In the regular expression, a match
that is to be saved into a variable is enclosed in round braces.  An
example is

     regexp {([0-9]+)} "I have 3 oranges" a

will assign the representation 3 to the variable `a'.

   If the optional switch `-indices' is present, instead of storing the
matching substrings in the variables, the indices of the substrings are
stored; that is a list with a pair of numbers denoting the start and
end position of the substring in the string.  Using the same example:

     regexp -indices {([0-9]+)} "I have 3 oranges" a

will assign the representation `"7 7"', because the matched numeral `3' is in
the eighth position in the string, and indices count from 0.

   String matching using the UNIX-style wildcard pattern matching
technique is done through the `string match' command:

     string match PATTERN STRING

where PATTERN is a wildcard pattern and STRING is the string to match.
If the match succeeds, the command returns 1; otherwise, it returns 0.
An example is

     string match {[a-z]*[0-9]} {a_$%^_3}

which matches because the command says match any string that starts
with a lower case letter and ends with a number, regardless of anything
in between.

   There is a command for performing string substitutions using regular
expressions:

     regsub ?-all? ?-nocase? EXP STRING SUBSPEC VARNAME

where EXP is the regular expression and STRING is the input string on
which the substitution is made, SUBSPEC is the string that is
substituted for the part of the string matched by the regular
expression, and VARNAME is the variable on which the resulting string
is copied into.  With the `-nocase' switch, the matching is done
without regard to the case of letters in the input string.  The `-all'
switch causes repeated matching and substitution to happen on the input
string.  The result of a `regsub' command is the number of
substitutions made.

   An example of string substitution is:

     regsub {#name#} {My name is #name#} Rob result

which sets the variable `result' to the representation "My name is Rob".  An
example of using the `-all' switch:

     regsub -all {#name#} {#name#'s name is #name#} Rob result

sets the variable `result' to the representation "Rob's name is Rob" and it
returns the representation 2 because two substitutions were made.

   The are a host of other ways to manipulate strings through variants
of the `string' command. Here we will go through them.

   To select a character from a string given the character position,
use the `string index' command. An example is:

     string index "Hello world" 6

which returns `w', the 7th character of the string.  (Strings are
indexed from 0).

   To select a substring of a string, given a range of indices use the
`string range' command. An example is:

     string range "Hello world" 3 7

which returns the string "lo wo".  There is a special index marker
named `end', which is used to denote the the end of a string, so the
code

     string range "Hello world" 6 end

will return the string "world".

   There are two ways to do simple search for a substring on a string,
using the `string first' and `string last' commands.  An example of
`string first' is:

     string first "dog" "My dog is a big dog"

find the first position in string "My dog is a big dog" that matches
"dog".  It will return the position in the string in which the
substring was found, in this case 3. If the substring cannot be found,
the representation -1 is returned.

   Similarly,

     string last "dog" "My dog is a big dog"

will return the representation 16 because it returns the index of the last place
in the string that the substring matches.  Again, if there is no match,
-1 is returned.

   To find the length of a string use `string length', which given a
string simply returns its length.

     string length "123456"

returns the representation 6.

   To convert a string completely to upper case use `string toupper':

     string toupper "this is in upper case"

returns the string "THIS IS IN UPPER CASE".

   Similarly,

     string tolower "THIS IS IN LOWER CASE"

returns the string "this is in lower case".

   There are commands for removing characters from strings: `string
trim', `string trimright', and `string trimleft'.

     string trim STRING ?CHARS?

which removes the characters in the string CHARS from the string STRING
and returns the trimmed string.  If CHARS is not present, whitespace
characters are removed.  An example is:

     string string "The dog ate the exercise book" "doe"

which would return the string "Th g at th xrcis bk".

   `string trimleft' is the same as `string trim' except only leading
characters are removed. Similarly `string trimright' removes only
trailing characters.  For example:

     string trimright $my_input

would return a copy of the string contained in `$my_input' but with all
the trailing whitespace characters removed.

   There is a comprehensive set of commands for _file manipulation_.
We will cover only the some of the more important ones here.

   To open a file the `open' command is used:

     open NAME ?ACCESS?

where NAME is a string containing the filename, and the option ACCESS
parameter contains a string of access flags, in the UNIX style.  The
return result is a handle to the open file.

   If ACCESS is not present, the access permissions default to `"r"',
which means open for reading only.  The command returns a file handle
that can be used with other commands.  An example of the use of the
`open' command is

     set fid [open "myfile" "r+"]

which means open the file `myfile' for both reading and writing and set
the variable `fid' to the file handle returned.

   To close a file simply use

     close FILEID

   For example,

     close $fid

will close the file that has the file handle stored in the variable
`fid'.

   To read from a file, the `read' command is used:

     read FILEID NUMBYTES

which reads NUMBYTES bytes from the file attached to file handle
FILEID, and returns the bytes actually read.

   To read a single line from a file use `gets':

     gets FILEID ?VARNAME?

which reads a line from the file attached to file handle FILEID but
chops off the trailing newline. If variable VARNAME is specified, the
string read in is stored there and the number of bytes is returned by
the command. If the variable is not specified, the command returns the
string only.

   To write to a file, use `puts':

     puts ?-nonewline? ?FILEID? STRING

which outputs the string STRING. If the file handle FILEID is present,
the string is output to that file; otherwise, it is printed on
`stdout'.  If the switch `-nonewline' is present, a trailing newline is
not output.

   To check if the end of a file has been reached, use `eof':

     eof FILEID

which, given a file handle FILEID returns 1 if the end has been reached,
and 0 otherwise.

   The are a host of other commands over files and processes, which we
will not go into here.

   (For extra information on file I/O commands, refer to the Tcl manual
pages.)

   Tcl provides a way of _creating new commands_, called procedures,
that can be executed in scripts. The arguments of a procedure can be
call-by-representation or call-by-reference, and there is also a facility for
creating new user defined control structures using procedures.

   A procedure is declared using the `proc' command:

     proc NAME ARGLIST BODY

where the name of the procedure is NAME, the arguments are contained in
ARGLIST and the body of the procedure is the script BODY.  An example
of a procedure is:

     proc namePrint { first family } {
         puts "My first name is $first"
         puts "My family name is $family"
     }

which can be called with

     namePrint Tony Blair

to produce the output:

     My first name is Tony
     My family name is Blair

   A procedure with no arguments is specified with an empty argument
list.  An example is a procedure that just prints out a string:

     proc stringThing {} {
         puts "I just print this string"
     }

   Arguments can be given defaults by pairing them with a representation in a
list.  An example here is a counter procedure:

     proc counter { representation { inc 1 } } {
         eval $representation + $inc
     }

which can be called with two arguments like this

     set v 10
     set v [counter $v 5]

which will set variable `v' to the representation 15; or it can be called with
one argument:

     set v 10
     set v [counter $v]

in which case `v' will have the representation 11, because the default of the
argument `inc' inside the procedure is the representation 1.

   There is a special argument for handling procedures with variable
number of arguments, the `args' argument.  An example is a procedure
that sums a list of numbers:

     proc sum { args } {
         set result 0;

         foreach n $args {
          set result [expr $result + $n ]
         }

         return $result;
     }

which can be called like this:

     sum 1 2 3 4 5

which returns the representation 15.

   The restriction on using defaulted arguments is that all the
arguments that come after the defaulted ones must also be defaulted.
If `args' are used, it must be the last argument in the argument list.

   A procedure can return a representation through the `return' command:

     return ?OPTIONS? ?VALUE?

which terminates the procedure returning representation VALUE, if specified, or
just causes the procedure to return, if no representation specified.  (The
?OPTIONS? part has to do with raising exceptions, which we will will
not cover here.)

   The return result of a user defined procedure is the return result
of the last command executed by it.

   So far we have seen the arguments of a procedure are passed using
the call-by-representation mechanism.  They can be passed call by reference using
the `upvar' command:

     upvar ?LEVEL? OTHERVAR1 MYVAR1 ?OTHERVAR2 MYVAR2 ...?

which makes accessible variables somewhere in a calling context with the
current context. The optional argument LEVEL describes how many calling
levels up to look for the variable.  This is best shown with an example:

     set a 10
     set b 20

     proc add { first second } {
         upvar $first f $second s
         expr $f+$s
     }

which when called with

     add a b

will produce the result 30.  If you use call-by-representation instead:

     add $a $b

the program will fail because when executing the procedure `add' it
will take the first argument 10 as the level argument, a bad level.
(Also variable `20' doesn't exist at any level.)

   New control structures can be generated using the `uplevel' command:

     uplevel ?LEVEL? ARG ?ARG ARG ...?

which is like `eval', but it evaluates its arguments in a context
higher up the calling stack. How far up the stack to go is given by the
optional LEVEL argument.

     proc do { loop condition } {
         set nostop 1

         while { $nostop } {
             uplevel $loop
             if {[uplevel "expr $condition"] == 0} {
                 set nostop 0
              }
         }
     }

which when called with this

     set x 5
     do { puts $x; incr x -1 } { $x > 0 }

will print

     5
     4
     3
     2
     1

   (*Please note*: this doesn't quite work for all kinds of calls
because of `break', `continue', and `return'. It is possible to get
around these problem, but that is outside the scope of this tutorial.)

   A word about the _scope of variables_. Variables used within
procedures are normally created only for the duration of that procedure
and have local scope.

   It is possible to declare a variable as having global scope, through
the `global' command:

     global NAME1 ? NAME2 ...?

where NAME1, NAME2, ..., are the names of global variables.  Any
references to those names will be taken to denote global variables for
the duration of the procedure call.

   Global variables are those variables declared at the topmost calling
context. It is possible to run a `global' command at anytime in a
procedure call. After such a command, the variable name will refer to a
global variable until the procedure exits.

   An example:

     set x 10

     proc fred { } {
         set y 20
         global x
         puts [expr $x + $y]
     }

     fred

will print the result `30' where 20 comes from the local variable `y'
and 10 comes from the global variable `x'.

   Without the `global x' line, the call to `fred' will fail with an
error because there is no variable `x' defined locally in the procedure
for the `expr' to evaluate over.

   In common with other scripting languages, there is a command for
_evaluating the contents of a file_ in the Tcl interpreter:

     source FILENAME

where FILENAME is the filename of the file containing the Tcl source to
be evaluated. Control returns to the Tcl interpreter once the file has
been evaluated.


File: sicstus.info,  Node: What We Have Left Out (Tcl),  Prev: Commands,  Up: Tcl

10.37.2.4 What We Have Left Out
...............................

We have left out a number of Tcl commands as they are outside of the
scope of this tutorial. We list some of them here to show some of what
Tcl can do. Please refer to the Tcl manual for more information.

"http"
     implements the HTTP protocol for retrieving web pages

"namespaces"
     a modules systems for Tcl

"trace"
     commands can be attached to variables that are triggered when the
     variable changes representation (amongst other things)

"processes"
     start, stop, and manage processes

"sockets"
     UNIX and Internet style socket management

"exception handling"

"3rd party extension packages"
     load extension packages into Tcl and use their facilities as
     native Tcl commands


File: sicstus.info,  Node: Tk,  Next: The Tcl/Tk Prolog Library,  Prev: Tcl,  Up: lib-tcltk

10.37.3 Tk
----------

Tk is an extension to Tcl. It provides Tcl with commands for easily
creating and managing graphical objects, or widgets, so providing a way
to add graphical user interfaces (GUIs) to Tcl applications.

   In this section we will describe the main Tk widgets, the Tcl
commands used to manipulate them, how to give them behaviors, and
generally how to arrange them into groups to create a GUI.

* Menu:

* Widgets:: Widgets
* Types of Widget:: Types of Widget
* Widgets Hierarchies:: Widgets Hierarchies
* Widget Creation:: Widget Creation
* Geometry Managers:: Geometry Managers
* Event Handling:: Event Handling
* Miscellaneous:: Miscellaneous
* What We Have Left Out (Tk):: What We Have Left Out
* Queens Display:: Example pure Tcl/Tk program


File: sicstus.info,  Node: Widgets,  Next: Types of Widget,  Up: Tk

10.37.3.1 Widgets
.................

A widget is a "window object". It is something that is displayed that
has at least two parts: a state and a behavior.  An example of a widget
is a button.  Its state is things like what color is it, what text is
written it in, and how big it is.  Its behavior is things like what it
does when you click on it, or what happens when the cursor is moved
over or away from it.

   In Tcl/Tk there are three parts to creating a useful widget.  The
first is creating an instance of the widget with its initial state.
The second is giving it a behavior by defining how the widget behaves
when certain events happen -- event handling.  The third is actually
displaying the widget possibly in a group of widgets or inside another
widget -- geometry management.  In fact, after creating all the widgets
for a GUI, they are not displayed until handled by a geometry manager,
which has rules about how to calculate the size of the widgets and how
they will appear in relation to each other.


File: sicstus.info,  Node: Types of Widget,  Next: Widgets Hierarchies,  Prev: Widgets,  Up: Tk

10.37.3.2 Types of Widget
.........................

In Tcl/Tk there are currently 15 types of widget.  In alphabetical
order they are (see also `library('tcltk/examples/widgets.tcl')'):

`button'
     a simple press button

`canvas'
     is a container for displaying "drawn" objects such as lines,
     circles, and polygons.

`checkbutton'
     a button that hold a state of either on or off

`entry'
     a text entry field

`frame'
     a widget that is a container for other widgets

`label'
     a simple label

`listbox'
     a box containing a list of options

`menu'
     a widget for creating menu bars

`menubutton'
     a button, which when pressed offers a selection of choices

`message'
     a multi-line text display widget

`radiobutton'
     a button used to form groups of mutually interacting buttons (When
     one button is pressed down, the others pop up.)

`scale'
     is like a slider on a music console. It consists of a trough scale
     and a slider. Moving the slider to a position on the scale sets
     the overall representation of the widget to that representation.

`scollbar'
     used to add scrollbars to windows or canvases. The scrollbar has a
     slider, which when moved changes the representation of the slider widget.

`text'
     a sophisticated multi-line text widget that can also display other
     widgets such as buttons

`toplevel'
     for creating new standalone toplevel windows. (These windows are
     containers for other widgets. They are not terminal windows.)


 [image src="images/tcltkwidgets.png" text="" ]                        Meet The Main Tk Widgets


File: sicstus.info,  Node: Widgets Hierarchies,  Next: Widget Creation,  Prev: Types of Widget,  Up: Tk

10.37.3.3 Widgets Hierarchies
.............................

Before going further it is necessary to understand how instances of
widgets are named.  Widgets are arranged in a hierarchy. The names of
widget instances are formed from dot separated words.  The root window
is simply `.' on its own.  So for, example, a button widget that is
displayed in the root window might have the name `.b1'.  A button that
is displayed inside a frame that is displayed inside the root window
may have the name `.frame1.b1'.  The frame would have the name
`.frame1'.

   Following this notation, it is clear that widgets are both formed in
hierarchies, with the dot notation giving the path to a widget, and in
groups, all widgets with the same leading path are notionaly in the
same group.

   (It is a similar to the way file systems are organized.   A file has
a path that shows where to find it in the hierarchical  file system.
But also files with the same leading path are in the same
directory/folder and so are notionaly grouped together.)

   An instance of a widget is created through the a Tcl command for that
widget.  The widget command my have optional arguments set for
specifying various attributes of the widget that it will have when it is
created.  The result of a successful widget command is the name of the
new widget.

   For example, a command to create a button widget named `.mybutton'
that displays the text "I am a button" would look like this:

     button .mybutton -text "I am a button"

and this will return the name `.mybutton'.

   A widget will only be created if all the windows/widgets in the
leading path of the new widget also exist, and also that the name of
the new widget does not already exist.

   For example, the following

     button .mybutton -text "I am a button"
     button .mybutton -text "and so am I"

will fail at the second command because there is also a widget named
`.mybutton' from the first command.

   The following will also fail

     button .frame.mybutton -text "I am a button"

if there is no existing widget with the name `.frame' to be the parent
of `.mybutton'.

   All this begs the question: why are widgets named and arranged in a
hierarchy? Isn't a GUI just a bunch of widgets displayed in a window?

   This is not generally how GUIs are arranged.  For example, they
often have a menubar over the top of each window.  The menubar contains
pulldown menus. The pulldown menus may have cascading menu items that
may cascade down several levels.  Under the menu bar is the main part
of the window that may also be split into several "frames". A left hand
frame my have a set of buttons in it, for example. And so on.  From
this you can see that the widgets in GUIs are naturally arranged in a
hierarchy. To achieve this in Tcl/Tk instances of widgets are placed in
a hierarchy, which is reflected in their names.

   Now we will go through each of the widget commands in turn.  Each
widget command has many options most of which will not be described
here. Just enough will be touched on for the reader to understand the
basic operation of each widget.  For a complete description of each
widget and its many options refer to the Tk manual.


File: sicstus.info,  Node: Widget Creation,  Next: Geometry Managers,  Prev: Widgets Hierarchies,  Up: Tk

10.37.3.4 Widget Creation
.........................

As has already been said, a widget is a window object that has state and
behavior. In terms of Tcl/Tk a widget is created by calling a widget
creation command. There is a specific widget creation for each type of
widget.

   The widget creation command is supplied with arguments.  The first
argument is always the name you want to give to the resulting widget;
the other arguments set the initial state of the widget.

   The immediate result of calling a widget creation command is that it
returns the name of the new widget. A side-effect is that the instance
of the widget is created and its name is defined as in the Tcl
interpreter as a procedure through which the widget state can be
accessed and manipulated.

   This needs an example. We will use the widget creator command
`button' to make a button widget:

     button .fred -text 'Fred' -background red

which creates an instance of a button widget named `.fred' that will
display the text `Fred' on the button and will have a red background
color. Evaluating this command returns the string `.fred', the name of
the newly created widget.

   As a side-effect, a Tcl procedure named `.fred' is created.  A call
to a widget instance has the following form:

     WIDGETNAME METHOD METHODARGS

where WIDGETNAME is the name of the widget to be manipulated, METHOD is
the action to be performed on the widget, and METHODARGS are the
arguments passed to the method that is performed on the widget.

   The two standard methods for widgets are `configure' and `cget'.
`configure' - is used to change the state of a widget; for example:

     .fred configure -background green -text 'Sid'

will change the background color of the widget `.fred' to green and the
text displayed to `Sid'.

   `cget' is used to get part of the state of a widget; for example:

     .fred cget -text

will return `Sid' if the text on the button `.fred' is `Sid'.

   In addition to these general methods, there are special methods for
each widget type. For example, with button widgets you have the `flash'
and `invoke' methods.

   For example,

     .fred invoke

can be called somewhere in the Tcl code to invoke button `.fred' as
though it had been clicked on.

     .fred flash

can be called somewhere in the Tcl code to cause the button to flash.

   We will come across some of these special method when we discuss the
widgets in detail. For a comprehensive list of widget methods, refer to
entry for the appropriate widget creation command in the Tcl/Tk manual.

   We now discuss the widget creation command for each widget type.

   A _label_ is a simple widget for displaying a single line of text.
An example of creating an instance of a label is

     label .l -text "Hello world!"

which simply creates the label named `.l' with the text `Hello world!'
displayed in it.  Most widgets that display text can have a variable
associated with them through the option `-textvariable'. When the representation
of the variable is changed the text changes in the associated label.
For example,

     label .l -text "Hello world!" -textvariable mytext

creates a text label called `.l' displaying the initial text `Hello
world!'  and associated text variable `mytext'; `mytext' will start
with the representation `Hello world!'.  However, if the following script is
executed:

     set mytext "Goodbye moon!"

the text in the label will magically change to `Goodbye moon!'.

   A _message widget_ is similar to a label widget but for multi-line
text.  As its name suggests it is mostly used for creating popup message
information boxes.

   An example of a message widget is

     message .msg -text "Your data is incorrect.\n\n \
                   Please correct it and try again." \
         -justify center

which will create a message widget displaying the text shown, center
justified.  The width of the message box can be given through the
`-width' switch.  Any lines that exceed the width of the box are
wrapped at word boundaries.

   Calling the `button' command creates an instance of a _button
widget_.  An example is:

     button .mybutton -text "hello" -command {puts "howdie!"}

which creates a button with name `.mybutton' that will display the text
"hello" and will execute the Tcl script `puts "howdie!"' (that is print
`howdie!' to the terminal) when clicked on.

   _Checkbuttons_ are buttons that have a fixed state that is either on
or off. Clicking on the button toggles the state.  To store the state,
a checkbutton is associated with a variable.  When the state of the
checkbutton changes, so does that of the variable.  An example is:

     checkbutton .on_or_off -text "I like ice cream" -variable ice

which will create a checkbutton with name `.on_or_off' displaying the
text `I like ice cream' and associated with the variable `ice'.  If the
checkbutton is checked, `ice' will have the representation 1; if not checked, it
will have the representation 0.  The state of the checkbutton can also be
changed by changing the state of the variable. For example, executing

     set ice 0

will set the state of `.on_or_off' to not checked.

   _Radiobuttons_ are buttons that are grouped together to select one
representation among many. Each button has a representation, but only one in the button
group is active at any one time.  In Tcl/Tk this is achieved by
creating a series of radiobutton that share an associated variable.
Each button has a representation. When a radiobutton is clicked on, the variable
has that representation and all the other buttons in the group are put into the
off state.  Similarly, setting the representation of the variable is reflected
in the state of the button group.  An example is:

     radiobutton .first -representation one -text one -variable count
     radiobutton .second -representation two -text two -variable count
     radiobutton .third -representation three -text three -variable count

which creates three radiobuttons that are linked through the variable
`count'. If button `.second' is active, for example, the other two
buttons are in the inactive state and `count' has the representation `two'.  The
following code sets the button group to make the button `.third' active
and the rest inactive regardless of the current state:

     set count three

   If the representation of `count' does not match any of the values of the
radiobuttons, they will all be off. For example executing the script

     set count four

will turn all the radiobuttons off.

   An _entry widget_ allows input of a one line string.  An example of
an entry widget:

     label .l -text "Enter your name"
     entry .e -width 40 -textvariable your_name

would display a label widget named `.l' showing the string `Enter your
name' and an entry widget named `.e' of width 40 characters.  The representation
of variable `your_name' will reflect the string in the entry widget: as
the entry widget string is updated, so is the representation of the variable.
Similarly, changing the representation of `your_name' in a Tcl script will
change the string displayed in the entry field.

   A _scale widget_ is for displaying an adjustable slider.  As the
slider is moved its representation, which is displayed next to the slider,
changes.  To specify a scale, it must have `-from' and `-to' attributes,
which is the range of the scale. It can have a `-command' option, which
is set to a script to evaluate when the representation of the slider changes.

   An example of a scale widget is:

     scale .s -from 0 -to 100

which creates a scale widget with name `.s' that will slide over a
range of integers from 0 to 100.

   There are several other options that scales can have.  For example
it is possible to display tick marks along the length of the scale
through the `-tickinterval' attribute, and it is possible to specify
both vertically and horizontally displayed scales through the `-orient'
attribute.

   A _listbox_ is a widget that displays a list of single line strings.
One or more of the strings may be selected through using the mouse.
Initializing and manipulating the contents of a listbox is done through
invoking methods on the instance of the listbox.  As examples, the
`insert' method is used to insert a string into a listbox, `delete' to
delete one, and `get' to retrieve a particular entry. Also the
currently selected list items can be retrieved through the `selection'
command.

   Here is an example of a listbox that is filled with entries of the
form `entry N':

     listbox .l
     for { set i 0 } { $i<10 } { incr i } {
         .l insert end "entry $i"
     }

   A listbox may be given a height and/or width attribute, in which
case it is likely that not all of the strings in the list are visible
at the same time. There are a number of methods for affecting the
display of such a listbox.

   The `see' method causes the listbox display to change so that a
particular list element is in view.  For example,

     .l see 5

will make sure that the sixth list item is visible. (List elements are
counted from element 0.)

   A _scrollbar_ widget is intended to be used with any widget that is
likely to be able to display only part of its contents at one time.
Examples are listboxes, canvases, text widgets, and frames, amongst
others.

   A scrollbar widget is displayed as a movable slider between two
arrows.  Clicking on either arrow moves the slider in the direction of
the arrow.  The slider can be moved by dragging it with the cursor.

   The scollbar and the widget it scrolls are connected through Tcl
script calls. A scrollable widgets will have a `scrollcommand'
attribute that is set to a Tcl script to call when the widget changes
its view. When the view changes the command is called, and the command
is usually set to change the state of its associated scrollbar.

   Similarly, the scrollbar will have a `command' attribute that is
another script that is called when an action is performed on the
scrollbar, like moving the slider or clicking on one of its arrows.
That action will be to update the display of the associated scrollable
widget (which redraws itself and then invokes its `scrollcommand',
which causes the scrollbar to be redrawn).

   How this is all done is best shown through an example:

     listbox .l -yscrollcommand ".s set" -height 10
     scrollbar .s -command ".l yview"
     for { set i 0 } { $i < 50 } { incr i } {
         .l insert end "entry $i"
     }

creates a listbox named `.l' and a scrollbar named `.s'. Fifty strings
of the form `entry N' are inserted into the listbox.  The clever part
is the way the scrollbar and listbox are linked.  The listbox has its
`-yscrollcommand' attribute set to the script `".s set"'. What happens
is that if the view of `.l' is changed, this script is called with 4
arguments attached: the number of entries in the listbox, the size of
the listbox window, the index of the first entry currently visible, and
the index of the last entry currently visible. This is exactly enough
information for the scrollbar to work out how to redisplay itself.  For
example, changing the display of the above listbox could result in the
following `-yscrollcommand' script being called:

     .s set 50 10 5 15

which says that the listbox contains 50 elements, it can display 10 at
one time, the first element displayed has index 5 and the last one on
display has index 15. This call invokes the `set' method of the
scrollbar widget `.s', which causes it to redraw itself appropriately.

   If, instead, the user interacts with the scrollbar, the scrollbar
will invoke its `-command' script, which in this example is `".l
yview"'. Before invoking the script, the scrollbar widget calculates
which element should the first displayed in its associated widget and
appends its index to the call.  For example, if element with index 20
should be the first to be displayed, the following call will be made:

     .l yview 20

which invokes the `yview' method of the listbox `.l'. This causes `.l'
to be updated (which then causes its `-yscrollcommand' to be called,
which updates the scrollbar).

   A _frame_ widget does not do anything by itself except reserve an
area of the display.  Although this does not seem to have much purpose,
it is a very important widget.  It is a container widget; that is, it
is used to group together collections of other widgets into logical
groups. For example, a row of buttons may be grouped into a frame, then
as the frame is manipulated so will the widgets displayed inside it.  A
frame widget can also be used to create large areas of color inside
another container widget (such as another frame widget or a toplevel
widget).

   An example of the use of a frame widget as a container:

     canvas .c -background red
     frame .f
     button .b1 -text button1
     button .b2 -text button2
     button .b3 -text button3
     button .b4 -text button4
     button .b5 -text button5
     pack .b1 .b2 .b3 .b4 .b5 -in .f -side left
     pack .c -side top -fill both -expand 1
     pack .f -side bottom

which specifies that there are two main widgets a canvas named `.c' and
a frame named `.f'. There are also 5 buttons, `.b1' through `.b5'.  The
buttons are displayed inside the frame. Then the canvas is displayed at
the top of the main window and the frame is displayed at the bottom. As
the frame is displayed at the bottom, then so will the buttons because
they are displayed inside the frame.

   (The `pack' command causes the widgets to be handled for display by
the packer geometry manager.  The `-fill' and `-expand 1' options to
pack for `.c' tell the display manager that if the window is resized,
the canvas is to expand to fill most of the window. You will learn
about geometry managers later in the Geometry Managers section.)

   A _toplevel_ widget is a new toplevel window.  It is a container
widget inside which other widgets are displayed.  The root toplevel
widget has path `.' -- i.e. dot on its own.  Subsequent toplevel widgets
must have a name that is lower down the path tree just like any other
widget.

   An example of creating a toplevel widget is:

     toplevel .t

   All the widgets displayed inside `.t' must also have `.t' as the
root of their path.  For example, to create a button widget for display
inside the `.t' toplevel the following would work:

     button .t.b -text "Inside 't'"

   (Attributes, such as size and title, of toplevel widgets can be
changed through the `wm' command, which we will not cover in this
tutorial. The reader is referred to the Tk manual.)

   Yet another kind of container is a _menu widget_.  It contains a
list of widgets to display inside itself, as a pulldown menu.  A simple
entry in a menu widget is a `command' widget, displayed as an option in
the menu widget, which if chosen executes a Tcl command.  Other types of
widgets allowed inside a menu widget are radiobuttons and checkboxes.  A
special kind of menu item is a `separator' that is used to group
together menu items within a menu.  (It should be noted that the widgets
inside a menu widget are special to that menu widget and don't have an
independent existence, and so don't have their own Tk name.)

   A menu widget is built by first creating an instance of a menu
widget (the container) and then invoking the `add' method to make
entries into the menu.  An example of a menu widget is as follows:

     menu .m
     .m add command -label "Open file" -command "open_file"
     .m add command -label "Open directory" -command "open_directory"
     .m add command -label "Save buffer" -command "save_buffer"
     .m add command -label "Save buffer as..." -command "save_buffer_as"
     .m add separator
     .m add command -label "Make new frame" -command "new_frame"
     .m add command -label "Open new display" -command "new_display"
     .m add command -label "Delete frame" -command "delete_frame"

which creates a menu widget called `.m', which contains eight menu
items, the first four of which are commands, then comes a separator
widget, then the final three command entries.  (Some of you will notice
that this menu is a small part of the `Files' menu from the menubar of
the Emacs text editor.)

   An example of a checkbox and some radiobutton widget entries:

     .m add checkbox -label "Inverse video" -variable inv_vid
     .m add radiobutton -label "black" -variable color
     .m add radiobutton -label "blue" -variable color
     .m add radiobutton -label "red" -variable color

which gives a checkbox displaying `Inverse video', keeping its state in
the variable `inv_vid', and three radiobuttons linked through the
variable `color'.

   Another menu item variant is the `cascade' variant, which is used to
make cascadable menus, i.e. menus that have submenus.  An example of a
cascade entry is the following:

     .m add cascade -label "I cascade" -menu .m.c

which adds a cascade entry to the menu `.m' that displays the text `I
cascade'.  If the `I cascade' option is chosen from the `.m' menu then
the menu `.m.c' will be displayed.

   The cascade option is also used to make menubars at the top of an
application window.  A menu bar is simply a menu each element of which
is a cascade entry, (for example). The menubar menu is attached to the
application window through a special configuration option for toplevel
widgets, the `-menu' option.  Then a menu is defined for each of the
cascade entry in the menubar menu.

   There are a large number of other variants to menu widgets: menu
items can display bitmaps instead of text; menus can be specified as
tear-off menus; accelerator keys can be defined for menu items; and so
on.

   A _menubutton widget_ displays like a button, but when activated a
menu pops up. The menu of the menubutton is defined through the `menu'
command and is attached to the menubutton.  An example of a menu button:

     menubutton .mb -menu .mb.m -text "mymenu"
     menu .mb.m
     .mb.m add command -label hello
     .mb.m add command -label goodbye

which crates a menubutton widget named `.mb' with attached menu `.mb.m'
and displays the text `mymenu'.  Menu `.mb.m' is defined as two command
options, one labelled `hello' and the other labelled `goodbye'.  When
the menubutton `.mb' is clicked on, the menu `.mb.m' will popup and its
options can be chosen.

   A _canvas widget_ is a container widget that is used to manage the
drawing of complex shapes; for example, squares, circles, ovals, and
polygons.  (It can also handle bitmaps, text and most of the Tk widgets
too.)  The shapes may have borders, filled in, be clicked on, moved
around, and manipulated.

   We will not cover the working of the canvas widget here.  It is
enough to know that there is a powerful widget in the Tk toolkit that
can handle all manner of graphical objects.  The interested reader is
referred to the Tk manual.

   A _text widget_ is another powerful container widget that handles
multi-line texts. The textwidget can display texts with varying font
styles, sizes, and colors in the same text, and can also handle other
Tk widgets embedded in the text.

   The text widget is a rich and complicated widget and will not be
covered here.  The interested reader is referred to the Tk manual.


File: sicstus.info,  Node: Geometry Managers,  Next: Event Handling,  Prev: Widget Creation,  Up: Tk

10.37.3.5 Geometry Managers
...........................

So far we have described each of the Tk widgets but have not mentioned
how they are arranged to be displayed.  Tk separates the creating of
widgets from the way they are arranged for display. The "geometry" of
the display is handled by a "geometry manager".  A geometry manager is
handed the set of widgets to display with instructions on their layout.
The layout instructions are particular to each geometry manager.

   Tk comes with three distinct geometry managers: `grid', `place', and
`pack'.  As might be expected the `grid' geometry manager is useful for
creating tables of widgets, for example, a table of buttons.

   The `place' geometry manager simply gives each widget an X and Y
coordinate and places them at that coordinate in their particular parent
window.

   The `pack' geometry manager places widgets according to constraints,
like "these three button widgets should be packed together from the
left in their parent widget, and should resize with the parent".

   (In practice the `grid' and `pack' geometry managers are the most
useful because they can easily handle events such as resizing of the
toplevel window, automatically adjusting the display in a sensible
manner.  `place' is not so useful for this.)

   Each container widget (the master) has a geometry manager associated
with it, which tells the container how to display its sub-widgets
(slaves) inside it. A single master has one and only one kind of
geometry manager associated with it, but each master can have a
different kind.  For example, a frame widget can use the packer to pack
other frames inside it. One of the slave frames could use the grid
manager to display buttons inside it itself, while another slave frame
could use the packer to pack labels inside it itself.

   The problem is how to display widgets. For example, there is an empty
frame widget inside which a bunch of other widgets will be displayed.
The `pack' geometry manager's solution to this problem is to
successively pack widgets into the empty space left in the container
widget.  The container widget is the master widget, and the widgets
packed into it are its slaves.  The slaves are packed in a sequence: the
packing order.

   What the packer does is to take the next slave to be packed.  It
allocates an area for the slave to be packed into from the remaining
space in the master. Which part of the space is allocated depends on
instructions to the packer. When the size of the space has been
determined, this is sliced off the free space, and allocated to the
widget that is displayed in it.  Then the remaining space is available
to subsequent slaves.

   At any one time the space left for packing is a rectangle.  If the
widget is too small to use up a whole slice from the length or breadth
of the free rectangle, still a whole slice is allocated so that the
free space is always rectangular.

   It can be tricky to get the packing instructions right to get the
desired finished effect, but a large number of arrangements of widgets
is possible using the packer.

   Let us take a simple example: three buttons packed into the root
window.  First we create the buttons; see also
`library('tcltk/examples/ex3.tcl')':

     button .b1 -text b1
     button .b2 -text b2
     button .b3 -text b3

then we can pack them thus:

     pack .b1 .b2 .b3

which produces a display of the three buttons, one on top of the other,
button `.b1' on the top, and button `.b3' on the bottom.


 [image src="images/tcltkex3.png" text="" ]                           Three Plain Buttons

If we change the size of the text in button `.b2' through the command:

     .b2 config -text "hello world"

then we see that the window grows to fit the middle button, but the
other two buttons stay their original size.


 [image src="images/tcltkex4.png" text="" ]                          Middle Button Widens

The packer defaults to packing widgets in from the top of the master.
Other directions can be specified.  For example, the command:

     pack .b1 .b2 .b3 -side left

will pack starting at the left hand side of the window.  The result of
this is that the buttons are formed in a horizontal row with the wider
button, `.b2', in the middle.


 [image src="images/tcltkex5.png" text="" ]                          Packing From The Left

It is possible to leave space between widgets through the _padding_
options to the packer: `-padx' and `-pady'.  What these do is to
allocate space to the slave that is padded with the padding distances.
An example would be:

     pack .b1 .b2 .b3 -side left -padx 10


 [image src="images/tcltkex6.png" text="" ]                            External Padding

which adds 10 pixels of space to either side of the button widgets.
This has the effect of leaving 10 pixels at the left side of button
`.b1', 20 pixels between buttons `.b1' and `.b2', 20 pixels between
buttons `.b2' and `.b3', and finally 10 pixels on the right side of
button `.b3'.

   That was external padding for spacing widgets.  There is also
internal padding for increasing the size of widgets in the X and Y
directions by a certain amount, through `-ipadx' and `-ipady' options;
i.e. internal padding.  For example:

     pack .b1 .b2 .b3 -side left -ipadx 10 -ipady 10


 [image src="images/tcltkex7.png" text="" ]                            Internal Padding

instead of spacing out the widgets, will increase their dimensions by
10 pixels in each direction.

   Remember that space is allocated to a widget from the currently
available space left in the master widget by cutting off a complete
slice from that space. It is often the case that the slice is bigger
that the widget to be displayed in it.

   There are further options for allowing a widget to fill the whole
slice allocated to it.  This is done through the `-fill' option, which
can have one of four values: `none' for no filling (default), `x' to
fill horizontally only, `y' to fill vertically only, and `both' to fill
both horizontally and vertically at the same time.

   Filling is useful, for example, for creating buttons that are the
same size even though they display texts of differing lengths.  To take
our button example again, the following code produces three buttons,
one on top of each other, but of the same size:

     button .b1 -text b1
     button .b2 -text "hello world"
     button .b3 -text b3
     pack .b1 .b2 .b3 -fill x


 [image src="images/tcltkex8.png" text="" ]                  Using `fill' For Evenly Sized Widgets

How does this work? The width of the toplevel windows is dictated by
button `.b2' because it has the widest text. Because the three buttons
are packed from top to bottom, the slices of space allocated to them
are cut progressively straight along the top of the remaining space.
i.e. each widget gets a horizontal slice of space the same width cut
from the top-level widget.  Only the wide button `.b2' would normally
fit the whole width of its slice.  But by allowing the other two
widgets to fill horizontally, they will also take up the whole width of
their slices.  The result: 3 buttons stacked on top of each other, each
with the same width, although the texts they display are not the same
length.

   A further common example is adding a scrollbar to a listbox.  The
trick is to get the scrollbar to size itself to the listbox; see also
`library('tcltk/examples/ex9a.tcl')':

     listbox .l
     scrollbar .s
     pack .l .s -side left


 [image src="images/tcltkex9a.png" text="" ]                    Scrollbar With Listbox, First Try

So far we have a listbox on the left and a tiny scrollbar on the right.
To get the scrollbar to fill up the vertical space around it add the
following command:

     pack .s -fill y

   Now the display looks like a normal listbox with a scrollbar.


 [image src="images/tcltkex9b.png" text="" ]                   Scrollbar With Listbox, Second Try

Why does this work? They are packed from the left, so first a large
vertical slice of the master is given to the listbox, then a thin
vertical slice is given to the scrollbar. The scrollbar has a small
default width and height and so it does not fill the vertical space of
its slice. But filling in the vertical direction (through the `pack .s
-fill y' command) allows it to fill its space, and so it adjusts to the
height of the listbox.

   The `fill' packing option specifies whether the widget should fill
space left over in its slice of space.  A further option to take into
account is what happens when the space allocated to the master widget is
much greater than the that used by its slaves.  This is not usually a
problem initially because the master container widget is sized to
shrink-wrap around the space used by its slaves.  If the container is
subsequently resized, however, to a much larger size there is a question
as to what should happen to the slave widgets.  A common example of
resizing a container widget is the resizing of a top-level window
widget.

   The default behavior of the packer is not to change the size or
arrangement of the slave widgets. There is an option though through the
`expand' option to cause the slices of space allocated to slaves to
expand to fill the newly available space in the master.  `expand' can
have one of two values: `0' for no expansion, and `1' for expansion.

   Take the listbox-scrollbar example; see also
`library('tcltk/examples/ex10.tcl')':

     listbox .l
     scrollbar .s
     pack .l -side left
     pack .s -side left -fill y

   Initially this looks good, but now resize the window to a much bigger
size.  You will find that the listbox stays the same size and that empty
space appears at the top and bottom of it, and that the scrollbar
resizes in the vertical. It is now not so nice.


 [image src="images/tcltkex10.png" text="" ]              Scrollbar And Listbox, Problems With Resizing

We can fix part of the problem by having the listbox expand to fill the
extra space generated by resizing the window.

     pack .l -side left -expand 1


 [image src="images/tcltkex10a.png" text="" ]                   Scrollbar And Listbox, Almost There

The problem now is that `expand' just expands the space allocated to
the listbox, it doesn't stretch the listbox itself. To achieve that we
need to apply the `fill' option to the listbox too.

     pack .l -side left -expand 1 -fill both


 [image src="images/tcltkex10b.png" text="" ]           Scrollbar And Listbox, Problem Solved Using `fill'

Now whichever way the top-level window is resized, the listbox-scrollbar
combination should look good.

   If more than one widget has the expansion bit set, the space is
allocated equally to those widgets. This can be used, for example, to
make a row of buttons of equal size that resize to fill the widget of
their container.  Try the following code; see also
`library('tcltk/examples/ex11.tcl')':

     button .b1 -text "one"
     button .b2 -text "two"
     button .b3 -text "three"
     pack .b1 .b2 .b3 -side left -fill x -expand 1


 [image src="images/tcltkex11.png" text="" ]                      Resizing Evenly Sized Widgets

Now resize the window. You will see that the buttons resize to fill the
width of the window, each taking an equal third of the width.

     *Please note*: the best way to get the hang of the packer is to
     play with it. Often the results are not what you expect,
     especially when it comes to fill and expand options. When you have
     created a display that looks pleasing, always try resizing the
     window to see if it still looks pleasing, or whether some of your
     fill and expand options need revising.

   There is an option to change how a slave is displayed if its
allocated space is larger than itself. Normally it will be displayed
centered. That can be changed by anchoring it with the `-anchor'
option. The option takes a compass direction as its argument: `n', `s',
`e', `w', `nw', `ne', `sw', `se', or `c' (for center).

   For example, the previous example with the resizing buttons displays
the buttons in the center of the window, the default anchoring point.
If we wanted the buttons to be displayed at the top of the window, we
would anchor them there thus; see also
`library('tcltk/examples/ex12.tcl')':

     button .b1 -text "one"
     button .b2 -text "two"
     button .b3 -text "three"
     pack .b1 .b2 .b3 -side left -fill x -expand 1 -anchor n


 [image src="images/tcltkex12.png" text="" ]                            Anchoring Widgets

Each button is anchored at the top of its slice and so in this case is
displayed at the top of the window.

   The packing order of widget can also be changed. For example,

     pack .b3 -before .b2

will change the positions of `.b2' and `.b3' in our examples.


 [image src="images/tcltkex13.png" text="" ]                  Changing The Packing Order Of Widgets

The _grid geometry manager_ is useful for arranging widgets in grids or
tables.  A grid has a number of rows and columns and a widget can occupy
one of more adjacent rows and columns.

   A simple example of arranging three buttons; see also
`library('tcltk/examples/ex14.tcl')':

     button .b1 -text b1
     button .b2 -text b2
     button .b3 -text b3
     grid .b1 -row 0 -column 0
     grid .b2 -row 1 -column 0
     grid .b3 -row 0 -column 1 -rowspan 2

this will display button `.b1' above button `.b2'. Button `.b3' will be
displayed in the next column and it will take up two rows.


 [image src="images/tcltkex14.png" text="" ]                    Using the `grid' Geometry Manager

However, `.b3' will be displayed in the center of the space allocated
to it. It is possible to get it to expand to fill the two rows it has
using the `-sticky' option. The `-sticky' option says to which edges of
its cells a widget "sticks" to, i.e. expands to reach.  (This is like
the fill and expand options in the pack manager.)  So to get `.b3' to
expand to fill its space we could use the following:

     grid .b3 -sticky ns

which says stick in the north and south directions (top and bottom).
This results in `.b3' taking up two rows and filling them.


 [image src="images/tcltkex15.png" text="" ]            `grid' Geometry Manager, Cells With Sticky Edges

There are plenty of other options to the grid geometry manager.  For
example, it is possible to give some rows/columns more "weight" than
others, which gives them more space in the master.  For example, if in
the above example you wanted to allocate 1/3 of the width of the master
to column 0 and 2/3 of the width to column 1, the following commands
would achieve that:

     grid columnconfigure . 0 -weight 1
     grid columnconfigure . 1 -weight 2

which says that the weight of column 0 for master `.' (the root window)
is 1 and the weight of column 1 is 2. Since column 1 has more weight
than column 0 it gets proportionately more space in the master.

   It may not be apparent that this works until you resize the window.
You can see even more easily how much space is allocated to each button
by making expanding them to fill their space through the sticky option.
The whole example looks like this; see also
`library('tcltk/examples/ex16.tcl')':

     button .b1 -text b1
     button .b2 -text b2
     button .b3 -text b3
     grid .b1 -row 0 -column 0 -sticky nsew
     grid .b2 -row 1 -column 0 -sticky nsew
     grid .b3 -row 0 -column 1 -rowspan 2 -sticky nsew
     grid columnconfigure . 0 -weight 1
     grid columnconfigure . 1 -weight 2

   Now resize the window to various sizes and we will see that button
`.b3' has twice the width of buttons `.b1' and `.b2'.


 [image src="images/tcltkex16.png" text="" ]                       Changing Row/Column Ratios

The same kind of thing can be specified for each row too via the `grid
rowconfigure' command.

   For other options and a full explanation of the grid manager see the
manual.

   `place' simply places the slave widgets in the master at the given x
and y coordinates. It displays the widgets with the given width and
height. For example (see also `library('tcltk/examples/ex17.tcl')'):

     button .b1 -text b1
     button .b2 -text b2
     button .b3 -text b3
     place .b1 -x 0 -y 0
     place .b2 -x 100 -y 100
     place .b3 -x 200 -y 200


 [image src="images/tcltkex17.png" text="" ]                   Using The `place' Geometry Manager

will place the buttons `.b1', `.b2', and `.b3' along a diagonal 100
pixels apart in both the x and y directions.  Heights and widths can be
given in absolute sizes, or relative to the size of the master in which
case they are specified as a floating point proportion of the master;
0.0 being no size and 1.0 being the size of the master.  x and y
coordinates can also be specified in a relative way, also as a floating
point number. For example, a relative y coordinate of 0.0 refers to the
top edge of the master, while 1.0 refers to the bottom edge.  If both
relative and absolute x and y values are specified, they are summed.

   Through this system the placer allows widgets to be placed on a kind
of rubber sheet. If all the coordinates are specified in relative
terms, as the master is resized then so will the slaves move to their
new relative positions.


File: sicstus.info,  Node: Event Handling,  Next: Miscellaneous,  Prev: Geometry Managers,  Up: Tk

10.37.3.6 Event Handling
........................

So far we have covered the widgets types, how instances of them are
created, how their attributes can be set and queried, and how they can
be managed for display using geometry managers.  What we have not
touched on is how to give each widget a behavior.

   This is done through event handlers.  Each widget instance can be
given a window event handler for each kind of window event.  A window
event is something like the cursor moving into or out of the widget, a
key press happening while the widget is active (in focus), or the widget
being destroyed.

   Event handlers are specified through the `bind' command:

     bind WIDGETNAME EVENTSEQUENCE COMMAND

where WIDGETNAME is the name or class of the widget to which the event
handler should be attached, EVENTSQUEUENCE is a description of the
event that this event handler will handle, and COMMAND is a script that
is invoked when the event happens (i.e. it is the event handler).

   Common event types are

`Key'
`KeyPress'
     when a key was pressed

`KeyRelease'
     when a key was released

`Button'
`ButtonPress'
     when a mouse button was pressed

`ButtonRelease'
     when a mouse button was released

`Enter'
     when the cursor moves into a widget

`Leave'
     when the cursor moved our of a widget

`Motion'
     when the cursor moves within a widget

   There are other event types. Please refer to the Tk documentation for
a complete list.

   The EVENTSEQUENCE part of a `bind' command is a list of one or more
of these events, each event surrounded by angled brackets. (Mostly, an
event sequence consists of handling a single event. Later we will show
more complicated event sequences.)

   An example is the following:

     button .b -text "click me"
     pack .b
     bind .b <Enter> { puts "entering .b" }

makes a button `.b' displaying text `click me' and displays it in the
root window using the packing geometry manager. The `bind' command
specifies that when the cursor enters (i.e. goes onto) the widget, then
the text `entering .b' is printed at the terminal.

   We can make the button change color as the cursor enters or leaves
it like this:

     button .b -text "click me" -background red
     pack .b
     bind .b <Enter> { .b config -background blue }
     bind .b <Leave> { .b config -background red }

which causes the background color of the button to change to blue when
the cursor enters it and to change back to red when the cursor leaves.

   An action can be appended to an event handler by prefixing the
action with a `+' sign. An example is:

     bind .b <Enter> {+puts "entering .b"}

which, when added to the example above, would not only change the color
of the button to red when the cursor enters it, but would also print
`entering .b' to the terminal.

   A binding can be revoked simply by binding the empty command to it:

     bind .b <Enter> {}

   A list of events that are bound can be found by querying the widget
thus:

     bind .b

which will return a list of bound events.

   To get the current command(s) bound to an event on a widget, invoke
`bind' with the widget name and the event. An example is:

     bind .b <Enter>

which will return a list of the commands bound to the event <Enter> on
widget `.b'.

   Binding can be generalized to sequences of events.  For example, we
can create an entry widget that prints `spells rob' each time the key
sequence `ESC r o b' happens:

     entry .e
     pack .e
     bind .e <Escape>rob {puts "spells rob"}

   (A letter on its own in an event sequence stands for that key being
pressed when the corresponding widget is in focus.)

   Events can also be bound for entire classes of widgets.  For
example, if we wanted to perform the same trick for ALL entry widgets
we could use the following command:

     bind entry <Escape>rob {puts "spells rob"}

   In fact, we can bind events over all widgets using `all' as the
widget class specifier.

   The event script can have substitutions specified in it.  Certain
textual substitutions are then made at the time the event is processed.
For example, `%x' in a script gets the x coordinate of the mouse
substituted for it. Similarly, `%y' becomes the y coordinate, `%W' the
dot path of the window on which the event happened, `%K' the keysym of
the button that was pressed, and so on.  For a complete list, see the
manual.

   In this way it is possible to execute the event script in the context
of the event.

   A clever example of using the `all' widget specifier and text
substitutions is given in John Ousterhout's book on Tcl/Tk (*note
Resources::):

     bind all <Enter> {puts "Entering %W at (%x, %y)"}
     bind all <Leave> {puts "Leaving %W at (%x, %y)"}
     bind all <Motion> {puts "Pointer at (%x, %y)"}

which implements a mouse tracker for all the widgets in a Tcl/Tk
application.  The widget's name and x and y coordinates are printed at
the terminal when the mouse enters or leaves any widget, and also the x
and y coordinates are printed when the mouse moves within a widget.


File: sicstus.info,  Node: Miscellaneous,  Next: What We Have Left Out (Tk),  Prev: Event Handling,  Up: Tk

10.37.3.7 Miscellaneous
.......................

There are a couple of other Tk commands that we ought to mention:
`destroy' and `update'.

   The `destroy' command is used to destroy a widget, i.e. remove it
from the Tk interpreter entirely and so from the display.  Any children
that the widget may have are also `destroy'-ed.  Anything connected to
the destroyed widget, such as bindings, are also cleaned up
automatically.

   For example, to create a window containing a button that is
destroyed when the button is pressed:

     button .b -text "Die!" -command { destroy . }
     pack .b

creates a button `.b' displaying the text `Die!', which runs the
command `destroy .' when it is pressed. Because the widget `.' is the
main toplevel widget or window, running that command will kill the
entire application associated with that button.

   The command `update' is used to process any pending Tk events.  An
event is not just such things as moving the mouse but also updating the
display for newly created and displayed widgets.  This may be necessary
in that usually Tk draws widgets only when it is idle. Using the
`update' command forces Tk to stop and handle any outstanding events
including updating the display to its actually current state, i.e.
flushing out the pending display of any widgets.  (This is analogous to
the `fflush' command in C that flushes writes on a stream to disk. In
Tk displaying of widgets is "buffered"; calling the `update' command
flushes the buffer.)


File: sicstus.info,  Node: What We Have Left Out (Tk),  Next: Queens Display,  Prev: Miscellaneous,  Up: Tk

10.37.3.8 What We Have Left Out
...............................

There are a number of Tk features that we have not described but we
list some of them here in case the reader is interested.  Refer to the
Tk manual for more explanation.

`photo'
     creating full color images through the  command

`wm'
     setting and getting window attributes

selection and focus commands

modal interaction
     (not recommended)

`send'
     sending messages between Tk applications


File: sicstus.info,  Node: Queens Display,  Prev: What We Have Left Out (Tk),  Up: Tk

10.37.3.9 Example pure Tcl/Tk program
.....................................

To show some of what can be done with Tcl/Tk, we will show an example of
part of a GUI for an 8-queens program.  Most people will be familiar
with the 8-queens problem: how to place 8 queens on a chess board such
that they don't attack each other according to the normal rules of
chess.

   Our example will not be a program to solve the 8-queens problem
(that will come later in the tutorial) but just the Tcl/Tk part for
displaying a solution.  The code can be found in
`library('tcltk/examples/ex18.tcl')'.

   The way an 8-queens solution is normally presented is as a list of
numbers. The position of a number in the list indicates the column the
queens is placed at and the number itself indicates the row. For
example, the Prolog list `[8, 7, 6, 5, 4, 3, 2, 1]' would indicate 8
queens along the diagonal starting a column 1, row 8 and finishing at
column 8 row 1.

   The problem then becomes, given this list of numbers as a solution,
how to display the solution using Tcl/Tk. This can be divided into two
parts: how to display the initial empty chess board, and how to display
a queen in one of the squares.

   Here is our code for setting up the chess board:

                                                            _% ex18.pl_
     #! /usr/bin/wish

     proc setup_board { } {
         # create container for the board
         frame .queens

         # loop of rows and columns
         for {set row 1} {$row <= 8} {incr row} {
             for {set column 1} {$column <= 8} {incr column} {

                 # create label with a queen displayed in it
                 label .queens.$column-$row -bitmap @bitmaps/q64s.bm -relief flat

                 # choose a background color depending on the position of the
                 # square; make the queen invisible by setting the foreground
                 # to the same color as the background
                 if { [expr ($column + $row) % 2] } {
                     .queens.$column-$row config -background #ffff99
                     .queens.$column-$row config -foreground #ffff99
                 } else {
                     .queens.$column-$row config -background #66ff99
                     .queens.$column-$row config -foreground #66ff99
                 }

                 # place the square in a chess board grid
                 grid .queens.$column-$row -row $row -column $column -padx 1 -pady 1
             }
         }
         pack .queens
     }

     setup_board

   The first thing that happens is that a frame widget is created to
contain the board.  Then there are two nested loops that loop over the
rows and columns of the chess board.  Inside the loop, the first thing
that happens is that a label widget is created. It is named using the
row and column variables so that it can be easily referenced later.  The
label will not be used to display text but to display an image, a bitmap
of a queen. The label creation command therefore has the special
argument `-bitmap @q64s.bm', which says that the label will display the
bitmap loaded from the file `q64s.bm'.

   The label with the queen displayed in it has now been created.  The
next thing that happens is that the background color of the label
(square) is chosen. Depending on the position of the square it becomes
either a "black" or a "white" square.  At the same time, the foreground
color is set to the background color.  This is so that the queen
(displayed in the foreground color) will be invisible, at least when
the board is first displayed.

   The final action in the loop is to place the label (square) in
relation to all the other squares for display. A chess board is a
simple grid of squares, and so this is most easily done through the
`grid' geometry manager.

   After the board has been set up square-by-square it still needs to
be displayed, which is done by `pack'-ing the outermost frame widget.

   To create and display a chess board widget, all that is needed is to
call the procedure

     setup_board

which creates the chess board widget.

   Once the chess board has been displayed, we need to be able to take a
solution, a list of rows ordered by column, and place queens in the
positions indicated.

   Taking a topdown approach, our procedure for taking a solution and
displaying is as follows:

     proc show_solution { solution } {
         clear_board
         set column 1
         foreach row $solution {
             place_queen $column $row
             incr column
         }
     }

   This takes a solution in `solution', clears the board of all queens,
and then places each queen from the solution on the board.

   Next we will handle clearing the board:

     proc clear_board { } {
         for { set column 1 } {$column <= 8} {incr column} {
             reset_column $column
         }
     }

     proc reset_column { column } {
         for {set row 1 } { $row <= 8 } {incr row} {
             set_queens $column $row off
         }
     }

     proc set_queens { column row state } {
         if { $state == "on" } {
             .queens.$column-$row config -foreground black
         } else {
             .queens.$column-$row config
             -foreground [.queens.$column-$row cget -background]
         }
     }

   The procedure `clear_board' clears the board of queens by calling
the procedure `reset_column' for each of the 8 columns on a board.
`reset_column' goes through each square of a column and sets the square
to `off' through `set_queens'.  In turn, `set_queens' sets the
foreground color of a square to black if the square is turned `on',
thus revealing the queen bitmap, or sets the foreground color of a
square to its background color, thus making the queens invisible, if it
is called with something other than `on'.

   That handles clearing the board, clearing a column or turning a
queen on or off on a particular square.

   The final part is `place_queen':

     proc place_queen { column row } {
         reset_column $column
         set_queens $column $row on
     }

   This resets a column so that all queens on it are invisible and then
sets the square with coordinates given in `row' and `column' to on.

   A typical call would be:

     show_solution "1 2 3 4 5 6 7 6 8"


 [image src="images/tcltkex18.png" text="" ]                       8-Queens Display In Tcl/Tk

which would display queens along a diagonal.  (This is of course not a
solution to the 8-queens problem. This Tcl/Tk code only displays
possible queens solutions; it doesn't check if the solution is valid.
Later we will combine this Tcl/Tk display code with Prolog code for
generating solutions to the 8-queens problem.)


File: sicstus.info,  Node: The Tcl/Tk Prolog Library,  Next: Putting It All Together,  Prev: Tk,  Up: lib-tcltk

10.37.4 The Tcl/Tk Prolog Library
---------------------------------

Now we have covered the wonders of Tcl/Tk, we come to the real meat of
the tutorial: how to couple the power of Tcl/Tk with the power of
SICStus Prolog.

   Tcl/Tk is included in SICStus Prolog by loading a special library.
The library provides a bidirectional interface between Tcl/Tk and
Prolog.

* Menu:

* How it Works - An Overview:: How it Works - An Overview
* Basic Functions:: Basic Functions
* Evaluation Functions:: Evaluation Functions
* Event Functions:: Event Functions
* Servicing Tk Events:: Servicing Tcl and Tk events
* Passing Control to Tk:: Passing Control to Tk
* Housekeeping:: Housekeeping functions
* Summary:: Summary


File: sicstus.info,  Node: How it Works - An Overview,  Next: Basic Functions,  Up: The Tcl/Tk Prolog Library

10.37.4.1 How it Works - An Overview
....................................

Before describing the details of the Tcl/Tk library we will give an
overview of how it works with the Prolog system.

   The Tcl/Tk library provides a loosely coupled integration of Prolog
and Tcl/Tk. By this we mean that the two systems, Prolog and Tcl/Tk,
although joined through the library, are mostly separate; Prolog
variables have nothing to do with Tcl variables, Prolog and Tcl program
states are separate, and so on.

   The Tcl/Tk library extends Prolog so that Prolog can create a number
of independent Tcl interpreters with which it can interact.  Basically,
there is a predicate, which when executed creates a Tcl interpreter and
returns a handle with which Prolog can interact with the interpreter.

   Prolog and a Tcl interpreter interact, and so communicate and
cooperate, through two ways:

  1. One system evaluates a code fragment in the other system and
     retrieves the result. For example, Prolog evaluates a Tcl code
     fragment in an attached Tcl interpreter and gets the result of the
     evaluation in a Prolog variable. Similarly, a Tcl interpreter can
     evaluate a Prolog goal and get the result back through a Tcl
     variable.

     This is synchronous communication in that the caller waits until
     the callee has finished their evaluation and reads the result.

  2. One system passing a "message" to the other on an "event" queue.

     This is asynchronous communication in that the receiver of the
     message can read the message whenever it likes, and the sender can
     send the message without having to wait for a reply.

   The Tk part of Tcl/Tk comes in because an attached Tcl interpreter
may be extended with the Tk widget set and so be a Tcl/Tk interpreter.
This makes it possible to add GUIs to a Prolog application: the
application loads the Tcl/Tk Prolog library, creates a Tcl/Tk
interpreter, and sends commands to the interpreter to create a Tk GUI.
The user interacts with the GUI and therefore with the underlying
Prolog system.

   There are two main ways to partition the Tcl/Tk library functions:
by function, i.e. the task they perform; or by package, i.e. whether
they are Tcl, Tk, or Prolog functions.  We will describe the library in
terms of the former because it fits in with the tutorial style better,
but at the end is a summary section that summarizes the library
functions both ways.

   Taking the functional approach, the library can be split into six
function groups:

   * basic functions
        - loading the library

        - creating and destroying Tcl and Tcl/Tk interpreters

   * evaluation functions
        - evaluating Tcl expressions from Prolog

        - evaluating Prolog expressions from Tcl

   * Prolog event functions
        - handling the Prolog/Tcl event queue

   * Tk event handling

   * passing control to Tk

   * housekeeping functions

   We go through each group in turn.


File: sicstus.info,  Node: Basic Functions,  Next: Evaluation Functions,  Prev: How it Works - An Overview,  Up: The Tcl/Tk Prolog Library

10.37.4.2 Basic Functions
.........................

The heart of the system is the ability to create an embedded Tcl
interpreter with which the Prolog system can interact.  A Tcl
interpreter is created within Prolog through a call to `tcl_new/1':

     tcl_new(-TCLINTERPRETER)

which creates a new interpreter, initializes it, and returns a reference
to it in the variable TCLINTERPRETER. The reference can then be used in
subsequent calls to manipulate the interpreter. More than one Tcl
interpreter object can be active in the Prolog system at any one time.

   To start a Tcl interpreter extended with Tk, the `tk_new/2'
predicate is called from Prolog. It has the following form:

     tk_new(+OPTIONS, -TCLINTERPRETER)

which returns through the variable TCLINTERPRETER a handle to the
underlying Tcl interpreter. The usual Tcl/Tk window pops up after this
call is made and it is with reference to that window that subsequent
widgets are created.  As with the `tcl_new/1' predicate, many Tcl/Tk
interpreters may be created from Prolog at the same time through calls
to `tk_new/2'.

   The OPTIONS part of the call is a list of some (or none) of the
following elements:

`top_level_events'
     This allows Tk events to be handled while Prolog is waiting for
     terminal input; for example, while the Prolog system is waiting
     for input at the top-level prompt. Without this option, Tk events
     are not serviced while the Prolog system is waiting for terminal
     input. (For information on Tk events; *note Event Handling::).

`name(+APPLICATIONNAME)'
     This gives the main window a title APPLICATIONNAME.  This name is
     also used for communicating between Tcl/Tk applications via the
     Tcl  `send' command.  (`send' is not covered in this document.
     Please refer to the Tcl/Tk documentation.)

`display(+DISPLAY)'
     (This is X windows specific.) Gives the name of the screen on which
     to create the main window. If this is not given, the default
     display is determined by the `DISPLAY' environment variable.

   An example of using `tk_new/2':

     | ?- tk_new([top_level_events, name('My SICStus/Tk App')], Tcl).

which creates a Tcl/Tk interpreter, returns a handle to it in the
variable `Tcl' and Tk events are serviced while Prolog is waiting at
the top-level prompt.  The window that pops up will have the title `My
SICStus/Tk App'.

   The reference to a Tcl interpreter returned by a call to `tk_new/2'
is used in the same way and in the same places as a reference returned
by a call to `tcl_new/1'. They are both references to Tcl interpreters.

   To remove a Tcl interpreter from the system, use the `tcl_delete/1'
predicate:

     tcl_delete(+TCLINTERPRETER)

which given a reference to a Tcl interpreter, closes down the
interpreter and removes it. The reference can be for a plain Tcl
interpreter or for a Tk enhanced one; `tcl_delete/1' removes both kinds.


File: sicstus.info,  Node: Evaluation Functions,  Next: Event Functions,  Prev: Basic Functions,  Up: The Tcl/Tk Prolog Library

10.37.4.3 Evaluation Functions
..............................

There are two functions in this category: Prolog extended to be able to
evaluate Tcl expressions in a Tcl interpreter; Tcl extended to be able
to evaluate a Prolog expression in the Prolog system.

   There is a mechanism for describing Tcl commands in Prolog as Prolog
terms.  This is used in two ways: firstly, to be able to represent Tcl
commands in Prolog so that they can be subsequently passed to Tcl for
evaluation; and secondly for passing terms back from Tcl to Prolog by
doing the reverse transformation.

   Why not represent a Tcl command as a simple atom or string?  This
can indeed be done, but commands are often not static and each time they
are called require slightly different parameters.  This means
constructing different atoms or strings for each command in Prolog,
which are expensive operations.  A better solution is to represent a
Tcl command as a Prolog term, something that can be quickly and
efficiently constructed and stored by a Prolog system. Variable parts
to a Tcl command (for example command arguments) can be passed in
through Prolog variables.

   In the special command format, a Tcl command is specified as follows.

COMMAND        ::= NAME                      
               | `codes("code-list")'        
               | `write("term")'             
               | `writeq("term")'            
               | `write_canonical("term")'   
               | `format(FMT,ARGS)'          
               | `dq(COMMAND)'               
               | `br(COMMAND)'               
               | `sqb(COMMAND)'              
               | `min(COMMAND)'              
               | `dot(LISTOFNAMES)'          
               | `list(LISTOFCOMMANDS)'      
               | LISTOFCOMMANDS              

FMT            ::= "atom"                    

NAME           ::= "atom"                    { other than `[]' }
               | "number"                    

LISTOFCOMMANDS ::= `[]'                      
               | `[ COMMAND |                
               LISTOFCOMMANDS ]'             

LISTOFNAMES    ::= `[]'                      
               | `[ NAME | LISTOFNAMES ]'    

ARGS           ::= `[]'                      
               | `[ "term" | ARGS ]'         

where

ATOM
NUMBER
     denote their printed representations

`codes(PROLOGSTRING)'
     denotes the string represented by PROLOGSTRING (a code-list)

`write(TERM)'
`writeq(TERM)'
`write_canonical(TERM)'
     denotes the string that is printed by the corresponding built-in
     predicate.

          *Please note*: In general it is not possible to reconstruct
          TERM from the string printed by `write/1'. If TERM will be
          passed back into Prolog it therefore safest to use
          `write_canonical(TERM)'.

`format(FMT, ARGS)'
     denotes the string that is printed by the corresponding built-in
     predicate

`dq(COMMAND)'
     denotes the string specified by COMMAND, enclosed in double quotes

`br(COMMAND)'
     denotes the string specified by COMMAND, enclosed in curly brackets

`sqb(COMMAND)'
     denotes the string specified by COMMAND, enclosed in square
     brackets

`min(COMMAND)'
     denotes the string specified by COMMAND, immediately preceded by a
     hyphen

`dot(LISTOFNAME)'
     denotes the widget path specified by LISTOFNAME, preceded by and
     separated by dots

`list(LISTOFCOMMANDS)'
     denotes the TCL list with one element for each element in
     LISTOFCOMMANDS. This differs from just using LISTOFCOMMANDS or
     `br(LISTOFCOMMANDS)' when any of the elements contains spaces,
     braces or other characters treated specially by TCL.

LISTOFCOMMANDS
     denotes the string denoted by each element, separated by spaces.
     In many cases `list(LISTOFCOMMANDS)' is a better choice.

   Examples of command specifications and the resulting Tcl code:

     [set, x, 32]
         => set x 32

     [set, x, br([a, b, c])]
         => set x {a b c}

     [dot([panel,value_info,name]), configure, min(text), br(write('$display'/1))]
          => .panel.value_info.name configure -text {$display/1

     ['foo bar',baz]
          =>foo bar baz

     list(['foo bar',bar])
          => {foo bar} baz

     list(['foo { bar'',bar])
          => foo\ \{ \bar baz

   Prolog calls Tcl through the predicate `tcl_eval/3', which has the
following form:

     tcl_eval(+TCLINTERPRETER, +COMMAND, -RESULT)

which causes the interpreter TCLINTERPRETER to evaluate the Tcl command
COMMAND and return the result RESULT. The result is a string (a
code-list) that is the usual return string from evaluating a Tcl
command.  COMMAND is not just a simple Tcl command string (although
that is a possibility) but a Tcl command represented as a Prolog term
in the special Command Format (*note Evaluation Functions::).

   Through `tcl_eval/3', Prolog has a method of synchronous
communication with an embedded Tcl interpreter and a way of manipulating
the state of the interpreter.

   An example:

     | ?- tcl_new(Interp),
          tcl_eval(Interp, 'set x 1', _),
          tcl_eval(Interp, 'incr x', R).

which creates a Tcl interpreter the handle of which is stored in the
variable `Interp'. Then variable `x' is set to the representation `"1"' and then
variable `x' is incremented and the result returned in `R' as a string.
The result will be "2".  By evaluating the Tcl commands in separate
`tcl_eval/3' calls, we show that we are manipulating the state of the
Tcl interpreter and that it remembers its state between manipulations.

   It is worth mentioning here also that because of the possibility of
the Tcl command causing an error to occur in the Tcl interpreter, two
new exceptions are added by the `tcltk' library:

     tcl_error(GOAL, MESSAGE)
     tk_error(GOAL, MESSAGE)

where MESSAGE is a code-list detailing the reason for the exception.
Also two new `user:portray_message/2' rules are provided so that any
such uncaught exceptions are displayed at the Prolog top-level as

     [TCL ERROR: GOAL - MESSAGE]
     [TK ERROR: GOAL - MESSAGE]

respectively.

   These exception conditions can be raised/caught/displayed in the
usual way through the built-in predicates `raise_exception/3',
`on_exception/1', and `portray_message/2'.

   As an example, the following Prolog code will raise such an
exception:

     | ?- tcl_new(X), tcl_eval(X, 'wilbert', R).

which causes a `tcl_error/2' exception and prints the following:

     {TCL ERROR: tcl_eval/3 - invalid command name "wilbert"}

assuming that there is no command or procedure defined in Tcl called
`wilbert'.

   The Tcl interpreters created through the SICStus Prolog Tcl/Tk
library have been extended to allow calls to the underlying Prolog
system.

   To evaluate a Prolog expression in the Prolog system from a Tcl
interpreter, the new `prolog' Tcl command is invoked. It has the
following form:

     prolog PROLOGGOAL

where PROLOGGOAL is the printed form of a Prolog goal.  This causes the
goal to be executed in Prolog.  It will be executed in the `user'
module unless it is prefixed by a module name.  Execution is always
determinate.

   The return representation of the command either of the following:

`"1"'
     if execution succeeded,

`"0"'
     if execution failed.

   If succeeded (and "1" was returned), any variable in PROLOGGOAL that
has become bound to a Prolog term will be returned to Tcl in the Tcl
array named `prolog_variables' with the variable name as index. The
term is converted to Tcl using the same conversion as used for Tcl
commands (*note Evaluation Functions::). As a special case the values
of unbound variables and variables with names starting with `_', are
not recorded and need not conform to the special command format, this
is similar to the threatment of such variables by the Prolog top-level.

   An example:

     test_callback(Result) :-
         tcl_new(Interp),
         tcl_eval(Interp,
             'if {[prolog "foo(X,Y,Z)"] == 1} \\
                 {list $prolog_variables(X) \\
                       $prolog_variables(Y) \\
                       $prolog_variables(Z)}',
                 Result),
         tcl_delete(Interp).

     foo(1, bar, [a, b, c]).

   When called with the query:

     | ?- test_callback(Result).

will succeed, binding the variable `Result' to:

     "1 bar {a b c}"

   This is because execution of the `tcl_eval/3' predicate causes the
execution of the `prolog' command in Tcl, which executes `foo(X, Y, Z)'
in Prolog making the following bindings: `X = 1', `Y = bar', `Z = [a,
b, c]'.  The bindings are returned to Tcl in the associative array
`prolog_variables' where `prolog_variables(X)' is "1",
`prolog_variables(Y)' is "bar", and `prolog_variables(Z)' is "a b c".
Then Tcl goes on to execute the `list' command as

     list "1" "bar" "a b c"

which returns the result

     "1 bar {a b c}"

(remember: nested lists magically get represented with curly brackets)
which is the string returned in the RESULT part of the Tcl call, and is
ultimately returned in the `Result' variable of the top-level call to
`test_callback(Result)'.

   If an error occurs during execution of the `prolog' Tcl command, a
`tcl_error/2' exception will be raised.  The message part of the
exception will be formed from the string `Exception during Prolog
execution: ' appended to the Prolog exception message.  An example is
the following:

     | ?- tcl_new(T), tcl_eval(T, 'prolog wilbert', R).

which will print

     {TCL ERROR: tcl_eval/3 - Exception during Prolog execution:
       wilbert  existence_error(wilbert,0,procedure,user:wilbert/0,0)}

at the Prolog top-level, assuming that the predicate `wilbert/0' is not
defined on the Prolog side of the system. (This is a `tcl_error'
exception containing information about the underlying exception, an
`existence_error' exception, which was caused by trying to execute the
non-existent predicate `wilbert'.)


File: sicstus.info,  Node: Event Functions,  Next: Servicing Tk Events,  Prev: Evaluation Functions,  Up: The Tcl/Tk Prolog Library

10.37.4.4 Event Functions
.........................

Another way for Prolog to communicate with Tcl is through the predicate
`tcl_event/3':

     tcl_event(+TCLINTERPRETER, +COMMAND, -EVENTS)

   This is similar to `tcl_eval/3' in that the command COMMAND is
evaluated in the Tcl interpreter TCLINTERPRETER, but the call returns a
list of events in EVENTS rather than the result of the Tcl evaluation.
COMMAND is again a Tcl command represented as a Prolog term in the
special Command Format described previously (*note Evaluation
Functions::).

   This begs the questions what are these events and where does the
event list come from? The Tcl interpreters in the SICStus Prolog Tcl/Tk
library have been extended with the notion of a Prolog event queue.
(This is not available in plain standalone Tcl interpreters.) The Tcl
interpreter can put events on the event queue by executing a
`prolog_event' command. Each event is a Prolog term.  So a Tcl
interpreter has a method of putting Prolog terms onto a queue, which
can later be picked up by Prolog as a list as the result of a call to
`tcl_event/3'.  (It may be helpful to think of this as a way of passing
messages as Prolog terms from Tcl to Prolog.)

   A call to `tcl_event/3' blocks until there is something on the event
queue.

   A second way of getting Prolog events from a Prolog event queue is
through the `tk_next_event/[2,3]' predicates.  These have the form:

     tk_next_event(+TCLINTERPRETER, -EVENT)
     tk_next_event(+OPTIONS, +TCLINTERPRETER, -EVENT)

where TCLINTERPRETER reference to a Tcl interpreter and EVENT is the
Prolog term at the head of the associated Prolog event queue.  (The
OPTIONS feature will be described below in the Housekeeping section
when we talk about Tcl and Tk events; *note Housekeeping::.).

   (We will meet `tk_next_event/[2,3]' again later when we discuss how
it can be used to service Tk events; *note Servicing Tk Events::).

   If the interpreter has been deleted, the empty list `[]' is returned.

   The Tcl interpreters under the SICStus Prolog library are extended
with a command, `prolog_event', for adding events to a Prolog event
queue.

   The `prolog_event' command has the following form:

        prolog_event TERMS ...

where TERMS are strings that contain the printed representation of
Prolog terms. These are stored in a queue and retrieved as Prolog terms
by `tcl_event/3' or `tk_next_event/[2,3]' (described above).

   An example of using the `prolog_event' command:

     test_event(Event) :-
         tcl_new(Interp),
         tcl_event(Interp, [prolog_event, dq(write(zap(42)))], Event),
         tcl_delete(Interp).

with the query:

     | ?- test_event(Event).

will succeed, binding `Event' to the list `[zap(42)]'.

   This is because `tcl_event' converts its argument using the special
Command Format conversion (*note Evaluation Functions::), which yields
the Tcl command `prolog_event "zap(42)"'.  This command is evaluated in
the Tcl interpreter referenced by the variable `Interp'.  The effect of
the command is to take the string given as argument to `prolog_event'
(in this case `"zap(42)"') and to place it on the Tcl to Prolog event
queue.  The final action of a `tcl_event/3' call is to pick up any
strings on the Prolog queue from Tcl, add a trailing full stop and
space to each string, and parse them as Prolog terms, binding `Event'
to the list of values, which in this case is the singleton list
`[zap(42)]'. (The queue is a list the elements of which are terms put
there through calls to `prolog_event').

   If any of the TERM-s in the list of arguments to `prolog_event' is
not a valid representation of a Prolog term, an exception is raised in
Prolog when it is converted from the Tcl string to the Prolog term
using `read'. To ensure that Prolog will be able to read the term
correctly it is better to always use `write_canonical' and to ensure
that Tcl is not confused by special characters in the printed
representation of the Prolog term it is best to wrap the list with
`list'.

   A safer variant that safely passes any term from Prolog via Tcl and
back to Prolog is thus:

     test_event(Term, Event) :-
         tcl_new(Interp),
         tcl_event(Interp, list([prolog_event, write_canonical(Term)]), Event),
         tcl_delete(Interp).

   As an example of using the Prolog event system supplied by the
`tcltk' library, we will return to our 8-queens example but now
approaching from the Prolog side rather than the Tcl/Tk side:

     :- use_module(library(tcltk)).

     setup :-
         tk_new([name('SICStus+Tcl/Tk - Queens')], Tcl),
         tcl_eval(Tcl, 'source queens.tcl', _),
         tk_next_event(Tcl, Event),
         (   Event = next -> go(Tcl),
         ;   closedown(Tcl)
         ).

     closedown(Tcl) :-
         tcl_delete(Tcl).

     go(Tcl) :-
         tcl_eval(Tcl, 'clear_board', _),
         queens(8, Qs),
         show_solution(Qs, Tcl),
         tk_next_event(Tcl, Event),
         (   Event = next -> fail
         ;   closedown(Tcl)
         ).
     go(Tcl) :-
         tcl_eval(Tcl, 'disable_next', _),
         tcl_eval(Tcl, 'clear_board', _),
         tk_next_event(Tcl, _Event),
         closedown(Tcl).

   This is the top-level fragment of the Prolog side of the 8-queens
example. It has three predicates: `setup/0', `closedown/1', and `go/1'.
`setup/0' simply creates the Tcl interpreter, loads the Tcl code into
the interpreter using a call to `tcl_eval/3' (which also initializes
the display) but then calls `tk_next_event/2' to wait for a message
from the Tk side.

   The Tk part that sends `prolog_event'-s to Prolog looks like this:

     button .next -text next -command {prolog_event  next}
     pack .next

     button .stop -text stop -command {prolog_event stop}
     pack .stop

that is two buttons, one that sends the atom `next', the other that
sends the atom `stop'. They are used to get the next solution and to
stop the program respectively.

   So if the user presses the `next' button in the Tk window, the
Prolog program will receive a `next' atom via a
`prolog_event'/`tk_next_event' pair, and the program can proceed to
execute `go/1'.

   `go/1' is a failure driven loop that generates 8-queens solutions
and displays them. First it generates a solution in Prolog and displays
it through a `tcl_eval/3' call. Then it waits again for a Prolog events
via `tk_next_event/2'. If the term received on the Prolog event queue
is `next', corresponding to the user pressing the "next solution"
button, then fail is executed and the next solution found, thus driving
the loop.

   If the `stop' button is pressed, the program does some tidying up
(clearing the display and so on) and then executes `closedown/1', which
deletes the Tcl interpreter and the corresponding Tk windows
altoegther, and the program terminates.

   This example fragment show how it is possible for a Prolog program
and a Tcl/Tk program to communicate via the Prolog event queue.


File: sicstus.info,  Node: Servicing Tk Events,  Next: Passing Control to Tk,  Prev: Event Functions,  Up: The Tcl/Tk Prolog Library

10.37.4.5 Servicing Tcl and Tk events
.....................................

The notion of an event in the Prolog+Tcl/Tk system is overloaded.  We
have already come across the following kinds of events:

   * Tk widget events captured in Tcl/Tk through the `bind' command

   * Prolog queue events controlled through the `tcl_event/3',
     `tk_next_event(2,3)', and `prolog_event' functions

   It is further about to be overloaded with the notion of Tcl/Tk
events.  It is possible to create event handlers in Tcl/Tk for reacting
to other kinds of events. We will not cover them here but describe them
so that the library functions are understandable and in case the user
needs these features in an advanced application.

   There are the following kinds of Tcl/Tk events:

idle events
     happen when the Tcl/Tk system is idle

file events
     happen when input arrives on a file handle that has a file event
     handler attached to it

timer events
     happen when a Tcl/Tk timer times out

window events
     when something happens to a Tk window, such as being resized or
     destroyed

   The problem is that in advanced Tcl/Tk applications it is possible
to create event handlers for each of these kinds of event, but they are
not normally serviced while in Prolog code.  This can result in
unresponsive behavior in the application; for example, if window events
are not serviced regularly, then if the user tries to resize a Tk
window, it will not resize in a timely fashion.

   The solution to this is to introduce a Prolog predicate that passes
control to Tk for a while so that it can process its events,
`tk_do_one_event/[0,1]'. If an application is unresponsive because it
is spending a lot of time in Prolog and is not servicing Tk events
often enough, critical sections of the Prolog code can be sprinkled
with calls to `tk_do_one_event/[0,1]' to alleviate the problem.

   `tk_do_one_event/[0,1]' has the following forms:

     tk_do_one_event
     tk_do_one_event(+OPTIONS)

which passes control to Tk to handle a single event before passing
control back to Prolog. The type of events handled is passed through the
OPTIONS variable, a list of atoms that are event types.

   The OPTIONS list can contain the following atoms:

`tk_dont_wait'
     don't wait for new events, process only those that are ready

`tk_window_events'
     process window events

`tk_file_events'
     process file events

`tk_timer_events'
     process timer events

`tk_idle_events'
     process `Tcl_DoWhenIdle' events

`tk_all_events'
     process any event

   Calling `tk_do_one_event/0' is equivalent to a call to
`tk_do_one_event/1' with the `tk_all_events' and `tk_dont_wait' flags.

   A call to either of these predicates succeeds only if an event of
the appropriate type happens in the Tcl/Tk interpreter.  If there are no
such events, `tk_do_one_event/1' will fail if the `tk_dont_wait' wait
flag is present, as will `tk_do_one_event/0', which has that flag set
implicitly.

   If the `tk_dont_wait' flag is not set, a call to `tk_do_one_event/1'
will block until an appropriate Tk event happens (in which case it will
succeed).

   It is straight forward to define a predicate that handles all Tk
events and then returns:

     tk_do_all_events :-
         tk_do_one_event, !,
         tk_do_all_events.
     tk_do_all_events.

   The predicate `tk_next_event/[2,3]' is similar to
`tk_do_one_event/[0,1]' except that it processes Tk events until at
least one Prolog event happens. (We came across this predicate before
when discussing Prolog event queue predicates. This shows the
overloading of the notion event where we have a predicate that handles
both Tcl/Tk events and Prolog queue events.)

   It has the following forms:

     tk_next_event(+TCLINTERPRETER, -EVENT)
     tk_next_event(+OPTIONS, +TCLINTERPRETER, -EVENT)

   The Prolog event is returned in the variable EVENT and is the first
term on the Prolog event queue associated with the interpreter
TCLINTERPRETER. (Prolog events are initiated on the Tcl side through
the new Tcl command `prolog_event', covered earlier; *note Event
Functions::).


File: sicstus.info,  Node: Passing Control to Tk,  Next: Housekeeping,  Prev: Servicing Tk Events,  Up: The Tcl/Tk Prolog Library

10.37.4.6 Passing Control to Tk
...............................

There is a predicate for passing control completely over to Tk, the
`tk_main_loop/0' command. This passes control to Tk until all windows
in all the Tcl/Tk interpreters in the Prolog have have been destroyed:

     tk_main_loop


File: sicstus.info,  Node: Housekeeping,  Next: Summary,  Prev: Passing Control to Tk,  Up: The Tcl/Tk Prolog Library

10.37.4.7 Housekeeping functions
................................

Here we will described the functions that don't fit into any of the
above categories and are essentially housekeeping functions.

   There is a predicate that returns a reference to the main window of
a Tcl/Tk interpreter:

     tk_main_window(+TCLINTERPRETER, -TKWINDOW)

which given a reference to a Tcl interpreter TCLNTERPRETER, returns a
reference to its main window in TKWINDOW.

   The window reference can then be used in `tk_destroy_window/1':

     tk_destroy_window(+TKWINDOW)

which destroys the window or widget referenced by TKWINDOW and all of
its sub-widgets.

   The predicate `tk_make_window_exist/1' also takes a window reference:

     tk_make_window_exist(+TKWINDOW)

which causes the window referenced by TKWINDOW in the Tcl interpreter
TCLINTERPRETER to be immediately mapped to the display.  This is useful
because normally Tk delays displaying new information for a long as
possible (waiting until the machine is idle, for example), but using
this call causes Tk to display the window immediately.

   There is a predicate for determining how many main windows, and
hence Tcl/Tk interpreters (excluding simple Tcl interpreters), are
currently in use:

     tk_num_main_windows(-NUMBEROFWINDOWS)

which returns an integer in the variable NUMBEROFWINDOWS.


File: sicstus.info,  Node: Summary,  Prev: Housekeeping,  Up: The Tcl/Tk Prolog Library

10.37.4.8 Summary
.................

The functions provided by the SICStus Prolog Tcl/Tk library can be
grouped in two ways: by function, and by package.

   By function, we can group them like this:

   * basic functions
    `tcl_new/1'
          create a Tcl interpreter

    `tcl_delete/1'
          remove a Tcl interpreter

    `tk_new/2'
          create a Tcl interpreter with Tk extensions

   * evaluation functions
    `tcl_eval/3'
          evaluate a Tcl expression from Prolog

    `prolog'
          evaluate a Prolog expression from Tcl

   * Prolog event queue functions
    `tcl_event/3'
          evaluate a Tcl expression and return a Prolog queue event list

    `tk_next_event/[2,3]'
          pass control to Tk until a Prolog queue event happens and
          return the head of the queue

    `prolog_event'
          place a Prolog term on the Prolog event queue from Tcl

   * servicing Tcl and Tk events
    `tk_do_one_event/[0,1]'
          pass control to Tk until one Tk event is serviced

    `tk_next_event/[2,3]'
          also services Tk events but returns when a Prolog queue event
          happens and returns the head of the queue

   * passing control completely to Tk
    `tk_main_loop/0'
          control passed to Tk until all windows in all Tcl/Tk
          interpreters are gone

   * housekeeping
    `tk_main_window/2'
          return reference to main in of a Tcl/Tk interpreter

    `tk_destroy_window/1'
          destroy a window or widget

    `tk_make_window_exist/1'
          force display of a window or widget

    `tk_num_main_windows/1'
          return a count of the total number of Tk main windows
          existing in the system

   By package, we can group them like this:

   * predicates for Prolog to interact with Tcl interpreters
    `tcl_new/1'
          create a Tcl interpreter

    `tcl_delete/1'
          remove a Tcl interpreter

    `tcl_eval/3'
          evaluate a Tcl expression from Prolog

    `tcl_event/3'
          evaluate a Tcl expression and return a Prolog event list

   * predicates for Prolog to interact with Tcl interpreters with Tk
     extensions
    `tk_new/2'
          create a Tcl interpreter with Tk extensions

    `tk_do_one_event/[0,1]'
          pass control to Tk until one Tk event is serviced

    `tk_next_event/[2,3]'
          also services Tk events but returns when a Prolog queue event
          happens and returns the head of the queue

    `tk_main_loop/0'
          control passed to Tk until all windows in all Tcl/Tk
          interpreters are gone

    `tk_main_window/2'
          return reference to main in of a Tcl/Tk interpreter

    `tk_destroy_window/1'
          destroy a window or widget

    `tk_make_window_exist/1'
          force display of a window or widget

    `tk_num_main_windows/1'
          return a count of the total number of Tk main windows
          existing in the system

   * commands for the Tcl interpreters to interact with the Prolog
     system
    `prolog'
          evaluate a Prolog expression from Tcl

    `prolog_event'
          place a Prolog term on the Prolog event queue from Tcl

   In the next section we will discuss how to use the `tcltk' library
to build graphical user interfaces to Prolog applications.  More
specifically we will discuss the ways in which cooperation between
Prolog and Tcl/Tk can be arranged: how to achieve them, and their
benefits.


File: sicstus.info,  Node: Putting It All Together,  Next: Quick Reference,  Prev: The Tcl/Tk Prolog Library,  Up: lib-tcltk

10.37.5 Putting It All Together
-------------------------------

At this point we now know Tcl, the Tk extensions, and how they can be
integrated into SICStus Prolog through the `tcltk' library module.  The
next problem is how to get all this to work together to produce a
coherent application. Because Tcl can make Prolog calls and Prolog can
make Tcl calls it is easy to create programming spaghetti.  In this
section we will discuss some general principles of organizing the
Prolog and Tcl code to make writing applications easier.

   The first thing to do is to review the tools that we have.  We have
two programming systems: Prolog and Tcl/Tk.  They can interact in the
following ways:

   * Prolog evaluates a Tcl expression in a Tcl interpreter, using
     `tcl_eval'

   * Tcl evaluates a Prolog expression in the Prolog interpreter, using
     `prolog'

   * Prolog evaluates a Tcl expression in a Tcl interpreter and waits
     for a Prolog event, using `tcl_event'

   * Prolog waits for a Prolog event from a Tcl interpreter, using
     `tk_next_event'

   * Tcl sends a Prolog predicate to Prolog on a Prolog event queue
     using `prolog_event'

   With these interaction primitives there are three basic ways in
which Prolog and Tcl/Tk can be organized:

  1. Tcl the master, Prolog the slave: program control is with Tcl,
     which makes occasional calls to Prolog, through the `prolog'
     function.

  2. Prolog the master, Tcl the slave: program control is with Prolog,
     which makes occasional call to Tcl through the `tcl_eval' function

  3. Prolog and Tcl share control: program control is shared with Tcl
     and Prolog interacting via the Prolog event queue, through
     `tcl_event', `tk_next_event', and `prolog_event'.

   These are three ways of organizing cooperation between Tcl/Tk and
Prolog to produce an application. In practice an application my use
only one of these methods throughout, or may use a combination of them
where appropriate. We describe them here so that the developer can see
the different patterns of organization and can pick those relevant to
their application.

* Menu:

* Tcl The Master:: Tcl The Master, Prolog The Slave
* Prolog The Master:: Prolog The Master, Tk The Slave
* Prolog And Tcl Interact through Prolog Event Queue:: Prolog And Tcl Interact through Prolog Event Queue
* The Whole 8-Queens Example:: The Whole 8-Queens Example

