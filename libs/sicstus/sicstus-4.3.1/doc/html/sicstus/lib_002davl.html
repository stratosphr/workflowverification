<html lang="en">
<head>
<title>lib-avl - SICStus Prolog</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="SICStus Prolog">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="The-Prolog-Library.html#The-Prolog-Library" title="The Prolog Library">
<link rel="prev" href="lib_002datts.html#lib_002datts" title="lib-atts">
<link rel="next" href="lib_002dbags.html#lib_002dbags" title="lib-bags">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
<link href="texinfo.css" rel="stylesheet" type="text/css">
</head>
<body>
<div class="node">
<a name="lib-avl"></a>
<a name="lib_002davl"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="lib_002dbags.html#lib_002dbags">lib-bags</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="lib_002datts.html#lib_002datts">lib-atts</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="The-Prolog-Library.html#The-Prolog-Library">The Prolog Library</a>
<hr>
</div>

<h3 class="section">10.4 AVL Trees&mdash;<code>library(avl)</code></h3>

<p><a name="index-association-list-2530"></a><a name="index-list_002c-association-2531"></a><a name="index-binary-tree-2532"></a><a name="index-tree_002c-binary-2533"></a>This library module provides an AVL tree implementation of "association
lists". The binary tree <em>is</em> kept balanced, as opposed to
<code>library(assoc)</code>, which provides similar functionality based on
binary trees that are not kept balanced.

   <p>Exported predicates:

     <dl>
<dt><code>empty_avl(</code><var>?AVL</var><code>)</code><dd><a name="index-empty_005favl_002f1-_0028avl_0029-2534"></a><a name="index-empty_005favl_002f1-_0028avl_0029-2535"></a>
is true when <var>AVL</var> is an empty AVL tree. 
<br><dt><code>avl_to_list(</code><var>+AVL</var><code>, </code><var>-List</var><code>)</code><dd><a name="index-avl_005fto_005flist_002f2-_0028avl_0029-2536"></a><a name="index-avl_005fto_005flist_002f2-_0028avl_0029-2537"></a>
assumes that <var>AVL</var> is a proper AVL tree, and is true when
<var>List</var> is a list of <var>Key-Value</var> pairs in ascending order with no
duplicate keys specifying the same finite function as <var>AVL</var>. 
Use this to convert an <var>AVL</var> to an ordered list. 
<br><dt><code>is_avl(</code><var>+AVL</var><code>)</code><dd><a name="index-is_005favl_002f1-_0028avl_0029-2538"></a><a name="index-is_005favl_002f1-_0028avl_0029-2539"></a>
is true when <var>AVL</var> is a (proper) AVL tree.  It checks both the order
condition (that the keys are in ascending order as you go from left
to right) and the height balance condition.  This code relies on
variables (to be precise, the first anonymous variable in is_avl/1)
being <code>@&lt;</code> than any non-variable.  in strict point of fact you <em>can</em>
construct an AVL tree with variables as keys, but <code>is_avl/1</code> doesn't
believe it, and it is not good taste to do so. 
<br><dt><code>avl_domain(</code><var>+AVL</var><code>, </code><var>-Domain</var><code>)</code><dd><a name="index-avl_005fdomain_002f2-_0028avl_0029-2540"></a><a name="index-avl_005fdomain_002f2-_0028avl_0029-2541"></a>
unifies <var>Domain</var> with the ordered set representation of the domain
of the AVL tree (the keys of it).  As the keys are in ascending
order with no duplicates, we just read them off like <code>avl_to_list/2</code>. 
<br><dt><code>avl_range(</code><var>+AVL</var><code>, </code><var>-Range</var><code>)</code><dd><a name="index-avl_005frange_002f2-_0028avl_0029-2542"></a><a name="index-avl_005frange_002f2-_0028avl_0029-2543"></a>
unifies <var>Range</var> with the ordered set representation of the range of the
AVL (the values associated with its keys, not the keys themselves). 
Note that the cardinality (length) of the domain and the range are
seldom equal, except of course for trees representing intertible maps. 
<br><dt><code>avl_min(</code><var>+AVL</var><code>, </code><var>-Key</var><code>)</code><dd><a name="index-avl_005fmin_002f2-_0028avl_0029-2544"></a><a name="index-avl_005fmin_002f2-_0028avl_0029-2545"></a>
is true when <var>Key</var> is the smallest key in <var>AVL</var>. 
<br><dt><code>avl_min(</code><var>+AVL</var><code>, </code><var>-Key</var><code>, </code><var>-Val</var><code>)</code><dd><a name="index-avl_005fmin_002f3-_0028avl_0029-2546"></a><a name="index-avl_005fmin_002f3-_0028avl_0029-2547"></a>
is true when <var>Key</var> is the smallest key in <var>AVL</var> and <var>Val</var> is its representation.
<br><dt><code>avl_max(</code><var>+AVL</var><code>, </code><var>-Key</var><code>)</code><dd><a name="index-avl_005fmax_002f2-_0028avl_0029-2548"></a><a name="index-avl_005fmax_002f2-_0028avl_0029-2549"></a>
is true when <var>Key</var> is the greatest key in <var>AVL</var>. 
<br><dt><code>avl_max(</code><var>+AVL</var><code>, </code><var>-Key</var><code>, </code><var>-Val</var><code>)</code><dd><a name="index-avl_005fmax_002f3-_0028avl_0029-2550"></a><a name="index-avl_005fmax_002f3-_0028avl_0029-2551"></a>
is true when <var>Key</var> is the greatest key in <var>AVL</var> and <var>Val</var> is its representation.
<br><dt><code>avl_height(</code><var>+AVL</var><code>, </code><var>-Height</var><code>)</code><dd><a name="index-avl_005fheight_002f2-_0028avl_0029-2552"></a><a name="index-avl_005fheight_002f2-_0028avl_0029-2553"></a>
is true when <var>Height</var> is the height of the given AVL tree, that is,
the longest path in the tree has <var>Height</var> 'node's on it. 
<br><dt><code>avl_size(</code><var>+AVL</var><code>, </code><var>-Size</var><code>)</code><dd><a name="index-avl_005fsize_002f2-_0028avl_0029-2554"></a><a name="index-avl_005fsize_002f2-_0028avl_0029-2555"></a>
is true when <var>Size</var> is the size of the AVL tree, the number of 'node's in it. 
<br><dt><code>portray_avl(</code><var>+AVL</var><code>)</code><dd><a name="index-portray_005favl_002f1-_0028avl_0029-2556"></a><a name="index-portray_005favl_002f1-_0028avl_0029-2557"></a>
writes an AVL tree to the current output stream in a pretty form so
that you can easily see what it is.  Note that an AVL tree written
out this way can NOT be read back in; for that use <code>writeq/1</code>.  The
point of this predicate is
<!-- that you can add a directive -->
to get AVL trees displayed nicely by <code>print/1</code>. 
<br><dt><code>avl_member(</code><var>?Key</var><code>, </code><var>+AVL</var><code>)</code><dd><a name="index-avl_005fmember_002f2-_0028avl_0029-2558"></a><a name="index-avl_005fmember_002f2-_0028avl_0029-2559"></a>
is true when <var>Key</var> is one of the keys in the given AVL.  This
predicate should be used to enumerate the keys, not to look for
a particular key (use <code>avl_fetch/2</code> or <code>avl_fetch/3</code> for that). 
The <var>Keys</var> are enumerated in ascending order. 
<br><dt><code>avl_member(</code><var>?Key</var><code>, </code><var>+AVL</var><code>, </code><var>?Val</var><code>)</code><dd><a name="index-avl_005fmember_002f3-_0028avl_0029-2560"></a><a name="index-avl_005fmember_002f3-_0028avl_0029-2561"></a>
is true when <var>Key</var> is one of the keys in the given AVL and <var>Val</var> is
the representation the AVL associates with that <var>Key</var>.  This predicate should
be used to enumerate the keys and their values, not to look up the
representation of a known key (use <code>avl_fetch/3</code>) for that.
The <var>Keys</var> are enumerated in ascending order. 
<br><dt><code>avl_fetch(</code><var>+Key</var><code>, </code><var>+AVL</var><code>)</code><dd><a name="index-avl_005ffetch_002f2-_0028avl_0029-2562"></a><a name="index-avl_005ffetch_002f2-_0028avl_0029-2563"></a>
is true when the (given) <var>Key</var> is one of the keys in the (given) AVL. 
Use this to test whether a known Key occurs in <var>AVL</var> and you don't
want to know the representation associated with it.
<br><dt><code>avl_fetch(</code><var>+Key</var><code>, </code><var>+AVL</var><code>, </code><var>-Val</var><code>)</code><dd><a name="index-avl_005ffetch_002f3-_0028avl_0029-2564"></a><a name="index-avl_005ffetch_002f3-_0028avl_0029-2565"></a>
is true when the (given) <var>Key</var> is one of the keys in the (given) AVL
and the representation associated with it therein is <var>Val</var>.  It should be
used to look up <em>known</em> keys, not to enumerate keys (use either
<code>avl_member/2</code> or <code>avl_member/3</code> for that). 
<br><dt><code>avl_next(</code><var>+Key</var><code>, </code><var>+AVL</var><code>, </code><var>-Knext</var><code>)</code><dd><a name="index-avl_005fnext_002f3-_0028avl_0029-2566"></a><a name="index-avl_005fnext_002f3-_0028avl_0029-2567"></a>
is true when <var>Knext</var> is the next key after <var>Key</var> in <var>AVL</var>;
that is, <var>Knext</var> is the smallest key in <var>AVL</var> such that <var>Knext @&gt; Key</var>. 
<br><dt><code>avl_next(</code><var>+Key</var><code>, </code><var>+AVL</var><code>, </code><var>-Knext</var><code>, </code><var>-Vnext</var><code>)</code><dd><a name="index-avl_005fnext_002f4-_0028avl_0029-2568"></a><a name="index-avl_005fnext_002f4-_0028avl_0029-2569"></a>
is true when <var>Knext</var> is the next key after <var>Key</var> in <var>AVL</var> and <var>Vnext</var> is the
representation associated with <var>Knext</var> in <var>AVL</var>.  That is, <var>Knext</var> is the smallest
key in <var>AVL</var> such that <var>Knext @&gt; Key</var>, and <code>avl_fetch(</code><var>Knext</var><code>, </code><var>AVL</var><code>, </code><var>Vnext</var><code>)</code>. 
<br><dt><code>avl_prev(</code><var>+Key</var><code>, </code><var>+AVL</var><code>, </code><var>-Kprev</var><code>)</code><dd><a name="index-avl_005fprev_002f3-_0028avl_0029-2570"></a><a name="index-avl_005fprev_002f3-_0028avl_0029-2571"></a>
is true when <var>Kprev</var> is the key previous to <var>Key</var> in <var>AVL</var>;
that is, <var>Kprev</var> is the greatest key in <var>AVL</var> such that <var>Kprev @&lt; Key</var>. 
<br><dt><code>avl_prev(</code><var>+Key</var><code>, </code><var>+AVL</var><code>, </code><var>-Kprev</var><code>, </code><var>-Vprev</var><code>)</code><dd><a name="index-avl_005fprev_002f4-_0028avl_0029-2572"></a><a name="index-avl_005fprev_002f4-_0028avl_0029-2573"></a>
is true when <var>Kprev</var> is the key previous to Key in <var>AVL</var> and <var>Vprev</var> is the
representation associated with <var>Kprev</var> in <var>AVL</var>.  That is, <var>Kprev</var> is the greatest key
in <var>AVL</var> such that <var>Kprev @&lt; Key</var>, and <code>avl_fetch(</code><var>Kprev</var><code>, </code><var>AVL</var><code>, </code><var>Vprev</var><code>)</code>. 
<br><dt><code>avl_change(</code><var>+Key</var><code>, </code><var>?AVL1</var><code>, </code><var>?Val1</var><code>, </code><var>?AVL2</var><code>, </code><var>?Val2</var><code>)</code><dd><a name="index-avl_005fchange_002f5-_0028avl_0029-2574"></a><a name="index-avl_005fchange_002f5-_0028avl_0029-2575"></a>
is true when <var>AVL1</var> and <var>AVL2</var> are avl trees of exactly the same shape,
<var>Key</var> is a key of both of them, <var>Val1</var> is the representation associated with <var>Key</var>
in <var>AVL1</var> and <var>Val2</var> is the representation associated with it in <var>AVL2</var>, and when
<var>AVL1</var> and <var>AVL2</var> are identical except perhaps for the representation they assign
to <var>Key</var>.  Use this to change the representation associated with a <var>Key</var> which is
already present, not to insert a new <var>Key</var> (it won't). 
<br><dt><code>ord_list_to_avl(</code><var>+List</var><code>, </code><var>-AVL</var><code>)</code><dd><a name="index-ord_005flist_005fto_005favl_002f2-_0028avl_0029-2576"></a><a name="index-ord_005flist_005fto_005favl_002f2-_0028avl_0029-2577"></a>
is given a list of <var>Key-Val</var> pairs where the <var>Keys</var> are already in
standard order with no duplicates (this is not checked) and
returns an AVL representing the same associations.  This takes
<var>O(N)</var> time, unlike <code>list_to_avl/2</code> which takes <var>O(N lg N)</var>. 
<br><dt><code>list_to_avl(</code><var>+Pairs</var><code>, </code><var>-AVL</var><code>)</code><dd><a name="index-list_005fto_005favl_002f2-_0028avl_0029-2578"></a><a name="index-list_005fto_005favl_002f2-_0028avl_0029-2579"></a>
is given a list of <var>Key-Val</var> pairs where the <var>Keys</var> are in no particular
order (but are sufficiently instantiated to be told apart) and
returns an AVL representing the same associations.  This works by
starting with an empty tree and inserting the elements of the list
into it.  This takes <var>O(N lg N)</var> time.  Since it is possible to read
off a sorted list in <var>O(N)</var> time from the result, <var>O(N lg N)</var> is as good as
can possibly be done.  If the same <var>Key</var> appears more than once in the
input, the last representation associated with it will be used.
Could be defined as:

     <pre class="example">          list_to_avl(Pairs, AVL) :-
          	(   foreach(K-V,Pairs),
          	    fromto(empty,AVL0,AVL1,AVL)
          	do  avl_store(K, AVL0, V, AVL1)
          	).
</pre>
     <br><dt><code>avl_store(</code><var>+Key</var><code>, </code><var>+OldAVL</var><code>, </code><var>+Val</var><code>, </code><var>+NewAVL</var><code>)</code><dd><a name="index-avl_005fstore_002f4-_0028avl_0029-2580"></a><a name="index-avl_005fstore_002f4-_0028avl_0029-2581"></a>
is true when <var>OldAVL</var> and <var>NewAVL</var> define the same finite function
except that <var>NewAVL</var> associates <var>Val</var> with <var>Key</var>.  <var>OldAVL</var> need not have
associated any representation at all with <var>Key</var>.  When it didn't, you can
read this as "insert <var>(Key-&gt;Val)</var> into <var>OldAVL</var> giving <var>NewAVL</var>". 
<br><dt><code>avl_incr(</code><var>+Key</var><code>, </code><var>+OldAVL</var><code>, </code><var>+Inc</var><code>, </code><var>+NewAVL</var><code>)</code><dd><a name="index-avl_005fincr_002f4-_0028avl_0029-2582"></a><a name="index-avl_005fincr_002f4-_0028avl_0029-2583"></a>
if <var>Key</var> is not present in <var>OldAVL</var>, adds <var>Key-&gt;Incr</var>. 
if <var>Key-&gt;N</var> is present in <var>OldAvl</var>, changes it to <var>Key-&gt;N+Incr</var>. 
<br><dt><code>avl_delete(</code><var>+Key</var><code>, </code><var>+OldAVL</var><code>, </code><var>-Val</var><code>, </code><var>-NewAVL</var><code>)</code><dd><a name="index-avl_005fdelete_002f4-_0028avl_0029-2584"></a><a name="index-avl_005fdelete_002f4-_0028avl_0029-2585"></a>
is true when <var>OldAVL</var> and <var>NewAVL</var> define the same finite function
except that <var>OldAVL</var> associates <var>Key</var> with <var>Val</var> and <var>NewAVL</var> doesn't
associate <var>Key</var> with any representation.
<br><dt><code>avl_del_min(</code><var>+OldAVL</var><code>, </code><var>-Key</var><code>, </code><var>-Val</var><code>, </code><var>-NewAVL</var><code>)</code><dd><a name="index-avl_005fdel_005fmin_002f4-_0028avl_0029-2586"></a><a name="index-avl_005fdel_005fmin_002f4-_0028avl_0029-2587"></a>
is true when <var>OldAVL</var> and <var>NewAVL</var> define the same finite function
except that <var>OldAVL</var> associates <var>Key</var> with <var>Val</var> and <var>NewAVL</var> doesn't
associate <var>Key</var> with any representation and <var>Key</var> precedes all other keys in <var>OldAVL</var>.
<br><dt><code>avl_del_max(</code><var>+OldAVL</var><code>, </code><var>-Key</var><code>, </code><var>-Val</var><code>, </code><var>-NewAVL</var><code>)</code><dd><a name="index-avl_005fdel_005fmax_002f4-_0028avl_0029-2588"></a><a name="index-avl_005fdel_005fmax_002f4-_0028avl_0029-2589"></a>
is true when <var>OldAVL</var> and <var>NewAVL</var> define the same finite function
except that <var>OldAVL</var> associates <var>Key</var> with <var>Val</var> and <var>NewAVL</var> doesn't
associate <var>Key</var> with any representation and
<var>Key</var> is preceded by all other keys in <var>OldAVL</var>. 
<br><dt><code>avl_map(</code><var>:Pred</var><code>, </code><var>+AVL</var><code>)</code><dd><a name="index-avl_005fmap_002f2-_0028avl_0029-2590"></a><a name="index-avl_005fmap_002f2-_0028avl_0029-2591"></a>
is true when <var>AVL</var> is an association tree, and for each <var>Key</var>,
if <var>Key</var> is associated with <var>Value</var> in <var>AVL</var>, <var>Pred(Value)</var> is true. 
<br><dt><code>avl_map(</code><var>:Pred</var><code>, </code><var>+OldAVL</var><code>, </code><var>-NewAVL</var><code>)</code><dd><a name="index-avl_005fmap_002f3-_0028avl_0029-2592"></a><a name="index-avl_005fmap_002f3-_0028avl_0029-2593"></a>
is true when <var>OldAVL</var> and <var>NewAVL</var> are association trees of the
same shape, and for each <var>Key</var>, if <var>Key</var> is associated with <var>Old</var> in
<var>OldAVL</var> and with <var>New</var> in <var>NewAVL</var>, <var>Pred(Old,New)</var> is true. 
</dl>

<div class="logo">
<a href="http://sicstus.sics.se/">
<table><tr><td>&nbsp;</td></tr></table>
</a>
</div>
<div class="node">
<ul class="node">
<li><a href="index.html#Top">User's Manual</a>
<hr>
<li><a href="index.html#TOC">Table of Contents</a>
</ul>
</div>
<hr>
<a HREF="mailto:sicstus-support@sics.se?subject=Documentation%20feedback%20on%20html/sicstus/lib_002davl.html&amp;body=Feedback%20on%20documentation%20node%20html/sicstus/lib_002davl.html%20in%20User's%20Manual.">Send feedback on this subject.</a>
   </body></html>

