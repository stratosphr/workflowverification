<html lang="en">
<head>
<title>mpg-ref-cat - SICStus Prolog</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="SICStus Prolog">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="mpg_002dref.html#mpg_002dref" title="mpg-ref">
<link rel="prev" href="mpg_002dref_002dmod.html#mpg_002dref_002dmod" title="mpg-ref-mod">
<link rel="next" href="mpg_002dref_002daty.html#mpg_002dref_002daty" title="mpg-ref-aty">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
<link href="texinfo.css" rel="stylesheet" type="text/css">
</head>
<body>
<div class="node">
<a name="mpg-ref-cat"></a>
<a name="mpg_002dref_002dcat"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="mpg_002dref_002daty.html#mpg_002dref_002daty">mpg-ref-aty</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="mpg_002dref_002dmod.html#mpg_002dref_002dmod">mpg-ref-mod</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="mpg_002dref.html#mpg_002dref">mpg-ref</a>
<hr>
</div>

<h4 class="subsection">11.1.3 Predicate Annotation</h4>

<p><a name="index-predicates_002c-annotations-4301"></a>
<a name="index-built_002din-predicates_002c-annotations-4302"></a>
This section describes the annotations of predicates and how they are
indicated in the reference pages for predicates of each given
annotation.  The annotations appear to the right of the title of the
reference page.

     
<a name="index-hookable-_0028predicate-annotation_0029-4303"></a>
<dl><dt><dfn>hookable</dfn><dd>The behavior of the
predicate can be customized/redefined by defining one or more hooks. 
The mode and type annotations of a hookable predicate might not be absolute,
since hooks added by the user can change the behavior.

     <p><a name="index-hook-_0028predicate-annotation_0029-4304"></a><br><dt><dfn>hook</dfn><dd>The predicate is user defined, and is called by a
<dfn>hookable</dfn> builtin. Most hooks must be defined in module <code>user</code>. For a
hook, the mode and type annotations should be seen as guide-lines to
the user who wants to add his own hook; they describe how the
predicate is used by the system.

     <p><a name="index-extendible-_0028predicate-annotation_0029-4305"></a><br><dt><dfn>extendible</dfn><dd>A multifile predicate, to which new clauses
can be added by the user. For such a predicate, the mode and type
annotations should be seen as guide-lines to the user who wants to
extend the predicate; they describe how the predicate is used by the
system.

     <p><a name="index-declaration-_0028predicate-annotation_0029-4306"></a><br><dt><dfn>declaration</dfn><dd>You cannot call these directly but they can appear in
files as &lsquo;<samp><span class="samp">:- </span><var>declaration</var></samp>&rsquo; and give information to the compiler. 
The goal template is preceded by &lsquo;<samp><span class="samp">:-</span></samp>&rsquo; in the <b>Synopsis</b>.

     <!-- [Not very helpful, and difficult to draw the line. -Mats] -->
     <!-- @cindex meta-logical (predicate annotation) -->
     <!-- @item meta-logical -->
     <!-- A predicate that performs operations that require reasoning about the -->
     <!-- current instantiation of terms, or decomposing terms into their -->
     <!-- constituents.  Such operations cannot be expressed using predicate -->
     <!-- definitions with a finite number of clauses. -->
     <p><a name="index-development-_0028predicate-annotation_0029-4307"></a><br><dt><dfn>development</dfn><dd>A predicate that is defined in the development system only, i.e. not
in runtime systems.

     <p><a name="index-ISO-_0028predicate-annotation_0029-4308"></a><br><dt><dfn>ISO</dfn><dd>A predicate that is part of the ISO Prolog Standard.

     <p><a name="index-deprecated-_0028predicate-annotation_0029-4309"></a><br><dt><dfn>deprecated</dfn><dd>A predicate that is not recommended in new code and that
could be withdrawn in a future release. 
</dl>

   <p><dfn>Meta-predicates</dfn> and <dfn>operators</dfn> are recognizable by the implicit
conventions described below.

     <ul>
<li><a name="index-meta_002dpredicates-_0028definition_0029-4310"></a><dfn>Meta-predicates</dfn> are predicates that need to assume some module. 
The reference pages of these predicates indicate which arguments are
in a module expansion position by prefixing such arguments by &lsquo;<samp><span class="samp">:</span></samp>&rsquo;
in the <b>Arguments</b> field.  That is, the argument can be preceded by
a module prefix (an <dfn>atom</dfn> followed by a colon).  For example:
     <pre class="example">          assert(mod:a(1), Ref)
</pre>
     <p>If no module prefix is supplied, it will implicitly be set to the
calling module.  If the module prefix is a variable, an instantiation
error will be raised.  If it is not an atom a type error will be
raised.  So in any meta-predicate reference page the following
exceptions are implicit:

     <p><a name="index-module-name-expansion_002c-exceptions-4311"></a>
<a name="index-exceptions_002c-module-name-expansion-4312"></a>

<h4 class="subheading">Exceptions</h4>

          <dl>
<dt><code>instantiation_error</code><dd>A module prefix is written as a variable.

          <br><dt><code>type_error</code><dd>A module prefix is not an atom. 
</dl>

     <li>Whenever the name of a built-in predicate is defined
as <dfn>operator</dfn>, the name is presented in the <b>Synopsis</b> as an
operator, for example
     <pre class="example">          <code>:- initialization</code> <var>+Goal</var>                 &nbsp;<!-- /@w --> (A)
          <var>+Term1</var> <code>@&gt;</code> <var>+Term2</var>             &nbsp;<!-- /@w --> (B)
</pre>
     <p><a name="index-operators_002c-reference-page-convention-4313"></a>

     <p>It is thus always possible to see if a name is an
operator or not. The predicate can, of course, be written using the
canonical representation, even when the name is an operator.  Thus (A)
and (B) can be written as (C) and (D), respectively:
     <pre class="example">          <code>:- initialization(</code><var>+Goal</var><code>)</code>                 &nbsp;<!-- /@w --> (C)
          <code>@&gt;</code><var>(+Term1,  +Term2)</var>               &nbsp;<!-- /@w --> (D)
</pre>
     </ul>

<div class="logo">
<a href="http://sicstus.sics.se/">
<table><tr><td>&nbsp;</td></tr></table>
</a>
</div>
<div class="node">
<ul class="node">
<li><a href="index.html#Top">User's Manual</a>
<hr>
<li><a href="index.html#TOC">Table of Contents</a>
</ul>
</div>
<hr>
<a HREF="mailto:sicstus-support@sics.se?subject=Documentation%20feedback%20on%20html/sicstus/mpg_002dref_002dcat.html&amp;body=Feedback%20on%20documentation%20node%20html/sicstus/mpg_002dref_002dcat.html%20in%20User's%20Manual.">Send feedback on this subject.</a>
   </body></html>

