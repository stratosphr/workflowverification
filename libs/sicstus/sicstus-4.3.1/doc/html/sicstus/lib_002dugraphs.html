<html lang="en">
<head>
<title>lib-ugraphs - SICStus Prolog</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="SICStus Prolog">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="The-Prolog-Library.html#The-Prolog-Library" title="The Prolog Library">
<link rel="prev" href="lib_002dtypes.html#lib_002dtypes" title="lib-types">
<link rel="next" href="lib_002dvarnumbers.html#lib_002dvarnumbers" title="lib-varnumbers">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
<link href="texinfo.css" rel="stylesheet" type="text/css">
</head>
<body>
<div class="node">
<a name="lib-ugraphs"></a>
<a name="lib_002dugraphs"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="lib_002dvarnumbers.html#lib_002dvarnumbers">lib-varnumbers</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="lib_002dtypes.html#lib_002dtypes">lib-types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="The-Prolog-Library.html#The-Prolog-Library">The Prolog Library</a>
<hr>
</div>

<h3 class="section">10.42 Unweighted Graph Operations&mdash;<code>library(ugraphs)</code></h3>

<p>This library module provides operations on directed graphs. 
An unweighted directed graph (ugraph) is represented as a list of
<var>(vertex-neighbors)</var> pairs, where the pairs are in standard order
(as produced by <code>keysort/2</code> with unique keys) and the neighbors of
each vertex are also in standard order (as produced by <code>sort/2</code>), and
every neighbor appears as a vertex even if it has no neighbors
itself.

   <p>An undirected graph is represented as a directed graph where for
each edge <var>(U,V)</var> there is a symmetric edge <var>(V,U)</var>.

   <p>An edge <var>(U,V)</var> is represented as the term <var>U-V</var>.

   <p>A vertex can be any term.  Two vertices are distinct iff they are
not identical (<code>==</code>).

   <p>A path is represented as a list of vertices. 
No vertex can appear twice in a path.

   <p>Exported predicates:

     <dl>
<dt><code>vertices_edges_to_ugraph(</code><var>+Vertices</var><code>, </code><var>+Edges</var><code>, </code><var>-Graph</var><code>)</code><dd><a name="index-vertices_005fedges_005fto_005fugraph_002f3-_0028ugraphs_0029-4123"></a><a name="index-vertices_005fedges_005fto_005fugraph_002f3-_0028ugraphs_0029-4124"></a>
is true if <var>Vertices</var> is a list of vertices, <var>Edges</var> is a list of edges,
and <var>Graph</var> is a graph built from <var>Vertices</var> and <var>Edges</var>.  <var>Vertices</var> and
<var>Edges</var> may be in any order.  The vertices mentioned in <var>Edges</var> do not
have to occur explicitly in <var>Vertices</var>.  <var>Vertices</var> may be used to
specify vertices that are not connected to any edges. 
<br><dt><code>vertices(</code><var>+Graph</var><code>, </code><var>-Vertices</var><code>)</code><dd><a name="index-vertices_002f2-_0028ugraphs_0029-4125"></a><a name="index-vertices_002f2-_0028ugraphs_0029-4126"></a>
unifies <var>Vertices</var> with the vertices in <var>Graph</var>. 
Could be defined as:

     <pre class="example">          vertices(Graph, Vertices) :-
          	(   foreach(V-_,Graph),
          	    foreach(V,Vertices)
          	do  true
          	).
</pre>
     <br><dt><code>edges(</code><var>+Graph</var><code>, </code><var>-Edges</var><code>)</code><dd><a name="index-edges_002f2-_0028ugraphs_0029-4127"></a><a name="index-edges_002f2-_0028ugraphs_0029-4128"></a>
unifies <var>Edges</var> with the edges in <var>Graph</var>. 
Could be defined as:

     <pre class="example">          edges(Graph, Edges) :-
          	(   foreach(V1-Neibs,Graph),
          	    fromto(Edges,S0,S,[])
          	do  (   foreach(V2,Neibs),
          		param(V1),
          		fromto(S0,[V1-V2|S1],S1,S)
          	    do  true
          	    )
          	).
</pre>
     <br><dt><code>add_vertices(</code><var>+Graph1</var><code>, </code><var>+Vertices</var><code>, </code><var>-Graph2</var><code>)</code><dd><a name="index-add_005fvertices_002f3-_0028ugraphs_0029-4129"></a><a name="index-add_005fvertices_002f3-_0028ugraphs_0029-4130"></a>
is true if <var>Graph2</var> is <var>Graph1</var> with <var>Vertices</var> added to it. 
<br><dt><code>del_vertices(</code><var>+Graph1</var><code>, </code><var>+Vertices</var><code>, </code><var>-Graph2</var><code>)</code><dd><a name="index-del_005fvertices_002f3-_0028ugraphs_0029-4131"></a><a name="index-del_005fvertices_002f3-_0028ugraphs_0029-4132"></a>
is true if <var>Graph2</var> is <var>Graph1</var> with <var>Vertices</var> and all edges to and from
<var>Vertices</var> removed from it. 
<br><dt><code>add_edges(</code><var>+Graph1</var><code>, </code><var>+Edges</var><code>, </code><var>-Graph2</var><code>)</code><dd><a name="index-add_005fedges_002f3-_0028ugraphs_0029-4133"></a><a name="index-add_005fedges_002f3-_0028ugraphs_0029-4134"></a>
is true if <var>Graph2</var> is <var>Graph1</var> with <var>Edges</var> and their "to" and "from"
vertices added to it. 
<br><dt><code>del_edges(</code><var>+Graph1</var><code>, </code><var>+Edges</var><code>, </code><var>-Graph2</var><code>)</code><dd><a name="index-del_005fedges_002f3-_0028ugraphs_0029-4135"></a><a name="index-del_005fedges_002f3-_0028ugraphs_0029-4136"></a>
is true if <var>Graph2</var> is <var>Graph1</var> with <var>Edges</var> removed from it. 
<br><dt><code>transpose_ugraph(</code><var>+Graph</var><code>, </code><var>-Transpose</var><code>)</code><dd><a name="index-transpose_005fugraph_002f2-_0028ugraphs_0029-4137"></a><a name="index-transpose_005fugraph_002f2-_0028ugraphs_0029-4138"></a>
is true if <var>Transpose</var> is the graph computed by replacing each edge
<var>(u,v)</var> in <var>Graph</var> by its symmetric edge <var>(v,u)</var>.  It can only be used
one way around.  The cost is <var>O(N log N)</var>. 
<br><dt><code>neighbors(</code><var>+Vertex</var><code>, </code><var>+Graph</var><code>, </code><var>-Neighbors</var><code>)</code><dt><code>neighbours(</code><var>+Vertex</var><code>, </code><var>+Graph</var><code>, </code><var>-Neighbors</var><code>)</code><dd><a name="index-neighbors_002f3-_0028ugraphs_0029-4139"></a><a name="index-neighbors_002f3-_0028ugraphs_0029-4140"></a>
<a name="index-neighbours_002f3-_0028ugraphs_0029-4141"></a><a name="index-neighbours_002f3-_0028ugraphs_0029-4142"></a>
is true if <var>Vertex</var> is a vertex in <var>Graph</var> and <var>Neighbors</var> are its neighbors. 
<br><dt><code>complement(</code><var>+Graph</var><code>, </code><var>-Complement</var><code>)</code><dd><a name="index-complement_002f2-_0028ugraphs_0029-4143"></a><a name="index-complement_002f2-_0028ugraphs_0029-4144"></a>
<var>Complement</var> is the complement graph of <var>Graph</var>, i.e. the graph that has
the same vertices as <var>Graph</var> but only the edges that are not in <var>Graph</var>. 
<br><dt><code>compose(</code><var>+G1</var><code>, </code><var>+G2</var><code>, </code><var>-Composition</var><code>)</code><dd><a name="index-compose_002f3-_0028ugraphs_0029-4145"></a><a name="index-compose_002f3-_0028ugraphs_0029-4146"></a>
computes <var>Composition</var> as the composition of two graphs, which need
not have the same set of vertices. 
<br><dt><code>transitive_closure(</code><var>+Graph</var><code>, </code><var>-Closure</var><code>)</code><dd><a name="index-transitive_005fclosure_002f2-_0028ugraphs_0029-4147"></a><a name="index-transitive_005fclosure_002f2-_0028ugraphs_0029-4148"></a>
computes <var>Closure</var> as the transitive closure of <var>Graph</var> in <var>O(N^3)</var> time. 
<br><dt><code>symmetric_closure(</code><var>+Graph</var><code>, </code><var>-Closure</var><code>)</code><dd><a name="index-symmetric_005fclosure_002f2-_0028ugraphs_0029-4149"></a><a name="index-symmetric_005fclosure_002f2-_0028ugraphs_0029-4150"></a>
computes <var>Closure</var> as the symmetric closure of <var>Graph</var>, i.e. for each
edge <var>(u,v)</var> in <var>Graph</var>, add its symmetric edge <var>(v,u)</var>.  Approx. <var>O(N log N)</var>
time.  This is useful for making a directed graph undirected. 
Could be defined as:

     <pre class="example">          symmetric_closure(Graph, Closure) :-
          	transpose_ugraph(Graph, Transpose),
          	(   foreach(V-Neibs1,Graph),
          	    foreach(V-Neibs2,Transpose),
          	    foreach(V-Neibs,Closure)
          	do  ord_union(Neibs1, Neibs2, Neibs)
          	).
</pre>
     <br><dt><code>top_sort(</code><var>+Graph</var><code>, </code><var>-Sorted</var><code>)</code><dd><a name="index-top_005fsort_002f2-_0028ugraphs_0029-4151"></a><a name="index-top_005fsort_002f2-_0028ugraphs_0029-4152"></a>
finds a topological ordering of <var>Graph</var> and returns the ordering
as a list of <var>Sorted</var> vertices.  Fails iff no ordering exists, i.e. 
iff the graph contains cycles.  Approx. <var>O(N log N)</var> time. 
<br><dt><code>max_path(</code><var>+V1</var><code>, </code><var>+V2</var><code>, </code><var>+Graph</var><code>, </code><var>-Path</var><code>, </code><var>-Cost</var><code>)</code><dd><a name="index-max_005fpath_002f5-_0028ugraphs_0029-4153"></a><a name="index-max_005fpath_002f5-_0028ugraphs_0029-4154"></a>
is true if <var>Path</var> is a list of vertices constituting a longest path
of cost <var>Cost</var> from <var>V1</var> to <var>V2</var> in <var>Graph</var>, there being no cyclic paths from
<var>V1</var> to <var>V2</var>.  Takes <var>O(N^2)</var> time. 
<br><dt><code>min_path(</code><var>+V1</var><code>, </code><var>+V2</var><code>, </code><var>+Graph</var><code>, </code><var>-Path</var><code>, </code><var>-Length</var><code>)</code><dd><a name="index-min_005fpath_002f5-_0028ugraphs_0029-4155"></a><a name="index-min_005fpath_002f5-_0028ugraphs_0029-4156"></a>
is true if <var>Path</var> is a list of vertices constituting a shortest path
of length <var>Length</var> from <var>V1</var> to <var>V2</var> in <var>Graph</var>.  Takes <var>O(N^2)</var> time. 
<br><dt><code>min_paths(</code><var>+Vertex</var><code>, </code><var>+Graph</var><code>, </code><var>-Tree</var><code>)</code><dd><a name="index-min_005fpaths_002f3-_0028ugraphs_0029-4157"></a><a name="index-min_005fpaths_002f3-_0028ugraphs_0029-4158"></a>
is true if <var>Tree</var> is a tree of all the shortest paths from <var>Vertex</var> to
every other vertex in <var>Graph</var>.  This is the single-source shortest
paths problem.  The algorithm is straightforward. 
<br><dt><code>path(</code><var>+Vertex</var><code>, </code><var>+Graph</var><code>, </code><var>-Path</var><code>)</code><dd><a name="index-path_002f3-_0028ugraphs_0029-4159"></a><a name="index-path_002f3-_0028ugraphs_0029-4160"></a>
is given a <var>Graph</var> and a <var>Vertex</var> of that <var>Graph</var>, and returns a maximal
<var>Path</var> rooted at <var>Vertex</var>, enumerating more <var>Paths</var> on backtracking. 
<br><dt><code>reduce(</code><var>+Graph</var><code>, </code><var>-Reduced</var><code>)</code><dd><a name="index-reduce_002f2-_0028ugraphs_0029-4161"></a><a name="index-reduce_002f2-_0028ugraphs_0029-4162"></a>
is true if <var>Reduced</var> is the reduced graph for <var>Graph</var>. The vertices of
the reduced graph are the strongly connected components of <var>Graph</var>. 
There is an edge in <var>Reduced</var> from <var>u</var> to <var>v</var> iff there is an edge in
<var>Graph</var> from one of the vertices in <var>u</var> to one of the vertices in <var>v</var>. A
strongly connected component is a maximal set of vertices where
each vertex has a path to every other vertex. 
Algorithm from "Algorithms" by Sedgewick, page 482, Tarjan's algorithm. 
<br><dt><code>reachable(</code><var>+Vertex</var><code>, </code><var>+Graph</var><code>, </code><var>-Reachable</var><code>)</code><dd><a name="index-reachable_002f3-_0028ugraphs_0029-4163"></a><a name="index-reachable_002f3-_0028ugraphs_0029-4164"></a>
is given a Graph and a <var>Vertex</var> of that <var>Graph</var>, and returns the set
of vertices that are <var>Reachable</var> from that <var>Vertex</var>.  Takes <var>O(N^2)</var>
time. 
<br><dt><code>random_ugraph(</code><var>+P</var><code>, </code><var>+N</var><code>, </code><var>-Graph</var><code>)</code><dd><a name="index-random_005fugraph_002f3-_0028ugraphs_0029-4165"></a><a name="index-random_005fugraph_002f3-_0028ugraphs_0029-4166"></a>
where <var>P</var> is a probability, unifies <var>Graph</var> with a random graph of <var>N</var>
vertices where each possible edge is included with probability <var>P</var>. 
<br><dt><code>min_tree(</code><var>+Graph</var><code>, </code><var>-Tree</var><code>, </code><var>-Cost</var><code>)</code><dd><a name="index-min_005ftree_002f3-_0028ugraphs_0029-4167"></a><a name="index-min_005ftree_002f3-_0028ugraphs_0029-4168"></a>
is true if <var>Tree</var> is a spanning tree of an <em>undirected</em> <var>Graph</var> with
cost <var>Cost</var>, if it exists.  Using a version of Prim's algorithm. 
</dl>

<div class="logo">
<a href="http://sicstus.sics.se/">
<table><tr><td>&nbsp;</td></tr></table>
</a>
</div>
<div class="node">
<ul class="node">
<li><a href="index.html#Top">User's Manual</a>
<hr>
<li><a href="index.html#TOC">Table of Contents</a>
</ul>
</div>
<hr>
<a HREF="mailto:sicstus-support@sics.se?subject=Documentation%20feedback%20on%20html/sicstus/lib_002dugraphs.html&amp;body=Feedback%20on%20documentation%20node%20html/sicstus/lib_002dugraphs.html%20in%20User's%20Manual.">Send feedback on this subject.</a>
   </body></html>

